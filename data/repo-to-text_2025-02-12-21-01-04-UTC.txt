Directory: customgpt-api-sdks

Directory Structure:
```
.
├── .gitignore
├── LICENSE
├── README.md
├── SECURITY.md
├── customgpt-client
│   ├── customgpt-client/README.md
│   ├── customgpt-client/customgpt_client
│   │   ├── customgpt-client/customgpt_client/__init__.py
│   │   ├── customgpt-client/customgpt_client/api
│   │   │   ├── customgpt-client/customgpt_client/api/__init__.py
│   │   │   ├── customgpt-client/customgpt_client/api/citations
│   │   │   │   ├── customgpt-client/customgpt_client/api/citations/__init__.py
│   │   │   │   └── customgpt-client/customgpt_client/api/citations/get_citation.py
│   │   │   ├── customgpt-client/customgpt_client/api/conversations
│   │   │   │   ├── customgpt-client/customgpt_client/api/conversations/__init__.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/conversations/create_conversation.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/conversations/delete_conversation.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/conversations/get_conversations.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/conversations/messages_conversation.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/conversations/send_message.py
│   │   │   │   └── customgpt-client/customgpt_client/api/conversations/update_conversation.py
│   │   │   ├── customgpt-client/customgpt_client/api/page_metadata
│   │   │   │   ├── customgpt-client/customgpt_client/api/page_metadata/__init__.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/page_metadata/get_page_metadata.py
│   │   │   │   └── customgpt-client/customgpt_client/api/page_metadata/update_page_metadata.py
│   │   │   ├── customgpt-client/customgpt_client/api/pages
│   │   │   │   ├── customgpt-client/customgpt_client/api/pages/__init__.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/pages/delete_page.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/pages/get_pages.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/pages/preview_citation.py
│   │   │   │   └── customgpt-client/customgpt_client/api/pages/reindex_page.py
│   │   │   ├── customgpt-client/customgpt_client/api/project_plugins
│   │   │   │   ├── customgpt-client/customgpt_client/api/project_plugins/__init__.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/project_plugins/create_plugin.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/project_plugins/get_plugin.py
│   │   │   │   └── customgpt-client/customgpt_client/api/project_plugins/update_plugin.py
│   │   │   ├── customgpt-client/customgpt_client/api/project_settings
│   │   │   │   ├── customgpt-client/customgpt_client/api/project_settings/__init__.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/project_settings/get_settings.py
│   │   │   │   └── customgpt-client/customgpt_client/api/project_settings/update_settings.py
│   │   │   ├── customgpt-client/customgpt_client/api/projects
│   │   │   │   ├── customgpt-client/customgpt_client/api/projects/__init__.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/projects/create_project.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/projects/delete_project.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/projects/get_project.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/projects/list_projects.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/projects/stats_project.py
│   │   │   │   └── customgpt-client/customgpt_client/api/projects/update_project.py
│   │   │   ├── customgpt-client/customgpt_client/api/sources
│   │   │   │   ├── customgpt-client/customgpt_client/api/sources/__init__.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/sources/create_source.py
│   │   │   │   ├── customgpt-client/customgpt_client/api/sources/delete_source.py
│   │   │   │   └── customgpt-client/customgpt_client/api/sources/list_sources.py
│   │   │   └── customgpt-client/customgpt_client/api/users
│   │   │       ├── customgpt-client/customgpt_client/api/users/__init__.py
│   │   │       ├── customgpt-client/customgpt_client/api/users/get_user.py
│   │   │       └── customgpt-client/customgpt_client/api/users/update_user.py
│   │   ├── customgpt-client/customgpt_client/client.py
│   │   ├── customgpt-client/customgpt_client/errors.py
│   │   ├── customgpt-client/customgpt_client/models
│   │   │   ├── customgpt-client/customgpt_client/models/__init__.py
│   │   │   ├── customgpt-client/customgpt_client/models/conversation.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_json_body.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_201.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_201_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_201_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_conversation_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_json_body.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_201.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_201_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_201_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_plugin_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_multipart_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_201.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_201_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_201_data_type.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_201_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_400_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_project_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_multipart_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_201.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_201_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_201_data_pages_item.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_201_data_pages_item_crawl_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_201_data_pages_item_index_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_201_data_settings.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_201_data_type.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_201_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_400_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/create_source_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_conversation_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_page_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_project_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/delete_source_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_citation_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_order.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_200_data_data_item.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_conversations_user_filter.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_page_metadata_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_order.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_200_data_pages.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_200_data_pages_data_item.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_200_data_pages_data_item_crawl_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_200_data_pages_data_item_index_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_200_data_project.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_200_data_project_type.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_pages_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_plugin_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_200_data_type.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_project_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_200_data_citations_view_type.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_settings_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_user_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_user_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_user_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_user_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_user_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_user_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_user_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_user_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_user_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_user_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/get_user_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_order.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_response_200_data_data_item.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_response_200_data_data_item_type.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_projects_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_data_sitemaps_item.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_data_sitemaps_item_pages_item.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_data_sitemaps_item_pages_item_crawl_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_data_sitemaps_item_pages_item_index_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_data_sitemaps_item_settings.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_data_sitemaps_item_type.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_data_uploads.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_data_uploads_pages_item.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_data_uploads_pages_item_crawl_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_data_uploads_pages_item_index_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_data_uploads_settings.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_data_uploads_type.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/list_sources_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_order.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_200_data_conversation.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_200_data_messages.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_200_data_messages_data_item.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_200_data_messages_data_item_metadata.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/messages_conversation_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/open_graph_cache.py
│   │   │   ├── customgpt-client/customgpt_client/models/page.py
│   │   │   ├── customgpt-client/customgpt_client/models/page_crawl_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/page_index_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/page_metadata.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/preview_citation_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/project.py
│   │   │   ├── customgpt-client/customgpt_client/models/project_plugin.py
│   │   │   ├── customgpt-client/customgpt_client/models/project_settings.py
│   │   │   ├── customgpt-client/customgpt_client/models/project_settings_citations_view_type.py
│   │   │   ├── customgpt-client/customgpt_client/models/project_settings_response_source.py
│   │   │   ├── customgpt-client/customgpt_client/models/project_source.py
│   │   │   ├── customgpt-client/customgpt_client/models/project_source_settings.py
│   │   │   ├── customgpt-client/customgpt_client/models/project_source_type.py
│   │   │   ├── customgpt-client/customgpt_client/models/project_type.py
│   │   │   ├── customgpt-client/customgpt_client/models/prompt_history.py
│   │   │   ├── customgpt-client/customgpt_client/models/prompt_history_metadata.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_403.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_403_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_403_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_403_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_403_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/reindex_page_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_json_body.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_200_data_metadata.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/send_message_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/stats_project_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_json_body.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_conversation_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_json_body.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_page_metadata_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_json_body.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_plugin_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_multipart_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_200_data_type.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_404.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_404_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_404_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_404_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_404_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_project_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_multipart_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_multipart_data_citations_view_type.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_400.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_400_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_400_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_400_data_message.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_400_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_settings_response_500_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_user_multipart_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_user_response_200.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_user_response_200_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_user_response_200_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_user_response_401.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_user_response_401_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_user_response_401_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_user_response_401_status.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_user_response_500.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_user_response_500_data.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_user_response_500_data_code.py
│   │   │   ├── customgpt-client/customgpt_client/models/update_user_response_500_status.py
│   │   │   └── customgpt-client/customgpt_client/models/user.py
│   │   ├── customgpt-client/customgpt_client/py.typed
│   │   └── customgpt-client/customgpt_client/types.py
│   ├── customgpt-client/pyproject.toml
│   └── customgpt-client/tests
│       ├── customgpt-client/tests/__init__.py
│       ├── customgpt-client/tests/credentials.py
│       ├── customgpt-client/tests/file
│       │   └── customgpt-client/tests/file/vanka.pdf
│       ├── customgpt-client/tests/test_citations.py
│       ├── customgpt-client/tests/test_conversations.py
│       ├── customgpt-client/tests/test_page_metadata.py
│       ├── customgpt-client/tests/test_pages.py
│       ├── customgpt-client/tests/test_plugins.py
│       ├── customgpt-client/tests/test_project_settings.py
│       ├── customgpt-client/tests/test_projects.py
│       ├── customgpt-client/tests/test_sources.py
│       └── customgpt-client/tests/test_users.py
├── requirement.txt
└── templates
    ├── templates/README.md.jinja
    ├── templates/api_init.py.jinja
    ├── templates/client.py.jinja
    ├── templates/endpoint_init.py.jinja
    ├── templates/endpoint_macros.py.jinja
    ├── templates/endpoint_module.py.jinja
    ├── templates/errors.py.jinja
    ├── templates/helpers.jinja
    ├── templates/int_enum.py.jinja
    ├── templates/model.py.jinja
    ├── templates/models_init.py.jinja
    ├── templates/package_init.py.jinja
    ├── templates/property_templates
    │   ├── templates/property_templates/any_property.py.jinja
    │   ├── templates/property_templates/boolean_property.py.jinja
    │   ├── templates/property_templates/date_property.py.jinja
    │   ├── templates/property_templates/datetime_property.py.jinja
    │   ├── templates/property_templates/enum_property.py.jinja
    │   ├── templates/property_templates/file_property.py.jinja
    │   ├── templates/property_templates/float_property.py.jinja
    │   ├── templates/property_templates/helpers.jinja
    │   ├── templates/property_templates/int_property.py.jinja
    │   ├── templates/property_templates/list_property.py.jinja
    │   ├── templates/property_templates/model_property.py.jinja
    │   ├── templates/property_templates/property_macros.py.jinja
    │   └── templates/property_templates/union_property.py.jinja
    ├── templates/pyproject.toml.jinja
    ├── templates/pyproject_no_poetry.toml.jinja
    ├── templates/setup.py.jinja
    ├── templates/str_enum.py.jinja
    └── templates/types.py.jinja
```

Contents of LICENSE:
```
MIT License

Copyright (c) 2024 Poll The People

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

Contents of README.md:
```
# CustomGPT Python API SDK

### Welcome to CustomGPT's Official Python SDK!

The CustomGPT Python API SDK offers users access to the number one RAG system's REST API from any Python application.
The library offers both synchronous and asynchronous clients, as well as definitions for all request params and response fields.

## Documentation

The full documentation can be found online at [https://docs.customgpt.ai/reference/i-api-homepage](https://docs.customgpt.ai/reference/i-api-homepage)

## Usage
### First, create a client:

```python
from customgpt_client import CustomGPT

CustomGPT.api_key="SuperSecretToken"
```

Now you can access all of our models.
An example request will look like this:

### Creating a Project Synchronously:

```python
response = CustomGPT.Project.create(project_name='Test', sitemap_path='https://example.com/test.xml', file_data_retension=False, file=file)
project_id = response.data.id
```

### Or do the same thing with an async version:

```python
response = await CustomGPT.Project.acreate(project_name='Test', sitemap_path='https://example.com/test.xml', file_data_retension=False, file=file)
project_id = response.data.id
```

## Tests
Fill your credentials in customgpt_client/tests/credentials.py in base_url and api_key
```python
def credentials():
    return (base_url, api_key)
```

```

Contents of SECURITY.md:
```
# CustomGPT Security Policy
## Reporting Security Issues
At CustomGPT, the security of our systems, products, and services is of utmost importance. We take security seriously and encourage responsible reporting of any security vulnerabilities you may encounter.
## To Report a Security Vulnerability:
Please contact the CustomGPT support team directly at hello@customgpt.ai. We prioritize the confidentiality of your communication and encourage detailed reporting of any findings, which helps us in resolving issues more effectively.
## Responsible Disclosure Policy
We value the efforts of security researchers and enthusiasts who assist in maintaining the security of our technologies. If you have identified a security issue, please observe the following guidelines for responsible disclosure:
- Provide us with a reasonable amount of time to address the vulnerability before any public disclosure.
- Refrain from accessing or modifying user data without explicit permission of the owner.
- Avoid degradation of our services.
## Reporting Non-Product Related Security Vulnerabilities
For security issues that do not pertain directly to CustomGPT products but are related to our corporate services or infrastructure, please use the same contact hello@customgpt.com. This helps streamline our response and ensures all security matters are addressed appropriately.
## CustomGPT Terms and Policies
Information on our detailed security policy can be found at our [CustomGPT Security Policy](https://customgpt.ai/security/) page.
Also feel free to look at our [Trust Center](https://customgpt.trustcenter.sprinto.com/) to learn about our certifications.
For any further questions or concerns regarding our security practices, please reach out to hello@customgpt.com.
Thank you for helping us keep our technologies and services secure.

```

Contents of requirement.txt:
```
openapi-python-client 

```

Contents of customgpt-client/README.md:
```
# CustomGPT SDK

## Usage
First, create a client:

```python
from customgpt_client import CustomGPT

CustomGPT.api_key="SuperSecretToken"
```

Now you can access to all of our Models:
Example Request will be like this:

Creating a Project synchronously:

```python
response = CustomGPT.Project.create(project_name='Test', sitemap_path='https://example.com/test.xml', file_data_retension=False, file=file)
project_id = response.data.id
```

Or do the same thing with an async version:

```python
response = await CustomGPT.Project.acreate(project_name='Test', sitemap_path='https://example.com/test.xml', file_data_retension=False, file=file)
project_id = response.data.id
```

```

Contents of customgpt-client/pyproject.toml:
```
[tool.poetry]
name = "customgpt-client"
version = "1.2.2"
description = "A client library for accessing customgpt"

authors = []

readme = "README.md"
packages = [
    {include = "customgpt_client"},
]
include = ["CHANGELOG.md", "customgpt_client/py.typed"]

[tool.poetry.dependencies]
python = "^3.8"
sseclient-py = "1.7.2"
attrs = ">=21.3.0"
python-dateutil = "^2.8.0"
requests=">=2.31.0"

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"

[tool.black]
line-length = 120
target_version = ['py38', 'py39', 'py310', 'py311']
exclude = '''
(
  /(
    | \.git
    | \.venv
    | \.mypy_cache
  )/
)
'''

[tool.isort]
line_length = 120
profile = "black"

```

Contents of customgpt-client/customgpt_client/__init__.py:
```
""" A client library for accessing customgpt """
from .client import CustomGPT

__all__ = ("CustomGPT",)

```

Contents of customgpt-client/customgpt_client/client.py:
```
# Imports

import ssl
from typing import Any, Dict, Union

import attr

from customgpt_client.api.citations import get_citation
from customgpt_client.api.conversations import (
    create_conversation,
    delete_conversation,
    get_conversations,
    messages_conversation,
    send_message,
    update_conversation,
)
from customgpt_client.api.page_metadata import get_page_metadata, update_page_metadata
from customgpt_client.api.pages import delete_page, get_pages, preview_citation, reindex_page
from customgpt_client.api.project_plugins import create_plugin, get_plugin, update_plugin
from customgpt_client.api.project_settings import get_settings, update_settings
from customgpt_client.api.projects import (
    create_project,
    delete_project,
    get_project,
    list_projects,
    stats_project,
    update_project,
)
from customgpt_client.api.sources import create_source, delete_source, list_sources
from customgpt_client.api.users import get_user, update_user
from customgpt_client.models import (
    CreateConversationJsonBody,
    CreatePluginJsonBody,
    CreateProjectMultipartData,
    CreateSourceMultipartData,
    SendMessageJsonBody,
    UpdateConversationJsonBody,
    UpdatePageMetadataJsonBody,
    UpdatePluginJsonBody,
    UpdateProjectMultipartData,
    UpdateSettingsMultipartData,
    UpdateUserMultipartData,
)

# Initialize the client

def set_client():
    api_key = CustomGPT.api_key if hasattr(CustomGPT, "api_key") else ""
    base_url = CustomGPT.base_url if hasattr(CustomGPT, "base_url") else "https://app.customgpt.ai"
    timeout = CustomGPT.timeout if hasattr(CustomGPT, "timeout") else 100.0
    return CustomGPT(api_key=api_key, base_url=base_url, timeout=timeout)

# Function to retrieve data from kwargs

def pluck_data(fields, kwargs):
    json = {}
    for field in fields:
        if field in kwargs:
            json[field] = kwargs.pop(field)
    return json


@attr.s(auto_attribs=True)
class CustomGPT:
    """A Client which has been authenticated for use on secured endpoints
    Attributes:
        base_url: The base URL for the API, all requests are made to a relative path to this URL
        cookies: A dictionary of cookies to be sent with every request
        headers: A dictionary of headers to be sent with every request
        timeout: The maximum amount of a time in seconds a request can take. API functions will raise
            httpx.TimeoutException if this is exceeded.
        verify_ssl: Whether or not to verify the SSL certificate of the API server. This should be True in production,
            but can be set to False for testing purposes.
        raise_on_unexpected_status: Whether or not to raise an errors.UnexpectedStatus if the API returns a
            status code that was not documented in the source OpenAPI document.
        follow_redirects: Whether or not to follow redirects. Default value is False.
    """

    api_key: str
    prefix: str = "Bearer"
    auth_header_name: str = "Authorization"
    base_url: str = attr.ib("https://app.customgpt.ai")
    cookies: Dict[str, str] = attr.ib(factory=dict, kw_only=True)
    headers: Dict[str, str] = attr.ib(factory=dict, kw_only=True)
    timeout: float = attr.ib(5.0, kw_only=True)
    verify_ssl: Union[str, bool, ssl.SSLContext] = attr.ib(True, kw_only=True)
    raise_on_unexpected_status: bool = attr.ib(False, kw_only=True)
    follow_redirects: bool = attr.ib(False, kw_only=True)

    def with_headers(self, headers: Dict[str, str]) -> "CustomGPT":
        """Get a new client matching this one with additional headers"""
        return attr.evolve(self, headers={**self.headers, **headers})

    def get_cookies(self) -> Dict[str, str]:
        return {**self.cookies}

    def with_cookies(self, cookies: Dict[str, str]) -> "CustomGPT":
        """Get a new client matching this one with additional cookies"""
        return attr.evolve(self, cookies={**self.cookies, **cookies})

    def get_timeout(self) -> float:
        return self.timeout

    def with_timeout(self, timeout: float) -> "CustomGPT":
        """Get a new client matching this one with a new timeout (in seconds)"""
        return attr.evolve(self, timeout=timeout)

    def get_headers(self) -> Dict[str, str]:
        """Get headers to be used in authenticated endpoints"""
        auth_header_value = f"{self.prefix} {self.api_key}" if self.prefix else self.api_key
        return {self.auth_header_name: auth_header_value, **self.headers}

# Class for representing the Project object of the CustomGPT API
# The Project object contains methods for creating, updating, deleting, and listing projects, 
# both synchronously and asynchronously

    class Project:
        def list(*args: Any, **kwargs: Any):
            client = set_client()

            return list_projects.sync_detailed(client=client, *args, **kwargs)

        def alist(*args: Any, **kwargs: Any):
            client = set_client()

            return list_projects.asyncio_detailed(client=client, *args, **kwargs)

        def create(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["project_name", "sitemap_path", "file_data_retension", "file"]
            json = pluck_data(fields, kwargs)
            kwargs["multipart_data"] = CreateProjectMultipartData(**json)

            return create_project.sync_detailed(client=client, *args, **kwargs)

        def acreate(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["project_name", "sitemap_path", "file_data_retension", "file"]
            json = pluck_data(fields, kwargs)
            kwargs["multipart_data"] = CreateProjectMultipartData(**json)

            return create_project.asyncio_detailed(client=client, *args, **kwargs)

        def get(*args: Any, **kwargs: Any):
            client = set_client()

            return get_project.sync_detailed(client=client, *args, **kwargs)

        def aget(*args: Any, **kwargs: Any):
            client = set_client()

            return get_project.asyncio_detailed(client=client, *args, **kwargs)

        def update(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["project_name", "is_shared", "sitemap_path", "file_data_retension", "file"]
            json = pluck_data(fields, kwargs)
            kwargs["multipart_data"] = UpdateProjectMultipartData(**json)

            return update_project.sync_detailed(client=client, *args, **kwargs)

        def aupdate(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["project_name", "is_shared", "sitemap_path", "file_data_retension", "file"]
            json = pluck_data(fields, kwargs)
            kwargs["multipart_data"] = UpdateProjectMultipartData(**json)

            return update_project.asyncio_detailed(client=client, *args, **kwargs)

        def delete(*args: Any, **kwargs: Any):
            client = set_client()

            return delete_project.sync_detailed(client=client, *args, **kwargs)

        def adelete(*args: Any, **kwargs: Any):
            client = set_client()

            return delete_project.asyncio_detailed(client=client, *args, **kwargs)

        def stats(*args: Any, **kwargs: Any):
            client = set_client()

            return stats_project.sync_detailed(client=client, *args, **kwargs)

        def astats(*args: Any, **kwargs: Any):
            client = set_client()

            return stats_project.asyncio_detailed(client=client, *args, **kwargs)

# Class for representing the Page object of the CustomGPT API
# The Page object contains methods for getting, deleting, reindexing, and previewing pages,
# both synchronously and asynchronously

    class Page:
        def get(*args: Any, **kwargs: Any):
            client = set_client()

            return get_pages.sync_detailed(client=client, *args, **kwargs)

        def aget(*args: Any, **kwargs: Any):
            client = set_client()

            return get_pages.asyncio_detailed(client=client, *args, **kwargs)

        def delete(*args: Any, **kwargs: Any):
            client = set_client()

            return delete_page.sync_detailed(client=client, *args, **kwargs)

        def adelete(*args: Any, **kwargs: Any):
            client = set_client()

            return delete_page.asyncio_detailed(client=client, *args, **kwargs)

        def reindex(*args: Any, **kwargs: Any):
            client = set_client()

            return reindex_page.sync_detailed(client=client, *args, **kwargs)

        def areindex(*args: Any, **kwargs: Any):
            client = set_client()

            return reindex_page.asyncio_detailed(client=client, *args, **kwargs)

        def preview(*args: Any, **kwargs: Any):
            client = set_client()

            return preview_citation.sync_detailed(client=client, *args, **kwargs)

        def apreview(*args: Any, **kwargs: Any):
            client = set_client()

            return preview_citation.asyncio_detailed(client=client, *args, **kwargs)

# Class for representing the PageMetadata object of the CustomGPT API
# The PageMetadata object contains methods for getting and updating page metadata,
# both synchronously and asynchronously

    class PageMetadata:
        def get(*args: Any, **kwargs: Any):
            client = set_client()

            return get_page_metadata.sync_detailed(client=client, *args, **kwargs)

        def aget(*args: Any, **kwargs: Any):
            client = set_client()

            return get_page_metadata.asyncio_detailed(client=client, *args, **kwargs)

        def update(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["title", "url", "description", "image"]
            json = pluck_data(fields, kwargs)
            kwargs["json_body"] = UpdatePageMetadataJsonBody(**json)

            return update_page_metadata.sync_detailed(client=client, *args, **kwargs)

        def aupdate(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["title", "url", "description", "image"]
            json = pluck_data(fields, kwargs)
            kwargs["json_body"] = UpdatePageMetadataJsonBody(**json)

            return update_page_metadata.asyncio_detailed(client=client, *args, **kwargs)

# Class for representing the ProjectSettings object of the CustomGPT API
# The ProjectSettings object contains methods for getting and updating project settings,
# both synchronously and asynchronously

    class ProjectSettings:
        def get(*args: Any, **kwargs: Any):
            client = set_client()

            return get_settings.sync_detailed(client=client, *args, **kwargs)

        def aget(*args: Any, **kwargs: Any):
            client = set_client()

            return get_settings.asyncio_detailed(client=client, *args, **kwargs)

        def update(*args: Any, **kwargs: Any):
            client = set_client()
            fields = [
                "chat_bot_avatar",
                "chat_bot_bg",
                "default_prompt",
                "example_questions",
                "response_source",
                "chatbot_msg_lang",
                "chatbot_color",
                "persona_instructions",
                "citations_answer_source_label_msg",
                "citations_sources_label_msg",
                "hang_in_there_msg",
                "chatbot_siesta_msg",
                "is_loading_indicator_enabled",
                "enable_citations",
                "citations_view_type",
                "no_answer_message",
                "ending_message",
                "remove_branding",
            ]
            json = pluck_data(fields, kwargs)
            kwargs["multipart_data"] = UpdateSettingsMultipartData(**json)

            return update_settings.sync_detailed(client=client, *args, **kwargs)

        def aupdate(*args: Any, **kwargs: Any):
            client = set_client()
            fields = [
                "chat_bot_avatar",
                "chat_bot_bg",
                "default_prompt",
                "example_questions",
                "response_source",
                "chatbot_msg_lang",
                "chatbot_color",
                "persona_instructions",
                "citations_answer_source_label_msg",
                "citations_sources_label_msg",
                "hang_in_there_msg",
                "chatbot_siesta_msg",
                "is_loading_indicator_enabled",
                "enable_citations",
                "citations_view_type",
                "no_answer_message",
                "ending_message",
                "remove_branding",
            ]
            json = pluck_data(fields, kwargs)
            kwargs["multipart_data"] = UpdateSettingsMultipartData(**json)

            return update_settings.asyncio_detailed(client=client, *args, **kwargs)

# Class for representing the ProjectPlugins object of the CustomGPT API
# The ProjectPlugins object contains methods for getting, updating, and creating project plugins,
# both synchronously and asynchronously
# Note: The ProjectPlugins object has been deprecated and will be removed soon

    class ProjectPlugins:
        def get(*args: Any, **kwargs: Any):
            client = set_client()

            return get_plugin.sync_detailed(client=client, *args, **kwargs)

        def aget(*args: Any, **kwargs: Any):
            client = set_client()

            return get_plugin.asyncio_detailed(client=client, *args, **kwargs)

        def update(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["model_name", "human_name", "keywords", "description", "is_active"]
            json = pluck_data(fields, kwargs)
            kwargs["json_body"] = UpdatePluginJsonBody(**json)

            return update_plugin.sync_detailed(client=client, *args, **kwargs)

        def aupdate(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["model_name", "human_name", "keywords", "description", "is_active"]
            json = pluck_data(fields, kwargs)
            kwargs["json_body"] = UpdatePluginJsonBody(**json)

            return update_plugin.asyncio_detailed(client=client, *args, **kwargs)

        def create(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["model_name", "human_name", "keywords", "description", "is_active"]
            json = pluck_data(fields, kwargs)
            kwargs["json_body"] = CreatePluginJsonBody(**json)

            return create_plugin.sync_detailed(client=client, *args, **kwargs)

        def acreate(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["model_name", "human_name", "keywords", "description", "is_active"]
            json = pluck_data(fields, kwargs)
            kwargs["json_body"] = CreatePluginJsonBody(**json)

            return create_plugin.asyncio_detailed(client=client, *args, **kwargs)

# Class for representing the Conversation object of the CustomGPT API
# The Conversation object contains methods for creating, updating, deleting, 
# listing, and sending messages to conversations,
# both synchronously and asynchronously

    class Conversation:
        def get(*args: Any, **kwargs: Any):
            client = set_client()

            return get_conversations.sync_detailed(client=client, *args, **kwargs)

        def aget(*args: Any, **kwargs: Any):
            client = set_client()

            return get_conversations.asyncio_detailed(client=client, *args, **kwargs)

        def create(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["name"]
            json = pluck_data(fields, kwargs)
            kwargs["json_body"] = CreateConversationJsonBody(**json)

            return create_conversation.sync_detailed(client=client, *args, **kwargs)

        def acreate(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["name"]
            json = pluck_data(fields, kwargs)
            kwargs["json_body"] = CreateConversationJsonBody(**json)

            return create_conversation.asyncio_detailed(client=client, *args, **kwargs)

        def update(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["name"]
            json = pluck_data(fields, kwargs)
            kwargs["json_body"] = UpdateConversationJsonBody(**json)

            return update_conversation.sync_detailed(client=client, *args, **kwargs)

        def aupdate(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["name"]
            json = pluck_data(fields, kwargs)
            kwargs["json_body"] = UpdateConversationJsonBody(**json)

            return update_conversation.asyncio_detailed(client=client, *args, **kwargs)

        def delete(*args: Any, **kwargs: Any):
            client = set_client()

            return delete_conversation.sync_detailed(client=client, *args, **kwargs)

        def adelete(*args: Any, **kwargs: Any):
            client = set_client()

            return delete_conversation.asyncio_detailed(client=client, *args, **kwargs)

        def messages(*args: Any, **kwargs: Any):
            client = set_client()

            return messages_conversation.sync_detailed(client=client, *args, **kwargs)

        def amessages(*args: Any, **kwargs: Any):
            client = set_client()

            return messages_conversation.asyncio_detailed(client=client, *args, **kwargs)

        def send(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["prompt", "custom_persona"]
            json = pluck_data(fields, kwargs)
            kwargs["json_body"] = SendMessageJsonBody(**json)

            return send_message.sync_detailed(client=client, *args, **kwargs)

        def asend(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["prompt", "custom_persona"]
            json = pluck_data(fields, kwargs)
            kwargs["json_body"] = SendMessageJsonBody(**json)

            return send_message.asyncio_detailed(client=client, *args, **kwargs)

# Class for representing the Citation object of the CustomGPT API
# The Citation object contains methods for getting citations both synchronously and asynchronously

    class Citation:
        def get(*args: Any, **kwargs: Any):
            client = set_client()

            return get_citation.sync_detailed(client=client, *args, **kwargs)

        def aget(*args: Any, **kwargs: Any):
            client = set_client()

            return get_citation.asyncio_detailed(client=client, *args, **kwargs)

# Class for representing the Source object of the CustomGPT API
# The Source object contains methods for creating, deleting, and listing sources,
# both synchronously and asynchronously

    class Source:
        def list(*args: Any, **kwargs: Any):
            client = set_client()

            return list_sources.sync_detailed(client=client, *args, **kwargs)

        def alist(*args: Any, **kwargs: Any):
            client = set_client()

            return list_sources.asyncio_detailed(client=client, *args, **kwargs)

        def create(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["sitemap_path", "file_data_retension", "file"]
            json = pluck_data(fields, kwargs)
            kwargs["multipart_data"] = CreateSourceMultipartData(**json)

            return create_source.sync_detailed(client=client, *args, **kwargs)

        def acreate(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["sitemap_path", "file_data_retension", "file"]
            json = pluck_data(fields, kwargs)
            kwargs["multipart_data"] = CreateSourceMultipartData(**json)

            return create_source.asyncio_detailed(client=client, *args, **kwargs)

        def delete(*args: Any, **kwargs: Any):
            client = set_client()

            return delete_source.sync_detailed(client=client, *args, **kwargs)

        def adelete(*args: Any, **kwargs: Any):
            client = set_client()

            return delete_source.asyncio_detailed(client=client, *args, **kwargs)

# Class for representing the User object of the CustomGPT API
# The User object contains methods for getting and updating user information,
# both synchronously and asynchronously

    class User:
        def get(*args: Any, **kwargs: Any):
            client = set_client()

            return get_user.sync_detailed(client=client, *args, **kwargs)

        def aget(*args: Any, **kwargs: Any):
            client = set_client()

            return get_user.asyncio_detailed(client=client, *args, **kwargs)

        def update(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["profile_photo", "name"]
            json = pluck_data(fields, kwargs)
            kwargs["multipart_data"] = UpdateUserMultipartData(**json)

            return update_user.sync_detailed(client=client, *args, **kwargs)

        def aupdate(*args: Any, **kwargs: Any):
            client = set_client()
            fields = ["profile_photo", "name"]
            json = pluck_data(fields, kwargs)
            kwargs["multipart_data"] = UpdateUserMultipartData(**json)

            return update_user.asyncio_detailed(client=client, *args, **kwargs)

```

Contents of customgpt-client/customgpt_client/errors.py:
```
""" Contains shared errors types that can be raised from API functions """


class UnexpectedStatus(Exception):
    """Raised by api functions when the response status an undocumented status and Client.raise_on_unexpected_status is True"""

    def __init__(self, status_code: int, content: bytes):
        self.status_code = status_code
        self.content = content

        super().__init__(f"Unexpected status code: {status_code}")


__all__ = ["UnexpectedStatus"]

```

Contents of customgpt-client/customgpt_client/py.typed:
```
# Marker file for PEP 561
```

Contents of customgpt-client/customgpt_client/types.py:
```
""" Contains some shared types for properties """
from http import HTTPStatus
from typing import BinaryIO, Generic, Literal, MutableMapping, Optional, Tuple, TypeVar

import attr


class Unset:
    def __bool__(self) -> Literal[False]:
        return False


UNSET: Unset = Unset()

FileJsonType = Tuple[Optional[str], BinaryIO, Optional[str]]


@attr.s(auto_attribs=True)
class File:
    """Contains information for file uploads"""

    payload: BinaryIO
    file_name: Optional[str] = None
    mime_type: Optional[str] = None

    def to_tuple(self) -> FileJsonType:
        """Return a tuple representation that httpx will accept for multipart/form-data"""
        return self.file_name, self.payload, self.mime_type


T = TypeVar("T")


@attr.s(auto_attribs=True)
class Response(Generic[T]):
    """A response from an endpoint"""

    status_code: HTTPStatus
    content: bytes
    headers: MutableMapping[str, str]
    parsed: Optional[T]


__all__ = ["File", "Response", "FileJsonType"]

```

Contents of customgpt-client/customgpt_client/api/__init__.py:
```
""" Contains methods for accessing the API """

```

Contents of customgpt-client/customgpt_client/api/citations/__init__.py:
```

```

Contents of customgpt-client/customgpt_client/api/citations/get_citation.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.get_citation_response_200 import GetCitationResponse200
from ...models.get_citation_response_400 import GetCitationResponse400
from ...models.get_citation_response_401 import GetCitationResponse401
from ...models.get_citation_response_404 import GetCitationResponse404
from ...types import Response


def _get_kwargs(
    project_id: int,
    citation_id: int,
    *,
    client: {},
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/citations/{citationId}".format(
        client.base_url, projectId=project_id, citationId=citation_id
    )

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    return {
        "method": "get",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[Union[GetCitationResponse200, GetCitationResponse400, GetCitationResponse401, GetCitationResponse404]]:
    if response.status_code == HTTPStatus.OK:
        response_200 = GetCitationResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = GetCitationResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = GetCitationResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = GetCitationResponse404.from_dict(json.loads(response.text))

        return response_404
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[Union[GetCitationResponse200, GetCitationResponse400, GetCitationResponse401, GetCitationResponse404]]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    citation_id: int,
    *,
    client: {},
):
    """Get the Open Graph data for a citation.

     Retrieve the Open Graph data for a citation based on its unique identifier. This endpoint allows you
    to fetch the Open Graph metadata associated with a specific citation.
    Here is an example to get citation detail: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Get_citation_details.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Get_Citation_Details.ipynb).

    Args:
        project_id (int):
        citation_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[GetCitationResponse200, GetCitationResponse400, GetCitationResponse401, GetCitationResponse404]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        citation_id=citation_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    citation_id: int,
    *,
    client: {},
) -> Optional[Union[GetCitationResponse200, GetCitationResponse400, GetCitationResponse401, GetCitationResponse404]]:
    """Get the Open Graph data for a citation.

     Retrieve the Open Graph data for a citation based on its unique identifier. This endpoint allows you
    to fetch the Open Graph metadata associated with a specific citation.
    Here is an example to get citation detail: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Get_citation_details.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Get_Citation_Details.ipynb).

    Args:
        project_id (int):
        citation_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetCitationResponse200, GetCitationResponse400, GetCitationResponse401, GetCitationResponse404]
    """

    return sync_detailed(
        project_id=project_id,
        citation_id=citation_id,
        client=client,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    citation_id: int,
    *,
    client: {},
) -> Response[Union[GetCitationResponse200, GetCitationResponse400, GetCitationResponse401, GetCitationResponse404]]:
    kwargs = _get_kwargs(
        project_id=project_id,
        citation_id=citation_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    citation_id: int,
    *,
    client: {},
) -> Optional[Union[GetCitationResponse200, GetCitationResponse400, GetCitationResponse401, GetCitationResponse404]]:
    """Get the Open Graph data for a citation.

     Retrieve the Open Graph data for a citation based on its unique identifier. This endpoint allows you
    to fetch the Open Graph metadata associated with a specific citation.
    Here is an example to get citation detail: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Get_citation_details.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Get_Citation_Details.ipynb).

    Args:
        project_id (int):
        citation_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetCitationResponse200, GetCitationResponse400, GetCitationResponse401, GetCitationResponse404]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            citation_id=citation_id,
            client=client,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/conversations/__init__.py:
```

```

Contents of customgpt-client/customgpt_client/api/conversations/create_conversation.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.create_conversation_json_body import CreateConversationJsonBody
from ...models.create_conversation_response_201 import CreateConversationResponse201
from ...models.create_conversation_response_400 import CreateConversationResponse400
from ...models.create_conversation_response_401 import CreateConversationResponse401
from ...models.create_conversation_response_404 import CreateConversationResponse404
from ...models.create_conversation_response_500 import CreateConversationResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    *,
    client: {},
    json_body: CreateConversationJsonBody,
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/conversations".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    json_json_body = json_body.to_dict()

    return {
        "method": "post",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "json": json_json_body,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        CreateConversationResponse201,
        CreateConversationResponse400,
        CreateConversationResponse401,
        CreateConversationResponse404,
        CreateConversationResponse500,
    ]
]:
    if response.status_code == HTTPStatus.CREATED:
        response_201 = CreateConversationResponse201.from_dict(json.loads(response.text))

        return response_201
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = CreateConversationResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = CreateConversationResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = CreateConversationResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = CreateConversationResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        CreateConversationResponse201,
        CreateConversationResponse400,
        CreateConversationResponse401,
        CreateConversationResponse404,
        CreateConversationResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
    json_body: CreateConversationJsonBody,
):
    """Create a new conversation.

     Create a new conversation for a project identified by its unique projectId. This endpoint allows you
    to initiate a new conversation within a specific project. A conversation serves as a platform for
    users to exchange messages regarding project-related matters. By providing the projectId, you can
    establish a conversation within the context of the project allowing you to seamlessly communicate
    with it.
    Here is an example to create a conversation: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Create_a_new_conversation_and_send_a_message_to_the_conversation.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Create_a_new_conv
    ersation_and_send_a_message_to_the_conversation.ipynb).

    Args:
        project_id (int):
        json_body (CreateConversationJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[CreateConversationResponse201, CreateConversationResponse400, CreateConversationResponse401, CreateConversationResponse404, CreateConversationResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        json_body=json_body,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
    json_body: CreateConversationJsonBody,
) -> Optional[
    Union[
        CreateConversationResponse201,
        CreateConversationResponse400,
        CreateConversationResponse401,
        CreateConversationResponse404,
        CreateConversationResponse500,
    ]
]:
    """Create a new conversation.

     Create a new conversation for a project identified by its unique projectId. This endpoint allows you
    to initiate a new conversation within a specific project. A conversation serves as a platform for
    users to exchange messages regarding project-related matters. By providing the projectId, you can
    establish a conversation within the context of the project allowing you to seamlessly communicate
    with it.
    Here is an example to create a conversation: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Create_a_new_conversation_and_send_a_message_to_the_conversation.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Create_a_new_conv
    ersation_and_send_a_message_to_the_conversation.ipynb).

    Args:
        project_id (int):
        json_body (CreateConversationJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[CreateConversationResponse201, CreateConversationResponse400, CreateConversationResponse401, CreateConversationResponse404, CreateConversationResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
        json_body=json_body,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
    json_body: CreateConversationJsonBody,
) -> Response[
    Union[
        CreateConversationResponse201,
        CreateConversationResponse400,
        CreateConversationResponse401,
        CreateConversationResponse404,
        CreateConversationResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        json_body=json_body,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
    json_body: CreateConversationJsonBody,
) -> Optional[
    Union[
        CreateConversationResponse201,
        CreateConversationResponse400,
        CreateConversationResponse401,
        CreateConversationResponse404,
        CreateConversationResponse500,
    ]
]:
    """Create a new conversation.

     Create a new conversation for a project identified by its unique projectId. This endpoint allows you
    to initiate a new conversation within a specific project. A conversation serves as a platform for
    users to exchange messages regarding project-related matters. By providing the projectId, you can
    establish a conversation within the context of the project allowing you to seamlessly communicate
    with it.
    Here is an example to create a conversation: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Create_a_new_conversation_and_send_a_message_to_the_conversation.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Create_a_new_conv
    ersation_and_send_a_message_to_the_conversation.ipynb).

    Args:
        project_id (int):
        json_body (CreateConversationJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[CreateConversationResponse201, CreateConversationResponse400, CreateConversationResponse401, CreateConversationResponse404, CreateConversationResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
            json_body=json_body,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/conversations/delete_conversation.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.delete_conversation_response_200 import DeleteConversationResponse200
from ...models.delete_conversation_response_400 import DeleteConversationResponse400
from ...models.delete_conversation_response_401 import DeleteConversationResponse401
from ...models.delete_conversation_response_404 import DeleteConversationResponse404
from ...models.delete_conversation_response_500 import DeleteConversationResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    session_id: str,
    *,
    client: {},
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/conversations/{sessionId}".format(
        client.base_url, projectId=project_id, sessionId=session_id
    )

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    return {
        "method": "delete",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        DeleteConversationResponse200,
        DeleteConversationResponse400,
        DeleteConversationResponse401,
        DeleteConversationResponse404,
        DeleteConversationResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = DeleteConversationResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = DeleteConversationResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = DeleteConversationResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = DeleteConversationResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = DeleteConversationResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        DeleteConversationResponse200,
        DeleteConversationResponse400,
        DeleteConversationResponse401,
        DeleteConversationResponse404,
        DeleteConversationResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    session_id: str,
    *,
    client: {},
):
    """Delete a conversation.

     Delete a conversation within a project identified by its unique projectId and sessionId. This
    endpoint allows you to remove a specific conversation from the project, permanently deleting all
    associated messages. By providing the projectId and sessionId, you can target the conversation to be
    deleted, ensuring the removal of all conversation-related data.
    Here is an example to delete a conversation: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Update_Delete_a_conversation.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Update_Delete_a_conversation.ipynb).

    Args:
        project_id (int):
        session_id (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[DeleteConversationResponse200, DeleteConversationResponse400, DeleteConversationResponse401, DeleteConversationResponse404, DeleteConversationResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        session_id=session_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    session_id: str,
    *,
    client: {},
) -> Optional[
    Union[
        DeleteConversationResponse200,
        DeleteConversationResponse400,
        DeleteConversationResponse401,
        DeleteConversationResponse404,
        DeleteConversationResponse500,
    ]
]:
    """Delete a conversation.

     Delete a conversation within a project identified by its unique projectId and sessionId. This
    endpoint allows you to remove a specific conversation from the project, permanently deleting all
    associated messages. By providing the projectId and sessionId, you can target the conversation to be
    deleted, ensuring the removal of all conversation-related data.
    Here is an example to delete a conversation: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Update_Delete_a_conversation.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Update_Delete_a_conversation.ipynb).

    Args:
        project_id (int):
        session_id (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[DeleteConversationResponse200, DeleteConversationResponse400, DeleteConversationResponse401, DeleteConversationResponse404, DeleteConversationResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        session_id=session_id,
        client=client,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    session_id: str,
    *,
    client: {},
) -> Response[
    Union[
        DeleteConversationResponse200,
        DeleteConversationResponse400,
        DeleteConversationResponse401,
        DeleteConversationResponse404,
        DeleteConversationResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        session_id=session_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    session_id: str,
    *,
    client: {},
) -> Optional[
    Union[
        DeleteConversationResponse200,
        DeleteConversationResponse400,
        DeleteConversationResponse401,
        DeleteConversationResponse404,
        DeleteConversationResponse500,
    ]
]:
    """Delete a conversation.

     Delete a conversation within a project identified by its unique projectId and sessionId. This
    endpoint allows you to remove a specific conversation from the project, permanently deleting all
    associated messages. By providing the projectId and sessionId, you can target the conversation to be
    deleted, ensuring the removal of all conversation-related data.
    Here is an example to delete a conversation: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Update_Delete_a_conversation.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Update_Delete_a_conversation.ipynb).

    Args:
        project_id (int):
        session_id (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[DeleteConversationResponse200, DeleteConversationResponse400, DeleteConversationResponse401, DeleteConversationResponse404, DeleteConversationResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            session_id=session_id,
            client=client,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/conversations/get_conversations.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.get_conversations_order import GetConversationsOrder
from ...models.get_conversations_response_200 import GetConversationsResponse200
from ...models.get_conversations_response_400 import GetConversationsResponse400
from ...models.get_conversations_response_401 import GetConversationsResponse401
from ...models.get_conversations_response_404 import GetConversationsResponse404
from ...models.get_conversations_response_500 import GetConversationsResponse500
from ...models.get_conversations_user_filter import GetConversationsUserFilter
from ...types import UNSET, Response, Unset


def _get_kwargs(
    project_id: int,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    order: Union[Unset, None, GetConversationsOrder] = GetConversationsOrder.DESC,
    user_filter: Union[Unset, None, GetConversationsUserFilter] = GetConversationsUserFilter.ALL,
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/conversations".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    params: Dict[str, Any] = {}
    params["page"] = page

    json_order: Union[Unset, None, str] = UNSET
    if not isinstance(order, Unset):
        json_order = order if order else None

    params["order"] = json_order

    json_user_filter: Union[Unset, None, str] = UNSET
    if not isinstance(user_filter, Unset):
        json_user_filter = user_filter if user_filter else None

    params["userFilter"] = json_user_filter

    params = {k: v for k, v in params.items() if v is not UNSET and v is not None}

    return {
        "method": "get",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "params": params,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        GetConversationsResponse200,
        GetConversationsResponse400,
        GetConversationsResponse401,
        GetConversationsResponse404,
        GetConversationsResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = GetConversationsResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = GetConversationsResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = GetConversationsResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = GetConversationsResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = GetConversationsResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        GetConversationsResponse200,
        GetConversationsResponse400,
        GetConversationsResponse401,
        GetConversationsResponse404,
        GetConversationsResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    order: Union[Unset, None, GetConversationsOrder] = GetConversationsOrder.DESC,
    user_filter: Union[Unset, None, GetConversationsUserFilter] = GetConversationsUserFilter.ALL,
):
    """List all conversations for a project.

     Retrieve all conversations associated with a project based on its unique projectId. This endpoint
    allows you to fetch a collection of conversations related to a specific project.

    Args:
        project_id (int):  Example: 1.
        page (Union[Unset, None, int]):  Default: 1.
        order (Union[Unset, None, GetConversationsOrder]):  Default: GetConversationsOrder.DESC.
            Example: desc.
        user_filter (Union[Unset, None, GetConversationsUserFilter]):  Default:
            GetConversationsUserFilter.ALL. Example: all.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[GetConversationsResponse200, GetConversationsResponse400, GetConversationsResponse401, GetConversationsResponse404, GetConversationsResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        page=page,
        order=order,
        user_filter=user_filter,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    order: Union[Unset, None, GetConversationsOrder] = GetConversationsOrder.DESC,
    user_filter: Union[Unset, None, GetConversationsUserFilter] = GetConversationsUserFilter.ALL,
) -> Optional[
    Union[
        GetConversationsResponse200,
        GetConversationsResponse400,
        GetConversationsResponse401,
        GetConversationsResponse404,
        GetConversationsResponse500,
    ]
]:
    """List all conversations for a project.

     Retrieve all conversations associated with a project based on its unique projectId. This endpoint
    allows you to fetch a collection of conversations related to a specific project.

    Args:
        project_id (int):  Example: 1.
        page (Union[Unset, None, int]):  Default: 1.
        order (Union[Unset, None, GetConversationsOrder]):  Default: GetConversationsOrder.DESC.
            Example: desc.
        user_filter (Union[Unset, None, GetConversationsUserFilter]):  Default:
            GetConversationsUserFilter.ALL. Example: all.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetConversationsResponse200, GetConversationsResponse400, GetConversationsResponse401, GetConversationsResponse404, GetConversationsResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
        page=page,
        order=order,
        user_filter=user_filter,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    order: Union[Unset, None, GetConversationsOrder] = GetConversationsOrder.DESC,
    user_filter: Union[Unset, None, GetConversationsUserFilter] = GetConversationsUserFilter.ALL,
) -> Response[
    Union[
        GetConversationsResponse200,
        GetConversationsResponse400,
        GetConversationsResponse401,
        GetConversationsResponse404,
        GetConversationsResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        page=page,
        order=order,
        user_filter=user_filter,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    order: Union[Unset, None, GetConversationsOrder] = GetConversationsOrder.DESC,
    user_filter: Union[Unset, None, GetConversationsUserFilter] = GetConversationsUserFilter.ALL,
) -> Optional[
    Union[
        GetConversationsResponse200,
        GetConversationsResponse400,
        GetConversationsResponse401,
        GetConversationsResponse404,
        GetConversationsResponse500,
    ]
]:
    """List all conversations for a project.

     Retrieve all conversations associated with a project based on its unique projectId. This endpoint
    allows you to fetch a collection of conversations related to a specific project.

    Args:
        project_id (int):  Example: 1.
        page (Union[Unset, None, int]):  Default: 1.
        order (Union[Unset, None, GetConversationsOrder]):  Default: GetConversationsOrder.DESC.
            Example: desc.
        user_filter (Union[Unset, None, GetConversationsUserFilter]):  Default:
            GetConversationsUserFilter.ALL. Example: all.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetConversationsResponse200, GetConversationsResponse400, GetConversationsResponse401, GetConversationsResponse404, GetConversationsResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
            page=page,
            order=order,
            user_filter=user_filter,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/conversations/messages_conversation.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.messages_conversation_order import MessagesConversationOrder
from ...models.messages_conversation_response_200 import MessagesConversationResponse200
from ...models.messages_conversation_response_400 import MessagesConversationResponse400
from ...models.messages_conversation_response_401 import MessagesConversationResponse401
from ...models.messages_conversation_response_404 import MessagesConversationResponse404
from ...models.messages_conversation_response_500 import MessagesConversationResponse500
from ...types import UNSET, Response, Unset


def _get_kwargs(
    project_id: int,
    session_id: str,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    order: Union[Unset, None, MessagesConversationOrder] = MessagesConversationOrder.DESC,
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/conversations/{sessionId}/messages".format(
        client.base_url, projectId=project_id, sessionId=session_id
    )

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    params: Dict[str, Any] = {}
    params["page"] = page

    json_order: Union[Unset, None, str] = UNSET
    if not isinstance(order, Unset):
        json_order = order if order else None

    params["order"] = json_order

    params = {k: v for k, v in params.items() if v is not UNSET and v is not None}

    return {
        "method": "get",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "params": params,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        MessagesConversationResponse200,
        MessagesConversationResponse400,
        MessagesConversationResponse401,
        MessagesConversationResponse404,
        MessagesConversationResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = MessagesConversationResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = MessagesConversationResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = MessagesConversationResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = MessagesConversationResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = MessagesConversationResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        MessagesConversationResponse200,
        MessagesConversationResponse400,
        MessagesConversationResponse401,
        MessagesConversationResponse404,
        MessagesConversationResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    session_id: str,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    order: Union[Unset, None, MessagesConversationOrder] = MessagesConversationOrder.DESC,
):
    """Retrieve messages that have been sent in a conversation.

     Retrieve all messages sent within a conversation of a project identified by its unique projectId and
    sessionId. This endpoint allows you to retrieve a collection of messages exchanged in a specific
    conversation. Messages contain the content, timestamps, and other relevant information shared during
    the course of the conversation. By providing the projectId and sessionId, you can access all the
    messages associated with that particular conversation within the project context.
    Here is an example to retrieve messages of a conversation: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/Retrieve_messages_for_a_conversation.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Retrieve_Messages_of_conversation.ipynb).

    Args:
        project_id (int):  Example: 1.
        session_id (str):  Example: 1.
        page (Union[Unset, None, int]):  Default: 1.
        order (Union[Unset, None, MessagesConversationOrder]):  Default:
            MessagesConversationOrder.DESC. Example: desc.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[MessagesConversationResponse200, MessagesConversationResponse400, MessagesConversationResponse401, MessagesConversationResponse404, MessagesConversationResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        session_id=session_id,
        client=client,
        page=page,
        order=order,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    session_id: str,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    order: Union[Unset, None, MessagesConversationOrder] = MessagesConversationOrder.DESC,
) -> Optional[
    Union[
        MessagesConversationResponse200,
        MessagesConversationResponse400,
        MessagesConversationResponse401,
        MessagesConversationResponse404,
        MessagesConversationResponse500,
    ]
]:
    """Retrieve messages that have been sent in a conversation.

     Retrieve all messages sent within a conversation of a project identified by its unique projectId and
    sessionId. This endpoint allows you to retrieve a collection of messages exchanged in a specific
    conversation. Messages contain the content, timestamps, and other relevant information shared during
    the course of the conversation. By providing the projectId and sessionId, you can access all the
    messages associated with that particular conversation within the project context.
    Here is an example to retrieve messages of a conversation: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/Retrieve_messages_for_a_conversation.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Retrieve_Messages_of_conversation.ipynb).

    Args:
        project_id (int):  Example: 1.
        session_id (str):  Example: 1.
        page (Union[Unset, None, int]):  Default: 1.
        order (Union[Unset, None, MessagesConversationOrder]):  Default:
            MessagesConversationOrder.DESC. Example: desc.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[MessagesConversationResponse200, MessagesConversationResponse400, MessagesConversationResponse401, MessagesConversationResponse404, MessagesConversationResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        session_id=session_id,
        client=client,
        page=page,
        order=order,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    session_id: str,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    order: Union[Unset, None, MessagesConversationOrder] = MessagesConversationOrder.DESC,
) -> Response[
    Union[
        MessagesConversationResponse200,
        MessagesConversationResponse400,
        MessagesConversationResponse401,
        MessagesConversationResponse404,
        MessagesConversationResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        session_id=session_id,
        client=client,
        page=page,
        order=order,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    session_id: str,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    order: Union[Unset, None, MessagesConversationOrder] = MessagesConversationOrder.DESC,
) -> Optional[
    Union[
        MessagesConversationResponse200,
        MessagesConversationResponse400,
        MessagesConversationResponse401,
        MessagesConversationResponse404,
        MessagesConversationResponse500,
    ]
]:
    """Retrieve messages that have been sent in a conversation.

     Retrieve all messages sent within a conversation of a project identified by its unique projectId and
    sessionId. This endpoint allows you to retrieve a collection of messages exchanged in a specific
    conversation. Messages contain the content, timestamps, and other relevant information shared during
    the course of the conversation. By providing the projectId and sessionId, you can access all the
    messages associated with that particular conversation within the project context.
    Here is an example to retrieve messages of a conversation: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/Retrieve_messages_for_a_conversation.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Retrieve_Messages_of_conversation.ipynb).

    Args:
        project_id (int):  Example: 1.
        session_id (str):  Example: 1.
        page (Union[Unset, None, int]):  Default: 1.
        order (Union[Unset, None, MessagesConversationOrder]):  Default:
            MessagesConversationOrder.DESC. Example: desc.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[MessagesConversationResponse200, MessagesConversationResponse400, MessagesConversationResponse401, MessagesConversationResponse404, MessagesConversationResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            session_id=session_id,
            client=client,
            page=page,
            order=order,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/conversations/send_message.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests
from sseclient import SSEClient

from ... import errors
from ...models.send_message_json_body import SendMessageJsonBody
from ...models.send_message_response_200 import SendMessageResponse200
from ...models.send_message_response_400 import SendMessageResponse400
from ...models.send_message_response_401 import SendMessageResponse401
from ...models.send_message_response_404 import SendMessageResponse404
from ...models.send_message_response_500 import SendMessageResponse500
from ...types import UNSET, Response, Unset


def _get_kwargs(
    project_id: int,
    session_id: str,
    *,
    client: {},
    json_body: SendMessageJsonBody,
    stream: Union[Unset, None, bool] = False,
    lang: Union[Unset, None, str] = "en",
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/conversations/{sessionId}/messages".format(
        client.base_url, projectId=project_id, sessionId=session_id
    )

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    params: Dict[str, Any] = {}
    params["stream"] = 1 if stream else 0

    params["lang"] = lang

    params = {k: v for k, v in params.items() if v is not UNSET and v is not None}

    json_json_body = json_body.to_dict()

    if stream:
        headers["Accept"] = "text/event-stream"

    return {
        "method": "post",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "json": json_json_body,
        "params": params,
        "stream": stream,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        SendMessageResponse200,
        SendMessageResponse400,
        SendMessageResponse401,
        SendMessageResponse404,
        SendMessageResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = SendMessageResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = SendMessageResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = SendMessageResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = SendMessageResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = SendMessageResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        SendMessageResponse200,
        SendMessageResponse400,
        SendMessageResponse401,
        SendMessageResponse404,
        SendMessageResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    session_id: str,
    *,
    client: {},
    json_body: SendMessageJsonBody,
    stream: Union[Unset, None, bool] = False,
    lang: Union[Unset, None, str] = "en",
):
    """Send a message to a conversation.

     Send a message to a conversation within a project identified by its unique projectId and sessionId.
    This endpoint enables you to send a new message to a specific conversation, facilitating seamless
    communication and collaboration within the project. By providing the projectId and sessionId, you
    can target the desired conversation and contribute to the ongoing discussion. This API endpoint
    supports real-time streaming, allowing for instant message delivery and dynamic updates which
    enables efficient and interactive communication between the user and chatbot.
    Here is an example to send a message to a conversation: [API](https://github.com/Poll-The-
    People/customgpt-
    cookbook/blob/main/examples/Create_a_new_conversation_and_send_a_message_to_the_conversation.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Create_a_new_conv
    ersation_and_send_a_message_to_the_conversation.ipynb).

    Args:
        project_id (int):  Example: 1.
        session_id (str):  Example: 1.
        stream (Union[Unset, None, bool]):
        lang (Union[Unset, None, str]):  Default: 'en'.
        json_body (SendMessageJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[SendMessageResponse200, SendMessageResponse400, SendMessageResponse401, SendMessageResponse404, SendMessageResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        session_id=session_id,
        client=client,
        json_body=json_body,
        stream=stream,
        lang=lang,
    )

    response = requests.request(
        **kwargs,
    )

    if stream:
        return SSEClient(response)
    else:
        return _build_response(client=client, response=response)


def sync(
    project_id: int,
    session_id: str,
    *,
    client: {},
    json_body: SendMessageJsonBody,
    stream: Union[Unset, None, bool] = False,
    lang: Union[Unset, None, str] = "en",
) -> Optional[
    Union[
        SendMessageResponse200,
        SendMessageResponse400,
        SendMessageResponse401,
        SendMessageResponse404,
        SendMessageResponse500,
    ]
]:
    """Send a message to a conversation.

     Send a message to a conversation within a project identified by its unique projectId and sessionId.
    This endpoint enables you to send a new message to a specific conversation, facilitating seamless
    communication and collaboration within the project. By providing the projectId and sessionId, you
    can target the desired conversation and contribute to the ongoing discussion. This API endpoint
    supports real-time streaming, allowing for instant message delivery and dynamic updates which
    enables efficient and interactive communication between the user and chatbot.
    Here is an example to send a message to a conversation: [API](https://github.com/Poll-The-
    People/customgpt-
    cookbook/blob/main/examples/Create_a_new_conversation_and_send_a_message_to_the_conversation.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Create_a_new_conv
    ersation_and_send_a_message_to_the_conversation.ipynb).

    Args:
        project_id (int):  Example: 1.
        session_id (str):  Example: 1.
        stream (Union[Unset, None, bool]):
        lang (Union[Unset, None, str]):  Default: 'en'.
        json_body (SendMessageJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[SendMessageResponse200, SendMessageResponse400, SendMessageResponse401, SendMessageResponse404, SendMessageResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        session_id=session_id,
        client=client,
        json_body=json_body,
        stream=stream,
        lang=lang,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    session_id: str,
    *,
    client: {},
    json_body: SendMessageJsonBody,
    stream: Union[Unset, None, bool] = False,
    lang: Union[Unset, None, str] = "en",
) -> Response[
    Union[
        SendMessageResponse200,
        SendMessageResponse400,
        SendMessageResponse401,
        SendMessageResponse404,
        SendMessageResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        session_id=session_id,
        client=client,
        json_body=json_body,
        stream=stream,
        lang=lang,
    )

    response = requests.request(
        **kwargs,
    )

    if stream:
        return SSEClient(response)
    else:
        return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    session_id: str,
    *,
    client: {},
    json_body: SendMessageJsonBody,
    stream: Union[Unset, None, bool] = False,
    lang: Union[Unset, None, str] = "en",
) -> Optional[
    Union[
        SendMessageResponse200,
        SendMessageResponse400,
        SendMessageResponse401,
        SendMessageResponse404,
        SendMessageResponse500,
    ]
]:
    """Send a message to a conversation.

     Send a message to a conversation within a project identified by its unique projectId and sessionId.
    This endpoint enables you to send a new message to a specific conversation, facilitating seamless
    communication and collaboration within the project. By providing the projectId and sessionId, you
    can target the desired conversation and contribute to the ongoing discussion. This API endpoint
    supports real-time streaming, allowing for instant message delivery and dynamic updates which
    enables efficient and interactive communication between the user and chatbot.
    Here is an example to send a message to a conversation: [API](https://github.com/Poll-The-
    People/customgpt-
    cookbook/blob/main/examples/Create_a_new_conversation_and_send_a_message_to_the_conversation.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Create_a_new_conv
    ersation_and_send_a_message_to_the_conversation.ipynb).

    Args:
        project_id (int):  Example: 1.
        session_id (str):  Example: 1.
        stream (Union[Unset, None, bool]):
        lang (Union[Unset, None, str]):  Default: 'en'.
        json_body (SendMessageJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[SendMessageResponse200, SendMessageResponse400, SendMessageResponse401, SendMessageResponse404, SendMessageResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            session_id=session_id,
            client=client,
            json_body=json_body,
            stream=stream,
            lang=lang,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/conversations/update_conversation.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.update_conversation_json_body import UpdateConversationJsonBody
from ...models.update_conversation_response_200 import UpdateConversationResponse200
from ...models.update_conversation_response_400 import UpdateConversationResponse400
from ...models.update_conversation_response_401 import UpdateConversationResponse401
from ...models.update_conversation_response_404 import UpdateConversationResponse404
from ...models.update_conversation_response_500 import UpdateConversationResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    session_id: str,
    *,
    client: {},
    json_body: UpdateConversationJsonBody,
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/conversations/{sessionId}".format(
        client.base_url, projectId=project_id, sessionId=session_id
    )

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    json_json_body = json_body.to_dict()

    return {
        "method": "put",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "json": json_json_body,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        UpdateConversationResponse200,
        UpdateConversationResponse400,
        UpdateConversationResponse401,
        UpdateConversationResponse404,
        UpdateConversationResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = UpdateConversationResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = UpdateConversationResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = UpdateConversationResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = UpdateConversationResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = UpdateConversationResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        UpdateConversationResponse200,
        UpdateConversationResponse400,
        UpdateConversationResponse401,
        UpdateConversationResponse404,
        UpdateConversationResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    session_id: str,
    *,
    client: {},
    json_body: UpdateConversationJsonBody,
):
    """Update a conversation.

     Update a conversation within a project identified by its unique projectId and sessionId. This
    endpoint allows you to modify and update the properties of a specific conversation. By providing the
    projectId and sessionId, you can target the desired conversation and make changes to its attributes.
    Here is an example to update a conversation: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Update_Delete_a_conversation.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Update_Delete_a_conversation.ipynb).

    Args:
        project_id (int):
        session_id (str):
        json_body (UpdateConversationJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[UpdateConversationResponse200, UpdateConversationResponse400, UpdateConversationResponse401, UpdateConversationResponse404, UpdateConversationResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        session_id=session_id,
        client=client,
        json_body=json_body,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    session_id: str,
    *,
    client: {},
    json_body: UpdateConversationJsonBody,
) -> Optional[
    Union[
        UpdateConversationResponse200,
        UpdateConversationResponse400,
        UpdateConversationResponse401,
        UpdateConversationResponse404,
        UpdateConversationResponse500,
    ]
]:
    """Update a conversation.

     Update a conversation within a project identified by its unique projectId and sessionId. This
    endpoint allows you to modify and update the properties of a specific conversation. By providing the
    projectId and sessionId, you can target the desired conversation and make changes to its attributes.
    Here is an example to update a conversation: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Update_Delete_a_conversation.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Update_Delete_a_conversation.ipynb).

    Args:
        project_id (int):
        session_id (str):
        json_body (UpdateConversationJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[UpdateConversationResponse200, UpdateConversationResponse400, UpdateConversationResponse401, UpdateConversationResponse404, UpdateConversationResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        session_id=session_id,
        client=client,
        json_body=json_body,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    session_id: str,
    *,
    client: {},
    json_body: UpdateConversationJsonBody,
) -> Response[
    Union[
        UpdateConversationResponse200,
        UpdateConversationResponse400,
        UpdateConversationResponse401,
        UpdateConversationResponse404,
        UpdateConversationResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        session_id=session_id,
        client=client,
        json_body=json_body,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    session_id: str,
    *,
    client: {},
    json_body: UpdateConversationJsonBody,
) -> Optional[
    Union[
        UpdateConversationResponse200,
        UpdateConversationResponse400,
        UpdateConversationResponse401,
        UpdateConversationResponse404,
        UpdateConversationResponse500,
    ]
]:
    """Update a conversation.

     Update a conversation within a project identified by its unique projectId and sessionId. This
    endpoint allows you to modify and update the properties of a specific conversation. By providing the
    projectId and sessionId, you can target the desired conversation and make changes to its attributes.
    Here is an example to update a conversation: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Update_Delete_a_conversation.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Update_Delete_a_conversation.ipynb).

    Args:
        project_id (int):
        session_id (str):
        json_body (UpdateConversationJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[UpdateConversationResponse200, UpdateConversationResponse400, UpdateConversationResponse401, UpdateConversationResponse404, UpdateConversationResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            session_id=session_id,
            client=client,
            json_body=json_body,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/page_metadata/__init__.py:
```

```

Contents of customgpt-client/customgpt_client/api/page_metadata/get_page_metadata.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.get_page_metadata_response_200 import GetPageMetadataResponse200
from ...models.get_page_metadata_response_400 import GetPageMetadataResponse400
from ...models.get_page_metadata_response_401 import GetPageMetadataResponse401
from ...models.get_page_metadata_response_404 import GetPageMetadataResponse404
from ...types import Response


def _get_kwargs(
    project_id: int,
    page_id: str,
    *,
    client: {},
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/pages/{pageId}/metadata".format(
        client.base_url, projectId=project_id, pageId=page_id
    )

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    return {
        "method": "get",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        GetPageMetadataResponse200, GetPageMetadataResponse400, GetPageMetadataResponse401, GetPageMetadataResponse404
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = GetPageMetadataResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = GetPageMetadataResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = GetPageMetadataResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = GetPageMetadataResponse404.from_dict(json.loads(response.text))

        return response_404
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        GetPageMetadataResponse200, GetPageMetadataResponse400, GetPageMetadataResponse401, GetPageMetadataResponse404
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    page_id: str,
    *,
    client: {},
):
    """Get the Metadata for a certain page.

     Retrieve the Metadata for a page based on its unique identifier. This endpoint allows you to fetch
    the metadata associated with a specific page.

    Args:
        project_id (int):
        page_id (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[GetPageMetadataResponse200, GetPageMetadataResponse400, GetPageMetadataResponse401, GetPageMetadataResponse404]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        page_id=page_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    page_id: str,
    *,
    client: {},
) -> Optional[
    Union[
        GetPageMetadataResponse200, GetPageMetadataResponse400, GetPageMetadataResponse401, GetPageMetadataResponse404
    ]
]:
    """Get the Metadata for a certain page.

     Retrieve the Metadata for a page based on its unique identifier. This endpoint allows you to fetch
    the metadata associated with a specific page.

    Args:
        project_id (int):
        page_id (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetPageMetadataResponse200, GetPageMetadataResponse400, GetPageMetadataResponse401, GetPageMetadataResponse404]
    """

    return sync_detailed(
        project_id=project_id,
        page_id=page_id,
        client=client,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    page_id: str,
    *,
    client: {},
) -> Response[
    Union[
        GetPageMetadataResponse200, GetPageMetadataResponse400, GetPageMetadataResponse401, GetPageMetadataResponse404
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        page_id=page_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    page_id: str,
    *,
    client: {},
) -> Optional[
    Union[
        GetPageMetadataResponse200, GetPageMetadataResponse400, GetPageMetadataResponse401, GetPageMetadataResponse404
    ]
]:
    """Get the Metadata for a certain page.

     Retrieve the Metadata for a page based on its unique identifier. This endpoint allows you to fetch
    the metadata associated with a specific page.

    Args:
        project_id (int):
        page_id (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetPageMetadataResponse200, GetPageMetadataResponse400, GetPageMetadataResponse401, GetPageMetadataResponse404]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            page_id=page_id,
            client=client,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/page_metadata/update_page_metadata.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.update_page_metadata_json_body import UpdatePageMetadataJsonBody
from ...models.update_page_metadata_response_200 import UpdatePageMetadataResponse200
from ...models.update_page_metadata_response_400 import UpdatePageMetadataResponse400
from ...models.update_page_metadata_response_401 import UpdatePageMetadataResponse401
from ...models.update_page_metadata_response_404 import UpdatePageMetadataResponse404
from ...models.update_page_metadata_response_500 import UpdatePageMetadataResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    page_id: int,
    *,
    client: {},
    json_body: UpdatePageMetadataJsonBody,
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/pages/{pageId}/metadata".format(
        client.base_url, projectId=project_id, pageId=page_id
    )

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    json_json_body = json_body.to_dict()

    return {
        "method": "put",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "json": json_json_body,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        UpdatePageMetadataResponse200,
        UpdatePageMetadataResponse400,
        UpdatePageMetadataResponse401,
        UpdatePageMetadataResponse404,
        UpdatePageMetadataResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = UpdatePageMetadataResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = UpdatePageMetadataResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = UpdatePageMetadataResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = UpdatePageMetadataResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = UpdatePageMetadataResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        UpdatePageMetadataResponse200,
        UpdatePageMetadataResponse400,
        UpdatePageMetadataResponse401,
        UpdatePageMetadataResponse404,
        UpdatePageMetadataResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    page_id: int,
    *,
    client: {},
    json_body: UpdatePageMetadataJsonBody,
):
    """Update metadata for a certain page.

     Update the metadata for a specific page identified by its unique pageId. This endpoint allows you to
    update the associated metadata of the page.

    Args:
        project_id (int):
        page_id (int):
        json_body (UpdatePageMetadataJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[UpdatePageMetadataResponse200, UpdatePageMetadataResponse400, UpdatePageMetadataResponse401, UpdatePageMetadataResponse404, UpdatePageMetadataResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        page_id=page_id,
        client=client,
        json_body=json_body,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    page_id: int,
    *,
    client: {},
    json_body: UpdatePageMetadataJsonBody,
) -> Optional[
    Union[
        UpdatePageMetadataResponse200,
        UpdatePageMetadataResponse400,
        UpdatePageMetadataResponse401,
        UpdatePageMetadataResponse404,
        UpdatePageMetadataResponse500,
    ]
]:
    """Update metadata for a certain page.

     Update the metadata for a specific page identified by its unique pageId. This endpoint allows you to
    update the associated metadata of the page.

    Args:
        project_id (int):
        page_id (int):
        json_body (UpdatePageMetadataJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[UpdatePageMetadataResponse200, UpdatePageMetadataResponse400, UpdatePageMetadataResponse401, UpdatePageMetadataResponse404, UpdatePageMetadataResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        page_id=page_id,
        client=client,
        json_body=json_body,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    page_id: int,
    *,
    client: {},
    json_body: UpdatePageMetadataJsonBody,
) -> Response[
    Union[
        UpdatePageMetadataResponse200,
        UpdatePageMetadataResponse400,
        UpdatePageMetadataResponse401,
        UpdatePageMetadataResponse404,
        UpdatePageMetadataResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        page_id=page_id,
        client=client,
        json_body=json_body,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    page_id: int,
    *,
    client: {},
    json_body: UpdatePageMetadataJsonBody,
) -> Optional[
    Union[
        UpdatePageMetadataResponse200,
        UpdatePageMetadataResponse400,
        UpdatePageMetadataResponse401,
        UpdatePageMetadataResponse404,
        UpdatePageMetadataResponse500,
    ]
]:
    """Update metadata for a certain page.

     Update the metadata for a specific page identified by its unique pageId. This endpoint allows you to
    update the associated metadata of the page.

    Args:
        project_id (int):
        page_id (int):
        json_body (UpdatePageMetadataJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[UpdatePageMetadataResponse200, UpdatePageMetadataResponse400, UpdatePageMetadataResponse401, UpdatePageMetadataResponse404, UpdatePageMetadataResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            page_id=page_id,
            client=client,
            json_body=json_body,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/pages/__init__.py:
```

```

Contents of customgpt-client/customgpt_client/api/pages/delete_page.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.delete_page_response_200 import DeletePageResponse200
from ...models.delete_page_response_400 import DeletePageResponse400
from ...models.delete_page_response_401 import DeletePageResponse401
from ...models.delete_page_response_404 import DeletePageResponse404
from ...models.delete_page_response_500 import DeletePageResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    page_id: int,
    *,
    client: {},
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/pages/{pageId}".format(client.base_url, projectId=project_id, pageId=page_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    return {
        "method": "delete",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        DeletePageResponse200,
        DeletePageResponse400,
        DeletePageResponse401,
        DeletePageResponse404,
        DeletePageResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = DeletePageResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = DeletePageResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = DeletePageResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = DeletePageResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = DeletePageResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        DeletePageResponse200,
        DeletePageResponse400,
        DeletePageResponse401,
        DeletePageResponse404,
        DeletePageResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    page_id: int,
    *,
    client: {},
):
    """Delete a certain page that belongs to a certain project.

     Delete a specific page within a project based on its unique projectId and pageId. This endpoint
    allows you to remove a particular page from the project, permanently deleting its associated
    context.
    Here is an example to delete a certain page: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Delete_a_page_from_the_project.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Delete_a_project_page.ipynb).

    Args:
        project_id (int):
        page_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[DeletePageResponse200, DeletePageResponse400, DeletePageResponse401, DeletePageResponse404, DeletePageResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        page_id=page_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    page_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        DeletePageResponse200,
        DeletePageResponse400,
        DeletePageResponse401,
        DeletePageResponse404,
        DeletePageResponse500,
    ]
]:
    """Delete a certain page that belongs to a certain project.

     Delete a specific page within a project based on its unique projectId and pageId. This endpoint
    allows you to remove a particular page from the project, permanently deleting its associated
    context.
    Here is an example to delete a certain page: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Delete_a_page_from_the_project.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Delete_a_project_page.ipynb).

    Args:
        project_id (int):
        page_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[DeletePageResponse200, DeletePageResponse400, DeletePageResponse401, DeletePageResponse404, DeletePageResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        page_id=page_id,
        client=client,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    page_id: int,
    *,
    client: {},
) -> Response[
    Union[
        DeletePageResponse200,
        DeletePageResponse400,
        DeletePageResponse401,
        DeletePageResponse404,
        DeletePageResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        page_id=page_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    page_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        DeletePageResponse200,
        DeletePageResponse400,
        DeletePageResponse401,
        DeletePageResponse404,
        DeletePageResponse500,
    ]
]:
    """Delete a certain page that belongs to a certain project.

     Delete a specific page within a project based on its unique projectId and pageId. This endpoint
    allows you to remove a particular page from the project, permanently deleting its associated
    context.
    Here is an example to delete a certain page: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Delete_a_page_from_the_project.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Delete_a_project_page.ipynb).

    Args:
        project_id (int):
        page_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[DeletePageResponse200, DeletePageResponse400, DeletePageResponse401, DeletePageResponse404, DeletePageResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            page_id=page_id,
            client=client,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/pages/get_pages.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.get_pages_order import GetPagesOrder
from ...models.get_pages_response_200 import GetPagesResponse200
from ...models.get_pages_response_400 import GetPagesResponse400
from ...models.get_pages_response_401 import GetPagesResponse401
from ...models.get_pages_response_404 import GetPagesResponse404
from ...models.get_pages_response_500 import GetPagesResponse500
from ...types import UNSET, Response, Unset


def _get_kwargs(
    project_id: int,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    duration: Union[Unset, None, int] = 90,
    order: Union[Unset, None, GetPagesOrder] = GetPagesOrder.DESC,
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/pages".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    params: Dict[str, Any] = {}
    params["page"] = page

    params["duration"] = duration

    json_order: Union[Unset, None, str] = UNSET
    if not isinstance(order, Unset):
        json_order = order if order else None

    params["order"] = json_order

    params = {k: v for k, v in params.items() if v is not UNSET and v is not None}

    return {
        "method": "get",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "params": params,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[GetPagesResponse200, GetPagesResponse400, GetPagesResponse401, GetPagesResponse404, GetPagesResponse500]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = GetPagesResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = GetPagesResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = GetPagesResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = GetPagesResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = GetPagesResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[GetPagesResponse200, GetPagesResponse400, GetPagesResponse401, GetPagesResponse404, GetPagesResponse500]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    duration: Union[Unset, None, int] = 90,
    order: Union[Unset, None, GetPagesOrder] = GetPagesOrder.DESC,
):
    """List all pages that belong to a project.

     Retrieve a list of all pages associated with a project. This endpoint allows you to fetch project
    details and a collection of pages that belong to a specific project. Each page object includes
    information such as the page ID, URL, hash of the URL, project ID, crawl status, index status, file
    details (if applicable), creation and update timestamps, and other relevant attributes.
    Here is an example to list all pages belonging to project: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/List_all_pages_of_a_project.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_List_all_pages_belonging_to_a_project.ipynb).

    Args:
        project_id (int):  Example: 1.
        page (Union[Unset, None, int]):  Default: 1.
        duration (Union[Unset, None, int]):  Default: 90.
        order (Union[Unset, None, GetPagesOrder]):  Default: GetPagesOrder.DESC.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[GetPagesResponse200, GetPagesResponse400, GetPagesResponse401, GetPagesResponse404, GetPagesResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        page=page,
        duration=duration,
        order=order,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    duration: Union[Unset, None, int] = 90,
    order: Union[Unset, None, GetPagesOrder] = GetPagesOrder.DESC,
) -> Optional[
    Union[GetPagesResponse200, GetPagesResponse400, GetPagesResponse401, GetPagesResponse404, GetPagesResponse500]
]:
    """List all pages that belong to a project.

     Retrieve a list of all pages associated with a project. This endpoint allows you to fetch project
    details and a collection of pages that belong to a specific project. Each page object includes
    information such as the page ID, URL, hash of the URL, project ID, crawl status, index status, file
    details (if applicable), creation and update timestamps, and other relevant attributes.
    Here is an example to list all pages belonging to project: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/List_all_pages_of_a_project.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_List_all_pages_belonging_to_a_project.ipynb).

    Args:
        project_id (int):  Example: 1.
        page (Union[Unset, None, int]):  Default: 1.
        duration (Union[Unset, None, int]):  Default: 90.
        order (Union[Unset, None, GetPagesOrder]):  Default: GetPagesOrder.DESC.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetPagesResponse200, GetPagesResponse400, GetPagesResponse401, GetPagesResponse404, GetPagesResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
        page=page,
        duration=duration,
        order=order,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    duration: Union[Unset, None, int] = 90,
    order: Union[Unset, None, GetPagesOrder] = GetPagesOrder.DESC,
) -> Response[
    Union[GetPagesResponse200, GetPagesResponse400, GetPagesResponse401, GetPagesResponse404, GetPagesResponse500]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        page=page,
        duration=duration,
        order=order,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    duration: Union[Unset, None, int] = 90,
    order: Union[Unset, None, GetPagesOrder] = GetPagesOrder.DESC,
) -> Optional[
    Union[GetPagesResponse200, GetPagesResponse400, GetPagesResponse401, GetPagesResponse404, GetPagesResponse500]
]:
    """List all pages that belong to a project.

     Retrieve a list of all pages associated with a project. This endpoint allows you to fetch project
    details and a collection of pages that belong to a specific project. Each page object includes
    information such as the page ID, URL, hash of the URL, project ID, crawl status, index status, file
    details (if applicable), creation and update timestamps, and other relevant attributes.
    Here is an example to list all pages belonging to project: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/List_all_pages_of_a_project.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_List_all_pages_belonging_to_a_project.ipynb).

    Args:
        project_id (int):  Example: 1.
        page (Union[Unset, None, int]):  Default: 1.
        duration (Union[Unset, None, int]):  Default: 90.
        order (Union[Unset, None, GetPagesOrder]):  Default: GetPagesOrder.DESC.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetPagesResponse200, GetPagesResponse400, GetPagesResponse401, GetPagesResponse404, GetPagesResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
            page=page,
            duration=duration,
            order=order,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/pages/preview_citation.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.preview_citation_response_400 import PreviewCitationResponse400
from ...models.preview_citation_response_401 import PreviewCitationResponse401
from ...models.preview_citation_response_404 import PreviewCitationResponse404
from ...models.preview_citation_response_500 import PreviewCitationResponse500
from ...types import Response


def _get_kwargs(
    id: str,
    *,
    client: {},
) -> Dict[str, Any]:
    url = "{}/api/v1/preview/{id}".format(client.base_url, id=id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    return {
        "method": "get",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        PreviewCitationResponse400, PreviewCitationResponse401, PreviewCitationResponse404, PreviewCitationResponse500
    ]
]:
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = PreviewCitationResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = PreviewCitationResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = PreviewCitationResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = PreviewCitationResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        PreviewCitationResponse400, PreviewCitationResponse401, PreviewCitationResponse404, PreviewCitationResponse500
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    id: str,
    *,
    client: {},
):
    """Preview file from citation.

    Args:
        id (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[PreviewCitationResponse400, PreviewCitationResponse401, PreviewCitationResponse404, PreviewCitationResponse500]]
    """

    kwargs = _get_kwargs(
        id=id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    id: str,
    *,
    client: {},
) -> Optional[
    Union[
        PreviewCitationResponse400, PreviewCitationResponse401, PreviewCitationResponse404, PreviewCitationResponse500
    ]
]:
    """Preview file from citation.

    Args:
        id (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[PreviewCitationResponse400, PreviewCitationResponse401, PreviewCitationResponse404, PreviewCitationResponse500]
    """

    return sync_detailed(
        id=id,
        client=client,
    ).parsed


async def asyncio_detailed(
    id: str,
    *,
    client: {},
) -> Response[
    Union[
        PreviewCitationResponse400, PreviewCitationResponse401, PreviewCitationResponse404, PreviewCitationResponse500
    ]
]:
    kwargs = _get_kwargs(
        id=id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    id: str,
    *,
    client: {},
) -> Optional[
    Union[
        PreviewCitationResponse400, PreviewCitationResponse401, PreviewCitationResponse404, PreviewCitationResponse500
    ]
]:
    """Preview file from citation.

    Args:
        id (str):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[PreviewCitationResponse400, PreviewCitationResponse401, PreviewCitationResponse404, PreviewCitationResponse500]
    """

    return (
        await asyncio_detailed(
            id=id,
            client=client,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/pages/reindex_page.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.reindex_page_response_200 import ReindexPageResponse200
from ...models.reindex_page_response_400 import ReindexPageResponse400
from ...models.reindex_page_response_401 import ReindexPageResponse401
from ...models.reindex_page_response_403 import ReindexPageResponse403
from ...models.reindex_page_response_500 import ReindexPageResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    page_id: int,
    *,
    client: {},
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/pages/{pageId}/reindex".format(
        client.base_url, projectId=project_id, pageId=page_id
    )

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    return {
        "method": "post",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        ReindexPageResponse200,
        ReindexPageResponse400,
        ReindexPageResponse401,
        ReindexPageResponse403,
        ReindexPageResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = ReindexPageResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = ReindexPageResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = ReindexPageResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.FORBIDDEN:
        response_403 = ReindexPageResponse403.from_dict(json.loads(response.text))

        return response_403
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = ReindexPageResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        ReindexPageResponse200,
        ReindexPageResponse400,
        ReindexPageResponse401,
        ReindexPageResponse403,
        ReindexPageResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    page_id: int,
    *,
    client: {},
):
    """Reindex a certain page that belongs to a certain project.

     Reindex a specific page within a project based on its unique projectId and pageId. This endpoint
    allows you to refresh a particular page from the project. Our system will crawl and index page
    content newly.

    Args:
        project_id (int):
        page_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[ReindexPageResponse200, ReindexPageResponse400, ReindexPageResponse401, ReindexPageResponse403, ReindexPageResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        page_id=page_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    page_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        ReindexPageResponse200,
        ReindexPageResponse400,
        ReindexPageResponse401,
        ReindexPageResponse403,
        ReindexPageResponse500,
    ]
]:
    """Reindex a certain page that belongs to a certain project.

     Reindex a specific page within a project based on its unique projectId and pageId. This endpoint
    allows you to refresh a particular page from the project. Our system will crawl and index page
    content newly.

    Args:
        project_id (int):
        page_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[ReindexPageResponse200, ReindexPageResponse400, ReindexPageResponse401, ReindexPageResponse403, ReindexPageResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        page_id=page_id,
        client=client,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    page_id: int,
    *,
    client: {},
) -> Response[
    Union[
        ReindexPageResponse200,
        ReindexPageResponse400,
        ReindexPageResponse401,
        ReindexPageResponse403,
        ReindexPageResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        page_id=page_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    page_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        ReindexPageResponse200,
        ReindexPageResponse400,
        ReindexPageResponse401,
        ReindexPageResponse403,
        ReindexPageResponse500,
    ]
]:
    """Reindex a certain page that belongs to a certain project.

     Reindex a specific page within a project based on its unique projectId and pageId. This endpoint
    allows you to refresh a particular page from the project. Our system will crawl and index page
    content newly.

    Args:
        project_id (int):
        page_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[ReindexPageResponse200, ReindexPageResponse400, ReindexPageResponse401, ReindexPageResponse403, ReindexPageResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            page_id=page_id,
            client=client,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/project_plugins/__init__.py:
```

```

Contents of customgpt-client/customgpt_client/api/project_plugins/create_plugin.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.create_plugin_json_body import CreatePluginJsonBody
from ...models.create_plugin_response_201 import CreatePluginResponse201
from ...models.create_plugin_response_400 import CreatePluginResponse400
from ...models.create_plugin_response_401 import CreatePluginResponse401
from ...models.create_plugin_response_404 import CreatePluginResponse404
from ...models.create_plugin_response_500 import CreatePluginResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    *,
    client: {},
    json_body: CreatePluginJsonBody,
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/plugins".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    json_json_body = json_body.to_dict()

    return {
        "method": "post",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "json": json_json_body,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        CreatePluginResponse201,
        CreatePluginResponse400,
        CreatePluginResponse401,
        CreatePluginResponse404,
        CreatePluginResponse500,
    ]
]:
    if response.status_code == HTTPStatus.CREATED:
        response_201 = CreatePluginResponse201.from_dict(json.loads(response.text))

        return response_201
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = CreatePluginResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = CreatePluginResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = CreatePluginResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = CreatePluginResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        CreatePluginResponse201,
        CreatePluginResponse400,
        CreatePluginResponse401,
        CreatePluginResponse404,
        CreatePluginResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
    json_body: CreatePluginJsonBody,
):
    """Create a plugin.

     Create a new plugin for a specific project identified by its unique projectId. This endpoint enables
    you to create a custom plugin for the project. Which allows you to share the custom chatbot as
    openai plugin to be shared globally.

    Args:
        project_id (int):
        json_body (CreatePluginJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[CreatePluginResponse201, CreatePluginResponse400, CreatePluginResponse401, CreatePluginResponse404, CreatePluginResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        json_body=json_body,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
    json_body: CreatePluginJsonBody,
) -> Optional[
    Union[
        CreatePluginResponse201,
        CreatePluginResponse400,
        CreatePluginResponse401,
        CreatePluginResponse404,
        CreatePluginResponse500,
    ]
]:
    """Create a plugin.

     Create a new plugin for a specific project identified by its unique projectId. This endpoint enables
    you to create a custom plugin for the project. Which allows you to share the custom chatbot as
    openai plugin to be shared globally.

    Args:
        project_id (int):
        json_body (CreatePluginJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[CreatePluginResponse201, CreatePluginResponse400, CreatePluginResponse401, CreatePluginResponse404, CreatePluginResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
        json_body=json_body,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
    json_body: CreatePluginJsonBody,
) -> Response[
    Union[
        CreatePluginResponse201,
        CreatePluginResponse400,
        CreatePluginResponse401,
        CreatePluginResponse404,
        CreatePluginResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        json_body=json_body,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
    json_body: CreatePluginJsonBody,
) -> Optional[
    Union[
        CreatePluginResponse201,
        CreatePluginResponse400,
        CreatePluginResponse401,
        CreatePluginResponse404,
        CreatePluginResponse500,
    ]
]:
    """Create a plugin.

     Create a new plugin for a specific project identified by its unique projectId. This endpoint enables
    you to create a custom plugin for the project. Which allows you to share the custom chatbot as
    openai plugin to be shared globally.

    Args:
        project_id (int):
        json_body (CreatePluginJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[CreatePluginResponse201, CreatePluginResponse400, CreatePluginResponse401, CreatePluginResponse404, CreatePluginResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
            json_body=json_body,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/project_plugins/get_plugin.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.get_plugin_response_200 import GetPluginResponse200
from ...models.get_plugin_response_400 import GetPluginResponse400
from ...models.get_plugin_response_401 import GetPluginResponse401
from ...models.get_plugin_response_404 import GetPluginResponse404
from ...models.get_plugin_response_500 import GetPluginResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    *,
    client: {},
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/plugins".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    return {
        "method": "get",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[GetPluginResponse200, GetPluginResponse400, GetPluginResponse401, GetPluginResponse404, GetPluginResponse500]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = GetPluginResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = GetPluginResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = GetPluginResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = GetPluginResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = GetPluginResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[GetPluginResponse200, GetPluginResponse400, GetPluginResponse401, GetPluginResponse404, GetPluginResponse500]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
):
    """Show a certain project plugin.

     Retrieve the plugin details associated with a project. This endpoint provides information about the
    project plugin.

    Args:
        project_id (int):  Example: 1.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[GetPluginResponse200, GetPluginResponse400, GetPluginResponse401, GetPluginResponse404, GetPluginResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
) -> Optional[
    Union[GetPluginResponse200, GetPluginResponse400, GetPluginResponse401, GetPluginResponse404, GetPluginResponse500]
]:
    """Show a certain project plugin.

     Retrieve the plugin details associated with a project. This endpoint provides information about the
    project plugin.

    Args:
        project_id (int):  Example: 1.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetPluginResponse200, GetPluginResponse400, GetPluginResponse401, GetPluginResponse404, GetPluginResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
) -> Response[
    Union[GetPluginResponse200, GetPluginResponse400, GetPluginResponse401, GetPluginResponse404, GetPluginResponse500]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
) -> Optional[
    Union[GetPluginResponse200, GetPluginResponse400, GetPluginResponse401, GetPluginResponse404, GetPluginResponse500]
]:
    """Show a certain project plugin.

     Retrieve the plugin details associated with a project. This endpoint provides information about the
    project plugin.

    Args:
        project_id (int):  Example: 1.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetPluginResponse200, GetPluginResponse400, GetPluginResponse401, GetPluginResponse404, GetPluginResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/project_plugins/update_plugin.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.update_plugin_json_body import UpdatePluginJsonBody
from ...models.update_plugin_response_200 import UpdatePluginResponse200
from ...models.update_plugin_response_400 import UpdatePluginResponse400
from ...models.update_plugin_response_401 import UpdatePluginResponse401
from ...models.update_plugin_response_404 import UpdatePluginResponse404
from ...models.update_plugin_response_500 import UpdatePluginResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    *,
    client: {},
    json_body: UpdatePluginJsonBody,
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/plugins".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    json_json_body = json_body.to_dict()

    return {
        "method": "put",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "json": json_json_body,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        UpdatePluginResponse200,
        UpdatePluginResponse400,
        UpdatePluginResponse401,
        UpdatePluginResponse404,
        UpdatePluginResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = UpdatePluginResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = UpdatePluginResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = UpdatePluginResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = UpdatePluginResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = UpdatePluginResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        UpdatePluginResponse200,
        UpdatePluginResponse400,
        UpdatePluginResponse401,
        UpdatePluginResponse404,
        UpdatePluginResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
    json_body: UpdatePluginJsonBody,
):
    """Update a plugin.

     Update the plugin configuration for a specific project identified by its unique projectId. This
    endpoint allows you to update the associated attributes of the plugin.

    Args:
        project_id (int):
        json_body (UpdatePluginJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[UpdatePluginResponse200, UpdatePluginResponse400, UpdatePluginResponse401, UpdatePluginResponse404, UpdatePluginResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        json_body=json_body,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
    json_body: UpdatePluginJsonBody,
) -> Optional[
    Union[
        UpdatePluginResponse200,
        UpdatePluginResponse400,
        UpdatePluginResponse401,
        UpdatePluginResponse404,
        UpdatePluginResponse500,
    ]
]:
    """Update a plugin.

     Update the plugin configuration for a specific project identified by its unique projectId. This
    endpoint allows you to update the associated attributes of the plugin.

    Args:
        project_id (int):
        json_body (UpdatePluginJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[UpdatePluginResponse200, UpdatePluginResponse400, UpdatePluginResponse401, UpdatePluginResponse404, UpdatePluginResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
        json_body=json_body,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
    json_body: UpdatePluginJsonBody,
) -> Response[
    Union[
        UpdatePluginResponse200,
        UpdatePluginResponse400,
        UpdatePluginResponse401,
        UpdatePluginResponse404,
        UpdatePluginResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        json_body=json_body,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
    json_body: UpdatePluginJsonBody,
) -> Optional[
    Union[
        UpdatePluginResponse200,
        UpdatePluginResponse400,
        UpdatePluginResponse401,
        UpdatePluginResponse404,
        UpdatePluginResponse500,
    ]
]:
    """Update a plugin.

     Update the plugin configuration for a specific project identified by its unique projectId. This
    endpoint allows you to update the associated attributes of the plugin.

    Args:
        project_id (int):
        json_body (UpdatePluginJsonBody):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[UpdatePluginResponse200, UpdatePluginResponse400, UpdatePluginResponse401, UpdatePluginResponse404, UpdatePluginResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
            json_body=json_body,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/project_settings/__init__.py:
```

```

Contents of customgpt-client/customgpt_client/api/project_settings/get_settings.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.get_settings_response_200 import GetSettingsResponse200
from ...models.get_settings_response_400 import GetSettingsResponse400
from ...models.get_settings_response_401 import GetSettingsResponse401
from ...models.get_settings_response_404 import GetSettingsResponse404
from ...models.get_settings_response_500 import GetSettingsResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    *,
    client: {},
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/settings".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    return {
        "method": "get",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        GetSettingsResponse200,
        GetSettingsResponse400,
        GetSettingsResponse401,
        GetSettingsResponse404,
        GetSettingsResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = GetSettingsResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = GetSettingsResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = GetSettingsResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = GetSettingsResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = GetSettingsResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        GetSettingsResponse200,
        GetSettingsResponse400,
        GetSettingsResponse401,
        GetSettingsResponse404,
        GetSettingsResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
):
    """Get project settings.

     Retrieve the project settings for a specific project. This endpoint allows you to fetch the
    configuration and settings associated with the project.
    Here is an example to get a project settings: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Get_Settings_for_a_particular_project.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Get_settings_for_a_particular_project.ipynb).

    Args:
        project_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[GetSettingsResponse200, GetSettingsResponse400, GetSettingsResponse401, GetSettingsResponse404, GetSettingsResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        GetSettingsResponse200,
        GetSettingsResponse400,
        GetSettingsResponse401,
        GetSettingsResponse404,
        GetSettingsResponse500,
    ]
]:
    """Get project settings.

     Retrieve the project settings for a specific project. This endpoint allows you to fetch the
    configuration and settings associated with the project.
    Here is an example to get a project settings: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Get_Settings_for_a_particular_project.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Get_settings_for_a_particular_project.ipynb).

    Args:
        project_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetSettingsResponse200, GetSettingsResponse400, GetSettingsResponse401, GetSettingsResponse404, GetSettingsResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
) -> Response[
    Union[
        GetSettingsResponse200,
        GetSettingsResponse400,
        GetSettingsResponse401,
        GetSettingsResponse404,
        GetSettingsResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        GetSettingsResponse200,
        GetSettingsResponse400,
        GetSettingsResponse401,
        GetSettingsResponse404,
        GetSettingsResponse500,
    ]
]:
    """Get project settings.

     Retrieve the project settings for a specific project. This endpoint allows you to fetch the
    configuration and settings associated with the project.
    Here is an example to get a project settings: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Get_Settings_for_a_particular_project.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Get_settings_for_a_particular_project.ipynb).

    Args:
        project_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetSettingsResponse200, GetSettingsResponse400, GetSettingsResponse401, GetSettingsResponse404, GetSettingsResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/project_settings/update_settings.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.update_settings_multipart_data import UpdateSettingsMultipartData
from ...models.update_settings_response_200 import UpdateSettingsResponse200
from ...models.update_settings_response_400 import UpdateSettingsResponse400
from ...models.update_settings_response_401 import UpdateSettingsResponse401
from ...models.update_settings_response_500 import UpdateSettingsResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    *,
    client: {},
    multipart_data: UpdateSettingsMultipartData,
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/settings".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    multipart_multipart_data = multipart_data.to_multipart()

    return {
        "method": "post",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "files": multipart_multipart_data,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[UpdateSettingsResponse200, UpdateSettingsResponse400, UpdateSettingsResponse401, UpdateSettingsResponse500]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = UpdateSettingsResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = UpdateSettingsResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = UpdateSettingsResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = UpdateSettingsResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[UpdateSettingsResponse200, UpdateSettingsResponse400, UpdateSettingsResponse401, UpdateSettingsResponse500]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
    multipart_data: UpdateSettingsMultipartData,
):
    """Update project settings.

     Update the project settings for a specific project. This endpoint allows you to update the
    configuration and settings associated with the project.
    Here is an example to get a project settings: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Update_settings_for_a_particular_project.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Update_project_settings.ipynb).

    Args:
        project_id (int):
        multipart_data (UpdateSettingsMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[UpdateSettingsResponse200, UpdateSettingsResponse400, UpdateSettingsResponse401, UpdateSettingsResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        multipart_data=multipart_data,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
    multipart_data: UpdateSettingsMultipartData,
) -> Optional[
    Union[UpdateSettingsResponse200, UpdateSettingsResponse400, UpdateSettingsResponse401, UpdateSettingsResponse500]
]:
    """Update project settings.

     Update the project settings for a specific project. This endpoint allows you to update the
    configuration and settings associated with the project.
    Here is an example to get a project settings: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Update_settings_for_a_particular_project.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Update_project_settings.ipynb).

    Args:
        project_id (int):
        multipart_data (UpdateSettingsMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[UpdateSettingsResponse200, UpdateSettingsResponse400, UpdateSettingsResponse401, UpdateSettingsResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
        multipart_data=multipart_data,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
    multipart_data: UpdateSettingsMultipartData,
) -> Response[
    Union[UpdateSettingsResponse200, UpdateSettingsResponse400, UpdateSettingsResponse401, UpdateSettingsResponse500]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        multipart_data=multipart_data,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
    multipart_data: UpdateSettingsMultipartData,
) -> Optional[
    Union[UpdateSettingsResponse200, UpdateSettingsResponse400, UpdateSettingsResponse401, UpdateSettingsResponse500]
]:
    """Update project settings.

     Update the project settings for a specific project. This endpoint allows you to update the
    configuration and settings associated with the project.
    Here is an example to get a project settings: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Update_settings_for_a_particular_project.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Update_project_settings.ipynb).

    Args:
        project_id (int):
        multipart_data (UpdateSettingsMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[UpdateSettingsResponse200, UpdateSettingsResponse400, UpdateSettingsResponse401, UpdateSettingsResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
            multipart_data=multipart_data,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/projects/__init__.py:
```

```

Contents of customgpt-client/customgpt_client/api/projects/create_project.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.create_project_multipart_data import CreateProjectMultipartData
from ...models.create_project_response_201 import CreateProjectResponse201
from ...models.create_project_response_400 import CreateProjectResponse400
from ...models.create_project_response_401 import CreateProjectResponse401
from ...models.create_project_response_500 import CreateProjectResponse500
from ...types import Response


def _get_kwargs(
    *,
    client: {},
    multipart_data: CreateProjectMultipartData,
) -> Dict[str, Any]:
    url = "{}/api/v1/projects".format(client.base_url)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    multipart_multipart_data = multipart_data.to_multipart()

    return {
        "method": "post",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "files": multipart_multipart_data,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[CreateProjectResponse201, CreateProjectResponse400, CreateProjectResponse401, CreateProjectResponse500]
]:
    if response.status_code == HTTPStatus.CREATED:
        response_201 = CreateProjectResponse201.from_dict(json.loads(response.text))

        return response_201
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = CreateProjectResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = CreateProjectResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = CreateProjectResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[CreateProjectResponse201, CreateProjectResponse400, CreateProjectResponse401, CreateProjectResponse500]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    *,
    client: {},
    multipart_data: CreateProjectMultipartData,
):
    """Create a new project.

     Create a new project by importing data either from a sitemap or an uploaded file. This endpoint
    enables you to initiate the creation of a new project by supplying the necessary project data that
    will be used as the context. You can choose to import the project structure and content from a
    sitemap url or upload a specific file format that contains the context can be any text, audio or
    video format. The system will process the provided data and generate a new project based on the
    imported or uploaded information.
    Here is an example to create a bot using a sitemap: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/Create_Bot_By_Sitemap.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Create_Bot_By_Sitemap.ipynb).

    Args:
        multipart_data (CreateProjectMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[CreateProjectResponse201, CreateProjectResponse400, CreateProjectResponse401, CreateProjectResponse500]]
    """

    kwargs = _get_kwargs(
        client=client,
        multipart_data=multipart_data,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    *,
    client: {},
    multipart_data: CreateProjectMultipartData,
) -> Optional[
    Union[CreateProjectResponse201, CreateProjectResponse400, CreateProjectResponse401, CreateProjectResponse500]
]:
    """Create a new project.

     Create a new project by importing data either from a sitemap or an uploaded file. This endpoint
    enables you to initiate the creation of a new project by supplying the necessary project data that
    will be used as the context. You can choose to import the project structure and content from a
    sitemap url or upload a specific file format that contains the context can be any text, audio or
    video format. The system will process the provided data and generate a new project based on the
    imported or uploaded information.
    Here is an example to create a bot using a sitemap: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/Create_Bot_By_Sitemap.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Create_Bot_By_Sitemap.ipynb).

    Args:
        multipart_data (CreateProjectMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[CreateProjectResponse201, CreateProjectResponse400, CreateProjectResponse401, CreateProjectResponse500]
    """

    return sync_detailed(
        client=client,
        multipart_data=multipart_data,
    ).parsed


async def asyncio_detailed(
    *,
    client: {},
    multipart_data: CreateProjectMultipartData,
) -> Response[
    Union[CreateProjectResponse201, CreateProjectResponse400, CreateProjectResponse401, CreateProjectResponse500]
]:
    kwargs = _get_kwargs(
        client=client,
        multipart_data=multipart_data,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    *,
    client: {},
    multipart_data: CreateProjectMultipartData,
) -> Optional[
    Union[CreateProjectResponse201, CreateProjectResponse400, CreateProjectResponse401, CreateProjectResponse500]
]:
    """Create a new project.

     Create a new project by importing data either from a sitemap or an uploaded file. This endpoint
    enables you to initiate the creation of a new project by supplying the necessary project data that
    will be used as the context. You can choose to import the project structure and content from a
    sitemap url or upload a specific file format that contains the context can be any text, audio or
    video format. The system will process the provided data and generate a new project based on the
    imported or uploaded information.
    Here is an example to create a bot using a sitemap: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/Create_Bot_By_Sitemap.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Create_Bot_By_Sitemap.ipynb).

    Args:
        multipart_data (CreateProjectMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[CreateProjectResponse201, CreateProjectResponse400, CreateProjectResponse401, CreateProjectResponse500]
    """

    return (
        await asyncio_detailed(
            client=client,
            multipart_data=multipart_data,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/projects/delete_project.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.delete_project_response_200 import DeleteProjectResponse200
from ...models.delete_project_response_400 import DeleteProjectResponse400
from ...models.delete_project_response_401 import DeleteProjectResponse401
from ...models.delete_project_response_404 import DeleteProjectResponse404
from ...models.delete_project_response_500 import DeleteProjectResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    *,
    client: {},
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    return {
        "method": "delete",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        DeleteProjectResponse200,
        DeleteProjectResponse400,
        DeleteProjectResponse401,
        DeleteProjectResponse404,
        DeleteProjectResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = DeleteProjectResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = DeleteProjectResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = DeleteProjectResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = DeleteProjectResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = DeleteProjectResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        DeleteProjectResponse200,
        DeleteProjectResponse400,
        DeleteProjectResponse401,
        DeleteProjectResponse404,
        DeleteProjectResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
):
    """Delete a certain project.

     Delete a project by its unique project ID. This endpoint allows you to remove an existing project
    from the system based on its ID.
    Here is an example to delete a project: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Delete_a_project.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Delete_a_project.ipynb).

    Args:
        project_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[DeleteProjectResponse200, DeleteProjectResponse400, DeleteProjectResponse401, DeleteProjectResponse404, DeleteProjectResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        DeleteProjectResponse200,
        DeleteProjectResponse400,
        DeleteProjectResponse401,
        DeleteProjectResponse404,
        DeleteProjectResponse500,
    ]
]:
    """Delete a certain project.

     Delete a project by its unique project ID. This endpoint allows you to remove an existing project
    from the system based on its ID.
    Here is an example to delete a project: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Delete_a_project.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Delete_a_project.ipynb).

    Args:
        project_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[DeleteProjectResponse200, DeleteProjectResponse400, DeleteProjectResponse401, DeleteProjectResponse404, DeleteProjectResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
) -> Response[
    Union[
        DeleteProjectResponse200,
        DeleteProjectResponse400,
        DeleteProjectResponse401,
        DeleteProjectResponse404,
        DeleteProjectResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        DeleteProjectResponse200,
        DeleteProjectResponse400,
        DeleteProjectResponse401,
        DeleteProjectResponse404,
        DeleteProjectResponse500,
    ]
]:
    """Delete a certain project.

     Delete a project by its unique project ID. This endpoint allows you to remove an existing project
    from the system based on its ID.
    Here is an example to delete a project: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Delete_a_project.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Delete_a_project.ipynb).

    Args:
        project_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[DeleteProjectResponse200, DeleteProjectResponse400, DeleteProjectResponse401, DeleteProjectResponse404, DeleteProjectResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/projects/get_project.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.get_project_response_200 import GetProjectResponse200
from ...models.get_project_response_400 import GetProjectResponse400
from ...models.get_project_response_401 import GetProjectResponse401
from ...models.get_project_response_404 import GetProjectResponse404
from ...models.get_project_response_500 import GetProjectResponse500
from ...types import UNSET, Response, Unset


def _get_kwargs(
    project_id: int,
    *,
    client: {},
    width: Union[Unset, None, str] = "100%",
    height: Union[Unset, None, str] = "auto",
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    params: Dict[str, Any] = {}
    params["width"] = width

    params["height"] = height

    params = {k: v for k, v in params.items() if v is not UNSET and v is not None}

    return {
        "method": "get",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "params": params,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        GetProjectResponse200,
        GetProjectResponse400,
        GetProjectResponse401,
        GetProjectResponse404,
        GetProjectResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = GetProjectResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = GetProjectResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = GetProjectResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = GetProjectResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = GetProjectResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        GetProjectResponse200,
        GetProjectResponse400,
        GetProjectResponse401,
        GetProjectResponse404,
        GetProjectResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
    width: Union[Unset, None, str] = "100%",
    height: Union[Unset, None, str] = "auto",
):
    """Show a certain project.

     Retrieve details of a project based on its unique project ID. This endpoint allows you to fetch
    specific information about a project.

    Args:
        project_id (int):  Example: 1.
        width (Union[Unset, None, str]):  Default: '100%'. Example: 50rem.
        height (Union[Unset, None, str]):  Default: 'auto'. Example: 50rem.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[GetProjectResponse200, GetProjectResponse400, GetProjectResponse401, GetProjectResponse404, GetProjectResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        width=width,
        height=height,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
    width: Union[Unset, None, str] = "100%",
    height: Union[Unset, None, str] = "auto",
) -> Optional[
    Union[
        GetProjectResponse200,
        GetProjectResponse400,
        GetProjectResponse401,
        GetProjectResponse404,
        GetProjectResponse500,
    ]
]:
    """Show a certain project.

     Retrieve details of a project based on its unique project ID. This endpoint allows you to fetch
    specific information about a project.

    Args:
        project_id (int):  Example: 1.
        width (Union[Unset, None, str]):  Default: '100%'. Example: 50rem.
        height (Union[Unset, None, str]):  Default: 'auto'. Example: 50rem.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetProjectResponse200, GetProjectResponse400, GetProjectResponse401, GetProjectResponse404, GetProjectResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
        width=width,
        height=height,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
    width: Union[Unset, None, str] = "100%",
    height: Union[Unset, None, str] = "auto",
) -> Response[
    Union[
        GetProjectResponse200,
        GetProjectResponse400,
        GetProjectResponse401,
        GetProjectResponse404,
        GetProjectResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        width=width,
        height=height,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
    width: Union[Unset, None, str] = "100%",
    height: Union[Unset, None, str] = "auto",
) -> Optional[
    Union[
        GetProjectResponse200,
        GetProjectResponse400,
        GetProjectResponse401,
        GetProjectResponse404,
        GetProjectResponse500,
    ]
]:
    """Show a certain project.

     Retrieve details of a project based on its unique project ID. This endpoint allows you to fetch
    specific information about a project.

    Args:
        project_id (int):  Example: 1.
        width (Union[Unset, None, str]):  Default: '100%'. Example: 50rem.
        height (Union[Unset, None, str]):  Default: 'auto'. Example: 50rem.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetProjectResponse200, GetProjectResponse400, GetProjectResponse401, GetProjectResponse404, GetProjectResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
            width=width,
            height=height,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/projects/list_projects.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.list_projects_order import ListProjectsOrder
from ...models.list_projects_response_200 import ListProjectsResponse200
from ...models.list_projects_response_401 import ListProjectsResponse401
from ...models.list_projects_response_500 import ListProjectsResponse500
from ...types import UNSET, Response, Unset


def _get_kwargs(
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    duration: Union[Unset, None, int] = UNSET,
    order: Union[Unset, None, ListProjectsOrder] = ListProjectsOrder.DESC,
    width: Union[Unset, None, str] = "100%",
    height: Union[Unset, None, str] = "auto",
) -> Dict[str, Any]:
    url = "{}/api/v1/projects".format(client.base_url)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    params: Dict[str, Any] = {}
    params["page"] = page

    params["duration"] = duration

    json_order: Union[Unset, None, str] = UNSET
    if not isinstance(order, Unset):
        json_order = order if order else None

    params["order"] = json_order

    params["width"] = width

    params["height"] = height

    params = {k: v for k, v in params.items() if v is not UNSET and v is not None}

    return {
        "method": "get",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "params": params,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[Union[ListProjectsResponse200, ListProjectsResponse401, ListProjectsResponse500]]:
    if response.status_code == HTTPStatus.OK:
        response_200 = ListProjectsResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = ListProjectsResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = ListProjectsResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[Union[ListProjectsResponse200, ListProjectsResponse401, ListProjectsResponse500]]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    duration: Union[Unset, None, int] = UNSET,
    order: Union[Unset, None, ListProjectsOrder] = ListProjectsOrder.DESC,
    width: Union[Unset, None, str] = "100%",
    height: Union[Unset, None, str] = "auto",
):
    """List all projects.

     Returns a list of your projects. The projects are returned sorted by creation date, with the most
    recent projects appearing first. It is a paginated API and you can use the page parameter to fetch
    the next page of projects. The default page size is 10.

    Here is an example to list projects: using [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/List_all_projects_for_an_account_with_pagination.ipynb) and using our
    python [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_List_all_projects_using_pagination.ipynb).

    Args:
        page (Union[Unset, None, int]):  Default: 1. Example: 1.
        duration (Union[Unset, None, int]):
        order (Union[Unset, None, ListProjectsOrder]):  Default: ListProjectsOrder.DESC.
        width (Union[Unset, None, str]):  Default: '100%'. Example: 50rem.
        height (Union[Unset, None, str]):  Default: 'auto'. Example: 50rem.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[ListProjectsResponse200, ListProjectsResponse401, ListProjectsResponse500]]
    """

    kwargs = _get_kwargs(
        client=client,
        page=page,
        duration=duration,
        order=order,
        width=width,
        height=height,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    duration: Union[Unset, None, int] = UNSET,
    order: Union[Unset, None, ListProjectsOrder] = ListProjectsOrder.DESC,
    width: Union[Unset, None, str] = "100%",
    height: Union[Unset, None, str] = "auto",
) -> Optional[Union[ListProjectsResponse200, ListProjectsResponse401, ListProjectsResponse500]]:
    """List all projects.

     Returns a list of your projects. The projects are returned sorted by creation date, with the most
    recent projects appearing first. It is a paginated API and you can use the page parameter to fetch
    the next page of projects. The default page size is 10.

    Here is an example to list projects: using [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/List_all_projects_for_an_account_with_pagination.ipynb) and using our
    python [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_List_all_projects_using_pagination.ipynb).

    Args:
        page (Union[Unset, None, int]):  Default: 1. Example: 1.
        duration (Union[Unset, None, int]):
        order (Union[Unset, None, ListProjectsOrder]):  Default: ListProjectsOrder.DESC.
        width (Union[Unset, None, str]):  Default: '100%'. Example: 50rem.
        height (Union[Unset, None, str]):  Default: 'auto'. Example: 50rem.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[ListProjectsResponse200, ListProjectsResponse401, ListProjectsResponse500]
    """

    return sync_detailed(
        client=client,
        page=page,
        duration=duration,
        order=order,
        width=width,
        height=height,
    ).parsed


async def asyncio_detailed(
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    duration: Union[Unset, None, int] = UNSET,
    order: Union[Unset, None, ListProjectsOrder] = ListProjectsOrder.DESC,
    width: Union[Unset, None, str] = "100%",
    height: Union[Unset, None, str] = "auto",
) -> Response[Union[ListProjectsResponse200, ListProjectsResponse401, ListProjectsResponse500]]:
    kwargs = _get_kwargs(
        client=client,
        page=page,
        duration=duration,
        order=order,
        width=width,
        height=height,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    *,
    client: {},
    page: Union[Unset, None, int] = 1,
    duration: Union[Unset, None, int] = UNSET,
    order: Union[Unset, None, ListProjectsOrder] = ListProjectsOrder.DESC,
    width: Union[Unset, None, str] = "100%",
    height: Union[Unset, None, str] = "auto",
) -> Optional[Union[ListProjectsResponse200, ListProjectsResponse401, ListProjectsResponse500]]:
    """List all projects.

     Returns a list of your projects. The projects are returned sorted by creation date, with the most
    recent projects appearing first. It is a paginated API and you can use the page parameter to fetch
    the next page of projects. The default page size is 10.

    Here is an example to list projects: using [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/List_all_projects_for_an_account_with_pagination.ipynb) and using our
    python [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_List_all_projects_using_pagination.ipynb).

    Args:
        page (Union[Unset, None, int]):  Default: 1. Example: 1.
        duration (Union[Unset, None, int]):
        order (Union[Unset, None, ListProjectsOrder]):  Default: ListProjectsOrder.DESC.
        width (Union[Unset, None, str]):  Default: '100%'. Example: 50rem.
        height (Union[Unset, None, str]):  Default: 'auto'. Example: 50rem.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[ListProjectsResponse200, ListProjectsResponse401, ListProjectsResponse500]
    """

    return (
        await asyncio_detailed(
            client=client,
            page=page,
            duration=duration,
            order=order,
            width=width,
            height=height,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/projects/stats_project.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.stats_project_response_200 import StatsProjectResponse200
from ...models.stats_project_response_400 import StatsProjectResponse400
from ...models.stats_project_response_401 import StatsProjectResponse401
from ...models.stats_project_response_404 import StatsProjectResponse404
from ...models.stats_project_response_500 import StatsProjectResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    *,
    client: {},
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/stats".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    return {
        "method": "get",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        StatsProjectResponse200,
        StatsProjectResponse400,
        StatsProjectResponse401,
        StatsProjectResponse404,
        StatsProjectResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = StatsProjectResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = StatsProjectResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = StatsProjectResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = StatsProjectResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = StatsProjectResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        StatsProjectResponse200,
        StatsProjectResponse400,
        StatsProjectResponse401,
        StatsProjectResponse404,
        StatsProjectResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
):
    """Get the stats for a certain project.

     Retrieve statistical data for a project using its unique projectId. This endpoint provides extensive
    statistics about the project's performance, activity, or other relevant metrics.
    Here is an example to a specific object stats: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Get_Project_Stats.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Get_Project_Stats.ipynb).

    Args:
        project_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[StatsProjectResponse200, StatsProjectResponse400, StatsProjectResponse401, StatsProjectResponse404, StatsProjectResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        StatsProjectResponse200,
        StatsProjectResponse400,
        StatsProjectResponse401,
        StatsProjectResponse404,
        StatsProjectResponse500,
    ]
]:
    """Get the stats for a certain project.

     Retrieve statistical data for a project using its unique projectId. This endpoint provides extensive
    statistics about the project's performance, activity, or other relevant metrics.
    Here is an example to a specific object stats: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Get_Project_Stats.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Get_Project_Stats.ipynb).

    Args:
        project_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[StatsProjectResponse200, StatsProjectResponse400, StatsProjectResponse401, StatsProjectResponse404, StatsProjectResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
) -> Response[
    Union[
        StatsProjectResponse200,
        StatsProjectResponse400,
        StatsProjectResponse401,
        StatsProjectResponse404,
        StatsProjectResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        StatsProjectResponse200,
        StatsProjectResponse400,
        StatsProjectResponse401,
        StatsProjectResponse404,
        StatsProjectResponse500,
    ]
]:
    """Get the stats for a certain project.

     Retrieve statistical data for a project using its unique projectId. This endpoint provides extensive
    statistics about the project's performance, activity, or other relevant metrics.
    Here is an example to a specific object stats: [API](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/Get_Project_Stats.ipynb) [SDK](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/SDK_Get_Project_Stats.ipynb).

    Args:
        project_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[StatsProjectResponse200, StatsProjectResponse400, StatsProjectResponse401, StatsProjectResponse404, StatsProjectResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/projects/update_project.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.update_project_multipart_data import UpdateProjectMultipartData
from ...models.update_project_response_200 import UpdateProjectResponse200
from ...models.update_project_response_400 import UpdateProjectResponse400
from ...models.update_project_response_401 import UpdateProjectResponse401
from ...models.update_project_response_404 import UpdateProjectResponse404
from ...models.update_project_response_500 import UpdateProjectResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    *,
    client: {},
    multipart_data: UpdateProjectMultipartData,
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    multipart_multipart_data = multipart_data.to_multipart()

    return {
        "method": "post",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "files": multipart_multipart_data,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        UpdateProjectResponse200,
        UpdateProjectResponse400,
        UpdateProjectResponse401,
        UpdateProjectResponse404,
        UpdateProjectResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = UpdateProjectResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = UpdateProjectResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = UpdateProjectResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = UpdateProjectResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = UpdateProjectResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        UpdateProjectResponse200,
        UpdateProjectResponse400,
        UpdateProjectResponse401,
        UpdateProjectResponse404,
        UpdateProjectResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
    multipart_data: UpdateProjectMultipartData,
):
    """Update a certain project.

     Update a project with specific details based on its unique projectId. This endpoint allows you to
    modify and revise the information associated with a particular project
    Here is an example to a update a specific object: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/Update%20a%20project%20name.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Update_a_project_name.ipynb).

    Args:
        project_id (int):
        multipart_data (UpdateProjectMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[UpdateProjectResponse200, UpdateProjectResponse400, UpdateProjectResponse401, UpdateProjectResponse404, UpdateProjectResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        multipart_data=multipart_data,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
    multipart_data: UpdateProjectMultipartData,
) -> Optional[
    Union[
        UpdateProjectResponse200,
        UpdateProjectResponse400,
        UpdateProjectResponse401,
        UpdateProjectResponse404,
        UpdateProjectResponse500,
    ]
]:
    """Update a certain project.

     Update a project with specific details based on its unique projectId. This endpoint allows you to
    modify and revise the information associated with a particular project
    Here is an example to a update a specific object: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/Update%20a%20project%20name.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Update_a_project_name.ipynb).

    Args:
        project_id (int):
        multipart_data (UpdateProjectMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[UpdateProjectResponse200, UpdateProjectResponse400, UpdateProjectResponse401, UpdateProjectResponse404, UpdateProjectResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
        multipart_data=multipart_data,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
    multipart_data: UpdateProjectMultipartData,
) -> Response[
    Union[
        UpdateProjectResponse200,
        UpdateProjectResponse400,
        UpdateProjectResponse401,
        UpdateProjectResponse404,
        UpdateProjectResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        multipart_data=multipart_data,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
    multipart_data: UpdateProjectMultipartData,
) -> Optional[
    Union[
        UpdateProjectResponse200,
        UpdateProjectResponse400,
        UpdateProjectResponse401,
        UpdateProjectResponse404,
        UpdateProjectResponse500,
    ]
]:
    """Update a certain project.

     Update a project with specific details based on its unique projectId. This endpoint allows you to
    modify and revise the information associated with a particular project
    Here is an example to a update a specific object: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/Update%20a%20project%20name.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Update_a_project_name.ipynb).

    Args:
        project_id (int):
        multipart_data (UpdateProjectMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[UpdateProjectResponse200, UpdateProjectResponse400, UpdateProjectResponse401, UpdateProjectResponse404, UpdateProjectResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
            multipart_data=multipart_data,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/sources/__init__.py:
```

```

Contents of customgpt-client/customgpt_client/api/sources/create_source.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.create_source_multipart_data import CreateSourceMultipartData
from ...models.create_source_response_201 import CreateSourceResponse201
from ...models.create_source_response_400 import CreateSourceResponse400
from ...models.create_source_response_401 import CreateSourceResponse401
from ...models.create_source_response_404 import CreateSourceResponse404
from ...models.create_source_response_500 import CreateSourceResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    *,
    client: {},
    multipart_data: CreateSourceMultipartData,
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/sources".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    multipart_multipart_data = multipart_data.to_multipart()

    return {
        "method": "post",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "files": multipart_multipart_data,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        CreateSourceResponse201,
        CreateSourceResponse400,
        CreateSourceResponse401,
        CreateSourceResponse404,
        CreateSourceResponse500,
    ]
]:
    if response.status_code == HTTPStatus.CREATED:
        response_201 = CreateSourceResponse201.from_dict(json.loads(response.text))

        return response_201
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = CreateSourceResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = CreateSourceResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = CreateSourceResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = CreateSourceResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        CreateSourceResponse201,
        CreateSourceResponse400,
        CreateSourceResponse401,
        CreateSourceResponse404,
        CreateSourceResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
    multipart_data: CreateSourceMultipartData,
):
    """Create a new project source.

     Create a new data source for a given project, allowing you to add additional context by specifying a
    sitemap URL or uploading a file. This endpoint enables you to enrich the project's information by
    incorporating relevant data sources.
    Here is an example to add a new source to project: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/Add_a_sitemap_to_an_existing_project.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Add_a_Sitemap_to_project.ipynb).

    Args:
        project_id (int):
        multipart_data (CreateSourceMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[CreateSourceResponse201, CreateSourceResponse400, CreateSourceResponse401, CreateSourceResponse404, CreateSourceResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        multipart_data=multipart_data,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
    multipart_data: CreateSourceMultipartData,
) -> Optional[
    Union[
        CreateSourceResponse201,
        CreateSourceResponse400,
        CreateSourceResponse401,
        CreateSourceResponse404,
        CreateSourceResponse500,
    ]
]:
    """Create a new project source.

     Create a new data source for a given project, allowing you to add additional context by specifying a
    sitemap URL or uploading a file. This endpoint enables you to enrich the project's information by
    incorporating relevant data sources.
    Here is an example to add a new source to project: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/Add_a_sitemap_to_an_existing_project.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Add_a_Sitemap_to_project.ipynb).

    Args:
        project_id (int):
        multipart_data (CreateSourceMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[CreateSourceResponse201, CreateSourceResponse400, CreateSourceResponse401, CreateSourceResponse404, CreateSourceResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
        multipart_data=multipart_data,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
    multipart_data: CreateSourceMultipartData,
) -> Response[
    Union[
        CreateSourceResponse201,
        CreateSourceResponse400,
        CreateSourceResponse401,
        CreateSourceResponse404,
        CreateSourceResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
        multipart_data=multipart_data,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
    multipart_data: CreateSourceMultipartData,
) -> Optional[
    Union[
        CreateSourceResponse201,
        CreateSourceResponse400,
        CreateSourceResponse401,
        CreateSourceResponse404,
        CreateSourceResponse500,
    ]
]:
    """Create a new project source.

     Create a new data source for a given project, allowing you to add additional context by specifying a
    sitemap URL or uploading a file. This endpoint enables you to enrich the project's information by
    incorporating relevant data sources.
    Here is an example to add a new source to project: [API](https://github.com/Poll-The-
    People/customgpt-cookbook/blob/main/examples/Add_a_sitemap_to_an_existing_project.ipynb)
    [SDK](https://github.com/Poll-The-People/customgpt-
    cookbook/blob/main/examples/SDK_Add_a_Sitemap_to_project.ipynb).

    Args:
        project_id (int):
        multipart_data (CreateSourceMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[CreateSourceResponse201, CreateSourceResponse400, CreateSourceResponse401, CreateSourceResponse404, CreateSourceResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
            multipart_data=multipart_data,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/sources/delete_source.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.delete_source_response_200 import DeleteSourceResponse200
from ...models.delete_source_response_400 import DeleteSourceResponse400
from ...models.delete_source_response_401 import DeleteSourceResponse401
from ...models.delete_source_response_404 import DeleteSourceResponse404
from ...models.delete_source_response_500 import DeleteSourceResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    source_id: int,
    *,
    client: {},
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/sources/{sourceId}".format(
        client.base_url, projectId=project_id, sourceId=source_id
    )

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    return {
        "method": "delete",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        DeleteSourceResponse200,
        DeleteSourceResponse400,
        DeleteSourceResponse401,
        DeleteSourceResponse404,
        DeleteSourceResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = DeleteSourceResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = DeleteSourceResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = DeleteSourceResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = DeleteSourceResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = DeleteSourceResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        DeleteSourceResponse200,
        DeleteSourceResponse400,
        DeleteSourceResponse401,
        DeleteSourceResponse404,
        DeleteSourceResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    source_id: int,
    *,
    client: {},
):
    """Delete a project source.

     Delete a source for a given project.

    Args:
        project_id (int):
        source_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[DeleteSourceResponse200, DeleteSourceResponse400, DeleteSourceResponse401, DeleteSourceResponse404, DeleteSourceResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        source_id=source_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    source_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        DeleteSourceResponse200,
        DeleteSourceResponse400,
        DeleteSourceResponse401,
        DeleteSourceResponse404,
        DeleteSourceResponse500,
    ]
]:
    """Delete a project source.

     Delete a source for a given project.

    Args:
        project_id (int):
        source_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[DeleteSourceResponse200, DeleteSourceResponse400, DeleteSourceResponse401, DeleteSourceResponse404, DeleteSourceResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        source_id=source_id,
        client=client,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    source_id: int,
    *,
    client: {},
) -> Response[
    Union[
        DeleteSourceResponse200,
        DeleteSourceResponse400,
        DeleteSourceResponse401,
        DeleteSourceResponse404,
        DeleteSourceResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        source_id=source_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    source_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        DeleteSourceResponse200,
        DeleteSourceResponse400,
        DeleteSourceResponse401,
        DeleteSourceResponse404,
        DeleteSourceResponse500,
    ]
]:
    """Delete a project source.

     Delete a source for a given project.

    Args:
        project_id (int):
        source_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[DeleteSourceResponse200, DeleteSourceResponse400, DeleteSourceResponse401, DeleteSourceResponse404, DeleteSourceResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            source_id=source_id,
            client=client,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/sources/list_sources.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.list_sources_response_200 import ListSourcesResponse200
from ...models.list_sources_response_400 import ListSourcesResponse400
from ...models.list_sources_response_401 import ListSourcesResponse401
from ...models.list_sources_response_404 import ListSourcesResponse404
from ...models.list_sources_response_500 import ListSourcesResponse500
from ...types import Response


def _get_kwargs(
    project_id: int,
    *,
    client: {},
) -> Dict[str, Any]:
    url = "{}/api/v1/projects/{projectId}/sources".format(client.base_url, projectId=project_id)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    return {
        "method": "get",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[
    Union[
        ListSourcesResponse200,
        ListSourcesResponse400,
        ListSourcesResponse401,
        ListSourcesResponse404,
        ListSourcesResponse500,
    ]
]:
    if response.status_code == HTTPStatus.OK:
        response_200 = ListSourcesResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.BAD_REQUEST:
        response_400 = ListSourcesResponse400.from_dict(json.loads(response.text))

        return response_400
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = ListSourcesResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.NOT_FOUND:
        response_404 = ListSourcesResponse404.from_dict(json.loads(response.text))

        return response_404
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = ListSourcesResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[
    Union[
        ListSourcesResponse200,
        ListSourcesResponse400,
        ListSourcesResponse401,
        ListSourcesResponse404,
        ListSourcesResponse500,
    ]
]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    project_id: int,
    *,
    client: {},
):
    """List a certain project's sources.

     Retrieve a list of all sources associated with a given project. This endpoint provides a collection
    of sources that are linked to a specific project. Sources serve as references or contexts for the
    project.

    Args:
        project_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[ListSourcesResponse200, ListSourcesResponse400, ListSourcesResponse401, ListSourcesResponse404, ListSourcesResponse500]]
    """

    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    project_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        ListSourcesResponse200,
        ListSourcesResponse400,
        ListSourcesResponse401,
        ListSourcesResponse404,
        ListSourcesResponse500,
    ]
]:
    """List a certain project's sources.

     Retrieve a list of all sources associated with a given project. This endpoint provides a collection
    of sources that are linked to a specific project. Sources serve as references or contexts for the
    project.

    Args:
        project_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[ListSourcesResponse200, ListSourcesResponse400, ListSourcesResponse401, ListSourcesResponse404, ListSourcesResponse500]
    """

    return sync_detailed(
        project_id=project_id,
        client=client,
    ).parsed


async def asyncio_detailed(
    project_id: int,
    *,
    client: {},
) -> Response[
    Union[
        ListSourcesResponse200,
        ListSourcesResponse400,
        ListSourcesResponse401,
        ListSourcesResponse404,
        ListSourcesResponse500,
    ]
]:
    kwargs = _get_kwargs(
        project_id=project_id,
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    project_id: int,
    *,
    client: {},
) -> Optional[
    Union[
        ListSourcesResponse200,
        ListSourcesResponse400,
        ListSourcesResponse401,
        ListSourcesResponse404,
        ListSourcesResponse500,
    ]
]:
    """List a certain project's sources.

     Retrieve a list of all sources associated with a given project. This endpoint provides a collection
    of sources that are linked to a specific project. Sources serve as references or contexts for the
    project.

    Args:
        project_id (int):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[ListSourcesResponse200, ListSourcesResponse400, ListSourcesResponse401, ListSourcesResponse404, ListSourcesResponse500]
    """

    return (
        await asyncio_detailed(
            project_id=project_id,
            client=client,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/users/__init__.py:
```

```

Contents of customgpt-client/customgpt_client/api/users/get_user.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.get_user_response_200 import GetUserResponse200
from ...models.get_user_response_401 import GetUserResponse401
from ...models.get_user_response_500 import GetUserResponse500
from ...types import Response


def _get_kwargs(
    *,
    client: {},
) -> Dict[str, Any]:
    url = "{}/api/v1/user".format(client.base_url)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    return {
        "method": "get",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[Union[GetUserResponse200, GetUserResponse401, GetUserResponse500]]:
    if response.status_code == HTTPStatus.OK:
        response_200 = GetUserResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = GetUserResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = GetUserResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[Union[GetUserResponse200, GetUserResponse401, GetUserResponse500]]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    *,
    client: {},
):
    """Show the user's profile.

     Retrieve the profile information of the current user. This endpoint allows you to fetch the details
    and attributes associated with the user's profile, providing valuable information about the user's
    account and preferences.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[GetUserResponse200, GetUserResponse401, GetUserResponse500]]
    """

    kwargs = _get_kwargs(
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    *,
    client: {},
) -> Optional[Union[GetUserResponse200, GetUserResponse401, GetUserResponse500]]:
    """Show the user's profile.

     Retrieve the profile information of the current user. This endpoint allows you to fetch the details
    and attributes associated with the user's profile, providing valuable information about the user's
    account and preferences.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetUserResponse200, GetUserResponse401, GetUserResponse500]
    """

    return sync_detailed(
        client=client,
    ).parsed


async def asyncio_detailed(
    *,
    client: {},
) -> Response[Union[GetUserResponse200, GetUserResponse401, GetUserResponse500]]:
    kwargs = _get_kwargs(
        client=client,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    *,
    client: {},
) -> Optional[Union[GetUserResponse200, GetUserResponse401, GetUserResponse500]]:
    """Show the user's profile.

     Retrieve the profile information of the current user. This endpoint allows you to fetch the details
    and attributes associated with the user's profile, providing valuable information about the user's
    account and preferences.

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[GetUserResponse200, GetUserResponse401, GetUserResponse500]
    """

    return (
        await asyncio_detailed(
            client=client,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/api/users/update_user.py:
```
import json
from http import HTTPStatus
from typing import Any, Dict, Optional, Union

import requests

from ... import errors
from ...models.update_user_multipart_data import UpdateUserMultipartData
from ...models.update_user_response_200 import UpdateUserResponse200
from ...models.update_user_response_401 import UpdateUserResponse401
from ...models.update_user_response_500 import UpdateUserResponse500
from ...types import Response


def _get_kwargs(
    *,
    client: {},
    multipart_data: UpdateUserMultipartData,
) -> Dict[str, Any]:
    url = "{}/api/v1/user".format(client.base_url)

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()

    multipart_multipart_data = multipart_data.to_multipart()

    return {
        "method": "post",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        "files": multipart_multipart_data,
    }


def _parse_response(
    *, client: {}, response: None
) -> Optional[Union[UpdateUserResponse200, UpdateUserResponse401, UpdateUserResponse500]]:
    if response.status_code == HTTPStatus.OK:
        response_200 = UpdateUserResponse200.from_dict(json.loads(response.text))

        return response_200
    if response.status_code == HTTPStatus.UNAUTHORIZED:
        response_401 = UpdateUserResponse401.from_dict(json.loads(response.text))

        return response_401
    if response.status_code == HTTPStatus.INTERNAL_SERVER_ERROR:
        response_500 = UpdateUserResponse500.from_dict(json.loads(response.text))

        return response_500
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(
    *, client: {}, response: None, content: Optional[bytes] = None
) -> Response[Union[UpdateUserResponse200, UpdateUserResponse401, UpdateUserResponse500]]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )


def sync_detailed(
    *,
    client: {},
    multipart_data: UpdateUserMultipartData,
):
    """Update the user's profile.

     Update the profile of the current user. This endpoint allows the user to modify and update their
    profile information and preferences within the application or system.

    Args:
        multipart_data (UpdateUserMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Response[Union[UpdateUserResponse200, UpdateUserResponse401, UpdateUserResponse500]]
    """

    kwargs = _get_kwargs(
        client=client,
        multipart_data=multipart_data,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


def sync(
    *,
    client: {},
    multipart_data: UpdateUserMultipartData,
) -> Optional[Union[UpdateUserResponse200, UpdateUserResponse401, UpdateUserResponse500]]:
    """Update the user's profile.

     Update the profile of the current user. This endpoint allows the user to modify and update their
    profile information and preferences within the application or system.

    Args:
        multipart_data (UpdateUserMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[UpdateUserResponse200, UpdateUserResponse401, UpdateUserResponse500]
    """

    return sync_detailed(
        client=client,
        multipart_data=multipart_data,
    ).parsed


async def asyncio_detailed(
    *,
    client: {},
    multipart_data: UpdateUserMultipartData,
) -> Response[Union[UpdateUserResponse200, UpdateUserResponse401, UpdateUserResponse500]]:
    kwargs = _get_kwargs(
        client=client,
        multipart_data=multipart_data,
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)


async def asyncio(
    *,
    client: {},
    multipart_data: UpdateUserMultipartData,
) -> Optional[Union[UpdateUserResponse200, UpdateUserResponse401, UpdateUserResponse500]]:
    """Update the user's profile.

     Update the profile of the current user. This endpoint allows the user to modify and update their
    profile information and preferences within the application or system.

    Args:
        multipart_data (UpdateUserMultipartData):

    Raises:
        errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
        httpx.TimeoutException: If the request takes longer than Client.timeout.

    Returns:
        Union[UpdateUserResponse200, UpdateUserResponse401, UpdateUserResponse500]
    """

    return (
        await asyncio_detailed(
            client=client,
            multipart_data=multipart_data,
        )
    ).parsed

```

Contents of customgpt-client/customgpt_client/models/__init__.py:
```
""" Contains all the data models used in inputs/outputs """

from .conversation import Conversation
from .create_conversation_json_body import CreateConversationJsonBody
from .create_conversation_response_201 import CreateConversationResponse201
from .create_conversation_response_201_data import CreateConversationResponse201Data
from .create_conversation_response_201_status import CreateConversationResponse201Status
from .create_conversation_response_400 import CreateConversationResponse400
from .create_conversation_response_400_data import CreateConversationResponse400Data
from .create_conversation_response_400_data_code import CreateConversationResponse400DataCode
from .create_conversation_response_400_status import CreateConversationResponse400Status
from .create_conversation_response_401 import CreateConversationResponse401
from .create_conversation_response_401_data import CreateConversationResponse401Data
from .create_conversation_response_401_data_code import CreateConversationResponse401DataCode
from .create_conversation_response_401_status import CreateConversationResponse401Status
from .create_conversation_response_404 import CreateConversationResponse404
from .create_conversation_response_404_data import CreateConversationResponse404Data
from .create_conversation_response_404_data_code import CreateConversationResponse404DataCode
from .create_conversation_response_404_data_message import CreateConversationResponse404DataMessage
from .create_conversation_response_404_status import CreateConversationResponse404Status
from .create_conversation_response_500 import CreateConversationResponse500
from .create_conversation_response_500_data import CreateConversationResponse500Data
from .create_conversation_response_500_data_code import CreateConversationResponse500DataCode
from .create_conversation_response_500_status import CreateConversationResponse500Status
from .create_plugin_json_body import CreatePluginJsonBody
from .create_plugin_response_201 import CreatePluginResponse201
from .create_plugin_response_201_data import CreatePluginResponse201Data
from .create_plugin_response_201_status import CreatePluginResponse201Status
from .create_plugin_response_400 import CreatePluginResponse400
from .create_plugin_response_400_data import CreatePluginResponse400Data
from .create_plugin_response_400_data_code import CreatePluginResponse400DataCode
from .create_plugin_response_400_status import CreatePluginResponse400Status
from .create_plugin_response_401 import CreatePluginResponse401
from .create_plugin_response_401_data import CreatePluginResponse401Data
from .create_plugin_response_401_data_code import CreatePluginResponse401DataCode
from .create_plugin_response_401_status import CreatePluginResponse401Status
from .create_plugin_response_404 import CreatePluginResponse404
from .create_plugin_response_404_data import CreatePluginResponse404Data
from .create_plugin_response_404_data_code import CreatePluginResponse404DataCode
from .create_plugin_response_404_data_message import CreatePluginResponse404DataMessage
from .create_plugin_response_404_status import CreatePluginResponse404Status
from .create_plugin_response_500 import CreatePluginResponse500
from .create_plugin_response_500_data import CreatePluginResponse500Data
from .create_plugin_response_500_data_code import CreatePluginResponse500DataCode
from .create_plugin_response_500_status import CreatePluginResponse500Status
from .create_project_multipart_data import CreateProjectMultipartData
from .create_project_response_201 import CreateProjectResponse201
from .create_project_response_201_data import CreateProjectResponse201Data
from .create_project_response_201_data_type import CreateProjectResponse201DataType
from .create_project_response_201_status import CreateProjectResponse201Status
from .create_project_response_400 import CreateProjectResponse400
from .create_project_response_400_data import CreateProjectResponse400Data
from .create_project_response_400_data_code import CreateProjectResponse400DataCode
from .create_project_response_400_data_message import CreateProjectResponse400DataMessage
from .create_project_response_400_status import CreateProjectResponse400Status
from .create_project_response_401 import CreateProjectResponse401
from .create_project_response_401_data import CreateProjectResponse401Data
from .create_project_response_401_data_code import CreateProjectResponse401DataCode
from .create_project_response_401_status import CreateProjectResponse401Status
from .create_project_response_500 import CreateProjectResponse500
from .create_project_response_500_data import CreateProjectResponse500Data
from .create_project_response_500_data_code import CreateProjectResponse500DataCode
from .create_project_response_500_status import CreateProjectResponse500Status
from .create_source_multipart_data import CreateSourceMultipartData
from .create_source_response_201 import CreateSourceResponse201
from .create_source_response_201_data import CreateSourceResponse201Data
from .create_source_response_201_data_pages_item import CreateSourceResponse201DataPagesItem
from .create_source_response_201_data_pages_item_crawl_status import CreateSourceResponse201DataPagesItemCrawlStatus
from .create_source_response_201_data_pages_item_index_status import CreateSourceResponse201DataPagesItemIndexStatus
from .create_source_response_201_data_settings import CreateSourceResponse201DataSettings
from .create_source_response_201_data_type import CreateSourceResponse201DataType
from .create_source_response_201_status import CreateSourceResponse201Status
from .create_source_response_400 import CreateSourceResponse400
from .create_source_response_400_data import CreateSourceResponse400Data
from .create_source_response_400_data_code import CreateSourceResponse400DataCode
from .create_source_response_400_data_message import CreateSourceResponse400DataMessage
from .create_source_response_400_status import CreateSourceResponse400Status
from .create_source_response_401 import CreateSourceResponse401
from .create_source_response_401_data import CreateSourceResponse401Data
from .create_source_response_401_data_code import CreateSourceResponse401DataCode
from .create_source_response_401_status import CreateSourceResponse401Status
from .create_source_response_404 import CreateSourceResponse404
from .create_source_response_404_data import CreateSourceResponse404Data
from .create_source_response_404_data_code import CreateSourceResponse404DataCode
from .create_source_response_404_data_message import CreateSourceResponse404DataMessage
from .create_source_response_404_status import CreateSourceResponse404Status
from .create_source_response_500 import CreateSourceResponse500
from .create_source_response_500_data import CreateSourceResponse500Data
from .create_source_response_500_data_code import CreateSourceResponse500DataCode
from .create_source_response_500_status import CreateSourceResponse500Status
from .delete_conversation_response_200 import DeleteConversationResponse200
from .delete_conversation_response_200_data import DeleteConversationResponse200Data
from .delete_conversation_response_200_status import DeleteConversationResponse200Status
from .delete_conversation_response_400 import DeleteConversationResponse400
from .delete_conversation_response_400_data import DeleteConversationResponse400Data
from .delete_conversation_response_400_data_code import DeleteConversationResponse400DataCode
from .delete_conversation_response_400_status import DeleteConversationResponse400Status
from .delete_conversation_response_401 import DeleteConversationResponse401
from .delete_conversation_response_401_data import DeleteConversationResponse401Data
from .delete_conversation_response_401_data_code import DeleteConversationResponse401DataCode
from .delete_conversation_response_401_status import DeleteConversationResponse401Status
from .delete_conversation_response_404 import DeleteConversationResponse404
from .delete_conversation_response_404_data import DeleteConversationResponse404Data
from .delete_conversation_response_404_data_code import DeleteConversationResponse404DataCode
from .delete_conversation_response_404_data_message import DeleteConversationResponse404DataMessage
from .delete_conversation_response_404_status import DeleteConversationResponse404Status
from .delete_conversation_response_500 import DeleteConversationResponse500
from .delete_conversation_response_500_data import DeleteConversationResponse500Data
from .delete_conversation_response_500_data_code import DeleteConversationResponse500DataCode
from .delete_conversation_response_500_status import DeleteConversationResponse500Status
from .delete_page_response_200 import DeletePageResponse200
from .delete_page_response_200_data import DeletePageResponse200Data
from .delete_page_response_200_status import DeletePageResponse200Status
from .delete_page_response_400 import DeletePageResponse400
from .delete_page_response_400_data import DeletePageResponse400Data
from .delete_page_response_400_data_code import DeletePageResponse400DataCode
from .delete_page_response_400_status import DeletePageResponse400Status
from .delete_page_response_401 import DeletePageResponse401
from .delete_page_response_401_data import DeletePageResponse401Data
from .delete_page_response_401_data_code import DeletePageResponse401DataCode
from .delete_page_response_401_status import DeletePageResponse401Status
from .delete_page_response_404 import DeletePageResponse404
from .delete_page_response_404_data import DeletePageResponse404Data
from .delete_page_response_404_data_code import DeletePageResponse404DataCode
from .delete_page_response_404_data_message import DeletePageResponse404DataMessage
from .delete_page_response_404_status import DeletePageResponse404Status
from .delete_page_response_500 import DeletePageResponse500
from .delete_page_response_500_data import DeletePageResponse500Data
from .delete_page_response_500_data_code import DeletePageResponse500DataCode
from .delete_page_response_500_status import DeletePageResponse500Status
from .delete_project_response_200 import DeleteProjectResponse200
from .delete_project_response_200_data import DeleteProjectResponse200Data
from .delete_project_response_200_status import DeleteProjectResponse200Status
from .delete_project_response_400 import DeleteProjectResponse400
from .delete_project_response_400_data import DeleteProjectResponse400Data
from .delete_project_response_400_data_code import DeleteProjectResponse400DataCode
from .delete_project_response_400_status import DeleteProjectResponse400Status
from .delete_project_response_401 import DeleteProjectResponse401
from .delete_project_response_401_data import DeleteProjectResponse401Data
from .delete_project_response_401_data_code import DeleteProjectResponse401DataCode
from .delete_project_response_401_status import DeleteProjectResponse401Status
from .delete_project_response_404 import DeleteProjectResponse404
from .delete_project_response_404_data import DeleteProjectResponse404Data
from .delete_project_response_404_data_code import DeleteProjectResponse404DataCode
from .delete_project_response_404_data_message import DeleteProjectResponse404DataMessage
from .delete_project_response_404_status import DeleteProjectResponse404Status
from .delete_project_response_500 import DeleteProjectResponse500
from .delete_project_response_500_data import DeleteProjectResponse500Data
from .delete_project_response_500_data_code import DeleteProjectResponse500DataCode
from .delete_project_response_500_status import DeleteProjectResponse500Status
from .delete_source_response_200 import DeleteSourceResponse200
from .delete_source_response_200_data import DeleteSourceResponse200Data
from .delete_source_response_200_status import DeleteSourceResponse200Status
from .delete_source_response_400 import DeleteSourceResponse400
from .delete_source_response_400_data import DeleteSourceResponse400Data
from .delete_source_response_400_data_code import DeleteSourceResponse400DataCode
from .delete_source_response_400_status import DeleteSourceResponse400Status
from .delete_source_response_401 import DeleteSourceResponse401
from .delete_source_response_401_data import DeleteSourceResponse401Data
from .delete_source_response_401_data_code import DeleteSourceResponse401DataCode
from .delete_source_response_401_status import DeleteSourceResponse401Status
from .delete_source_response_404 import DeleteSourceResponse404
from .delete_source_response_404_data import DeleteSourceResponse404Data
from .delete_source_response_404_data_code import DeleteSourceResponse404DataCode
from .delete_source_response_404_data_message import DeleteSourceResponse404DataMessage
from .delete_source_response_404_status import DeleteSourceResponse404Status
from .delete_source_response_500 import DeleteSourceResponse500
from .delete_source_response_500_data import DeleteSourceResponse500Data
from .delete_source_response_500_data_code import DeleteSourceResponse500DataCode
from .delete_source_response_500_status import DeleteSourceResponse500Status
from .get_citation_response_200 import GetCitationResponse200
from .get_citation_response_200_data import GetCitationResponse200Data
from .get_citation_response_200_status import GetCitationResponse200Status
from .get_citation_response_400 import GetCitationResponse400
from .get_citation_response_400_data import GetCitationResponse400Data
from .get_citation_response_400_data_code import GetCitationResponse400DataCode
from .get_citation_response_400_status import GetCitationResponse400Status
from .get_citation_response_401 import GetCitationResponse401
from .get_citation_response_401_data import GetCitationResponse401Data
from .get_citation_response_401_data_code import GetCitationResponse401DataCode
from .get_citation_response_401_status import GetCitationResponse401Status
from .get_citation_response_404 import GetCitationResponse404
from .get_citation_response_404_data import GetCitationResponse404Data
from .get_citation_response_404_data_code import GetCitationResponse404DataCode
from .get_citation_response_404_data_message import GetCitationResponse404DataMessage
from .get_citation_response_404_status import GetCitationResponse404Status
from .get_conversations_order import GetConversationsOrder
from .get_conversations_response_200 import GetConversationsResponse200
from .get_conversations_response_200_data import GetConversationsResponse200Data
from .get_conversations_response_200_data_data_item import GetConversationsResponse200DataDataItem
from .get_conversations_response_200_status import GetConversationsResponse200Status
from .get_conversations_response_400 import GetConversationsResponse400
from .get_conversations_response_400_data import GetConversationsResponse400Data
from .get_conversations_response_400_data_code import GetConversationsResponse400DataCode
from .get_conversations_response_400_status import GetConversationsResponse400Status
from .get_conversations_response_401 import GetConversationsResponse401
from .get_conversations_response_401_data import GetConversationsResponse401Data
from .get_conversations_response_401_data_code import GetConversationsResponse401DataCode
from .get_conversations_response_401_status import GetConversationsResponse401Status
from .get_conversations_response_404 import GetConversationsResponse404
from .get_conversations_response_404_data import GetConversationsResponse404Data
from .get_conversations_response_404_data_code import GetConversationsResponse404DataCode
from .get_conversations_response_404_data_message import GetConversationsResponse404DataMessage
from .get_conversations_response_404_status import GetConversationsResponse404Status
from .get_conversations_response_500 import GetConversationsResponse500
from .get_conversations_response_500_data import GetConversationsResponse500Data
from .get_conversations_response_500_data_code import GetConversationsResponse500DataCode
from .get_conversations_response_500_status import GetConversationsResponse500Status
from .get_conversations_user_filter import GetConversationsUserFilter
from .get_page_metadata_response_200 import GetPageMetadataResponse200
from .get_page_metadata_response_200_data import GetPageMetadataResponse200Data
from .get_page_metadata_response_200_status import GetPageMetadataResponse200Status
from .get_page_metadata_response_400 import GetPageMetadataResponse400
from .get_page_metadata_response_400_data import GetPageMetadataResponse400Data
from .get_page_metadata_response_400_data_code import GetPageMetadataResponse400DataCode
from .get_page_metadata_response_400_status import GetPageMetadataResponse400Status
from .get_page_metadata_response_401 import GetPageMetadataResponse401
from .get_page_metadata_response_401_data import GetPageMetadataResponse401Data
from .get_page_metadata_response_401_data_code import GetPageMetadataResponse401DataCode
from .get_page_metadata_response_401_status import GetPageMetadataResponse401Status
from .get_page_metadata_response_404 import GetPageMetadataResponse404
from .get_page_metadata_response_404_data import GetPageMetadataResponse404Data
from .get_page_metadata_response_404_data_code import GetPageMetadataResponse404DataCode
from .get_page_metadata_response_404_data_message import GetPageMetadataResponse404DataMessage
from .get_page_metadata_response_404_status import GetPageMetadataResponse404Status
from .get_pages_order import GetPagesOrder
from .get_pages_response_200 import GetPagesResponse200
from .get_pages_response_200_data import GetPagesResponse200Data
from .get_pages_response_200_data_pages import GetPagesResponse200DataPages
from .get_pages_response_200_data_pages_data_item import GetPagesResponse200DataPagesDataItem
from .get_pages_response_200_data_pages_data_item_crawl_status import GetPagesResponse200DataPagesDataItemCrawlStatus
from .get_pages_response_200_data_pages_data_item_index_status import GetPagesResponse200DataPagesDataItemIndexStatus
from .get_pages_response_200_data_project import GetPagesResponse200DataProject
from .get_pages_response_200_data_project_type import GetPagesResponse200DataProjectType
from .get_pages_response_200_status import GetPagesResponse200Status
from .get_pages_response_400 import GetPagesResponse400
from .get_pages_response_400_data import GetPagesResponse400Data
from .get_pages_response_400_data_code import GetPagesResponse400DataCode
from .get_pages_response_400_status import GetPagesResponse400Status
from .get_pages_response_401 import GetPagesResponse401
from .get_pages_response_401_data import GetPagesResponse401Data
from .get_pages_response_401_data_code import GetPagesResponse401DataCode
from .get_pages_response_401_status import GetPagesResponse401Status
from .get_pages_response_404 import GetPagesResponse404
from .get_pages_response_404_data import GetPagesResponse404Data
from .get_pages_response_404_data_code import GetPagesResponse404DataCode
from .get_pages_response_404_data_message import GetPagesResponse404DataMessage
from .get_pages_response_404_status import GetPagesResponse404Status
from .get_pages_response_500 import GetPagesResponse500
from .get_pages_response_500_data import GetPagesResponse500Data
from .get_pages_response_500_data_code import GetPagesResponse500DataCode
from .get_pages_response_500_status import GetPagesResponse500Status
from .get_plugin_response_200 import GetPluginResponse200
from .get_plugin_response_200_data import GetPluginResponse200Data
from .get_plugin_response_200_status import GetPluginResponse200Status
from .get_plugin_response_400 import GetPluginResponse400
from .get_plugin_response_400_data import GetPluginResponse400Data
from .get_plugin_response_400_data_code import GetPluginResponse400DataCode
from .get_plugin_response_400_status import GetPluginResponse400Status
from .get_plugin_response_401 import GetPluginResponse401
from .get_plugin_response_401_data import GetPluginResponse401Data
from .get_plugin_response_401_data_code import GetPluginResponse401DataCode
from .get_plugin_response_401_status import GetPluginResponse401Status
from .get_plugin_response_404 import GetPluginResponse404
from .get_plugin_response_404_data import GetPluginResponse404Data
from .get_plugin_response_404_data_code import GetPluginResponse404DataCode
from .get_plugin_response_404_data_message import GetPluginResponse404DataMessage
from .get_plugin_response_404_status import GetPluginResponse404Status
from .get_plugin_response_500 import GetPluginResponse500
from .get_plugin_response_500_data import GetPluginResponse500Data
from .get_plugin_response_500_data_code import GetPluginResponse500DataCode
from .get_plugin_response_500_status import GetPluginResponse500Status
from .get_project_response_200 import GetProjectResponse200
from .get_project_response_200_data import GetProjectResponse200Data
from .get_project_response_200_data_type import GetProjectResponse200DataType
from .get_project_response_200_status import GetProjectResponse200Status
from .get_project_response_400 import GetProjectResponse400
from .get_project_response_400_data import GetProjectResponse400Data
from .get_project_response_400_data_code import GetProjectResponse400DataCode
from .get_project_response_400_status import GetProjectResponse400Status
from .get_project_response_401 import GetProjectResponse401
from .get_project_response_401_data import GetProjectResponse401Data
from .get_project_response_401_data_code import GetProjectResponse401DataCode
from .get_project_response_401_status import GetProjectResponse401Status
from .get_project_response_404 import GetProjectResponse404
from .get_project_response_404_data import GetProjectResponse404Data
from .get_project_response_404_data_code import GetProjectResponse404DataCode
from .get_project_response_404_data_message import GetProjectResponse404DataMessage
from .get_project_response_404_status import GetProjectResponse404Status
from .get_project_response_500 import GetProjectResponse500
from .get_project_response_500_data import GetProjectResponse500Data
from .get_project_response_500_data_code import GetProjectResponse500DataCode
from .get_project_response_500_status import GetProjectResponse500Status
from .get_settings_response_200 import GetSettingsResponse200
from .get_settings_response_200_data import GetSettingsResponse200Data
from .get_settings_response_200_data_citations_view_type import GetSettingsResponse200DataCitationsViewType
from .get_settings_response_200_status import GetSettingsResponse200Status
from .get_settings_response_400 import GetSettingsResponse400
from .get_settings_response_400_data import GetSettingsResponse400Data
from .get_settings_response_400_data_code import GetSettingsResponse400DataCode
from .get_settings_response_400_status import GetSettingsResponse400Status
from .get_settings_response_401 import GetSettingsResponse401
from .get_settings_response_401_data import GetSettingsResponse401Data
from .get_settings_response_401_data_code import GetSettingsResponse401DataCode
from .get_settings_response_401_status import GetSettingsResponse401Status
from .get_settings_response_404 import GetSettingsResponse404
from .get_settings_response_404_data import GetSettingsResponse404Data
from .get_settings_response_404_data_code import GetSettingsResponse404DataCode
from .get_settings_response_404_data_message import GetSettingsResponse404DataMessage
from .get_settings_response_404_status import GetSettingsResponse404Status
from .get_settings_response_500 import GetSettingsResponse500
from .get_settings_response_500_data import GetSettingsResponse500Data
from .get_settings_response_500_data_code import GetSettingsResponse500DataCode
from .get_settings_response_500_status import GetSettingsResponse500Status
from .get_user_response_200 import GetUserResponse200
from .get_user_response_200_data import GetUserResponse200Data
from .get_user_response_200_status import GetUserResponse200Status
from .get_user_response_401 import GetUserResponse401
from .get_user_response_401_data import GetUserResponse401Data
from .get_user_response_401_data_code import GetUserResponse401DataCode
from .get_user_response_401_status import GetUserResponse401Status
from .get_user_response_500 import GetUserResponse500
from .get_user_response_500_data import GetUserResponse500Data
from .get_user_response_500_data_code import GetUserResponse500DataCode
from .get_user_response_500_status import GetUserResponse500Status
from .list_projects_order import ListProjectsOrder
from .list_projects_response_200 import ListProjectsResponse200
from .list_projects_response_200_data import ListProjectsResponse200Data
from .list_projects_response_200_data_data_item import ListProjectsResponse200DataDataItem
from .list_projects_response_200_data_data_item_type import ListProjectsResponse200DataDataItemType
from .list_projects_response_200_status import ListProjectsResponse200Status
from .list_projects_response_401 import ListProjectsResponse401
from .list_projects_response_401_data import ListProjectsResponse401Data
from .list_projects_response_401_data_code import ListProjectsResponse401DataCode
from .list_projects_response_401_status import ListProjectsResponse401Status
from .list_projects_response_500 import ListProjectsResponse500
from .list_projects_response_500_data import ListProjectsResponse500Data
from .list_projects_response_500_data_code import ListProjectsResponse500DataCode
from .list_projects_response_500_status import ListProjectsResponse500Status
from .list_sources_response_200 import ListSourcesResponse200
from .list_sources_response_200_data import ListSourcesResponse200Data
from .list_sources_response_200_data_sitemaps_item import ListSourcesResponse200DataSitemapsItem
from .list_sources_response_200_data_sitemaps_item_pages_item import ListSourcesResponse200DataSitemapsItemPagesItem
from .list_sources_response_200_data_sitemaps_item_pages_item_crawl_status import (
    ListSourcesResponse200DataSitemapsItemPagesItemCrawlStatus,
)
from .list_sources_response_200_data_sitemaps_item_pages_item_index_status import (
    ListSourcesResponse200DataSitemapsItemPagesItemIndexStatus,
)
from .list_sources_response_200_data_sitemaps_item_settings import ListSourcesResponse200DataSitemapsItemSettings
from .list_sources_response_200_data_sitemaps_item_type import ListSourcesResponse200DataSitemapsItemType
from .list_sources_response_200_data_uploads import ListSourcesResponse200DataUploads
from .list_sources_response_200_data_uploads_pages_item import ListSourcesResponse200DataUploadsPagesItem
from .list_sources_response_200_data_uploads_pages_item_crawl_status import (
    ListSourcesResponse200DataUploadsPagesItemCrawlStatus,
)
from .list_sources_response_200_data_uploads_pages_item_index_status import (
    ListSourcesResponse200DataUploadsPagesItemIndexStatus,
)
from .list_sources_response_200_data_uploads_settings import ListSourcesResponse200DataUploadsSettings
from .list_sources_response_200_data_uploads_type import ListSourcesResponse200DataUploadsType
from .list_sources_response_200_status import ListSourcesResponse200Status
from .list_sources_response_400 import ListSourcesResponse400
from .list_sources_response_400_data import ListSourcesResponse400Data
from .list_sources_response_400_data_code import ListSourcesResponse400DataCode
from .list_sources_response_400_status import ListSourcesResponse400Status
from .list_sources_response_401 import ListSourcesResponse401
from .list_sources_response_401_data import ListSourcesResponse401Data
from .list_sources_response_401_data_code import ListSourcesResponse401DataCode
from .list_sources_response_401_status import ListSourcesResponse401Status
from .list_sources_response_404 import ListSourcesResponse404
from .list_sources_response_404_data import ListSourcesResponse404Data
from .list_sources_response_404_data_code import ListSourcesResponse404DataCode
from .list_sources_response_404_data_message import ListSourcesResponse404DataMessage
from .list_sources_response_404_status import ListSourcesResponse404Status
from .list_sources_response_500 import ListSourcesResponse500
from .list_sources_response_500_data import ListSourcesResponse500Data
from .list_sources_response_500_data_code import ListSourcesResponse500DataCode
from .list_sources_response_500_status import ListSourcesResponse500Status
from .messages_conversation_order import MessagesConversationOrder
from .messages_conversation_response_200 import MessagesConversationResponse200
from .messages_conversation_response_200_data import MessagesConversationResponse200Data
from .messages_conversation_response_200_data_conversation import MessagesConversationResponse200DataConversation
from .messages_conversation_response_200_data_messages import MessagesConversationResponse200DataMessages
from .messages_conversation_response_200_data_messages_data_item import (
    MessagesConversationResponse200DataMessagesDataItem,
)
from .messages_conversation_response_200_data_messages_data_item_metadata import (
    MessagesConversationResponse200DataMessagesDataItemMetadata,
)
from .messages_conversation_response_200_status import MessagesConversationResponse200Status
from .messages_conversation_response_400 import MessagesConversationResponse400
from .messages_conversation_response_400_data import MessagesConversationResponse400Data
from .messages_conversation_response_400_data_code import MessagesConversationResponse400DataCode
from .messages_conversation_response_400_status import MessagesConversationResponse400Status
from .messages_conversation_response_401 import MessagesConversationResponse401
from .messages_conversation_response_401_data import MessagesConversationResponse401Data
from .messages_conversation_response_401_data_code import MessagesConversationResponse401DataCode
from .messages_conversation_response_401_status import MessagesConversationResponse401Status
from .messages_conversation_response_404 import MessagesConversationResponse404
from .messages_conversation_response_404_data import MessagesConversationResponse404Data
from .messages_conversation_response_404_data_code import MessagesConversationResponse404DataCode
from .messages_conversation_response_404_data_message import MessagesConversationResponse404DataMessage
from .messages_conversation_response_404_status import MessagesConversationResponse404Status
from .messages_conversation_response_500 import MessagesConversationResponse500
from .messages_conversation_response_500_data import MessagesConversationResponse500Data
from .messages_conversation_response_500_data_code import MessagesConversationResponse500DataCode
from .messages_conversation_response_500_status import MessagesConversationResponse500Status
from .open_graph_cache import OpenGraphCache
from .page import Page
from .page_crawl_status import PageCrawlStatus
from .page_index_status import PageIndexStatus
from .page_metadata import PageMetadata
from .preview_citation_response_400 import PreviewCitationResponse400
from .preview_citation_response_400_data import PreviewCitationResponse400Data
from .preview_citation_response_400_data_code import PreviewCitationResponse400DataCode
from .preview_citation_response_400_status import PreviewCitationResponse400Status
from .preview_citation_response_401 import PreviewCitationResponse401
from .preview_citation_response_401_data import PreviewCitationResponse401Data
from .preview_citation_response_401_data_code import PreviewCitationResponse401DataCode
from .preview_citation_response_401_status import PreviewCitationResponse401Status
from .preview_citation_response_404 import PreviewCitationResponse404
from .preview_citation_response_404_data import PreviewCitationResponse404Data
from .preview_citation_response_404_data_code import PreviewCitationResponse404DataCode
from .preview_citation_response_404_data_message import PreviewCitationResponse404DataMessage
from .preview_citation_response_404_status import PreviewCitationResponse404Status
from .preview_citation_response_500 import PreviewCitationResponse500
from .preview_citation_response_500_data import PreviewCitationResponse500Data
from .preview_citation_response_500_data_code import PreviewCitationResponse500DataCode
from .preview_citation_response_500_status import PreviewCitationResponse500Status
from .project import Project
from .project_plugin import ProjectPlugin
from .project_settings import ProjectSettings
from .project_settings_citations_view_type import ProjectSettingsCitationsViewType
from .project_settings_response_source import ProjectSettingsResponseSource
from .project_source import ProjectSource
from .project_source_settings import ProjectSourceSettings
from .project_source_type import ProjectSourceType
from .project_type import ProjectType
from .prompt_history import PromptHistory
from .prompt_history_metadata import PromptHistoryMetadata
from .reindex_page_response_200 import ReindexPageResponse200
from .reindex_page_response_200_data import ReindexPageResponse200Data
from .reindex_page_response_200_status import ReindexPageResponse200Status
from .reindex_page_response_400 import ReindexPageResponse400
from .reindex_page_response_400_data import ReindexPageResponse400Data
from .reindex_page_response_400_data_code import ReindexPageResponse400DataCode
from .reindex_page_response_400_status import ReindexPageResponse400Status
from .reindex_page_response_401 import ReindexPageResponse401
from .reindex_page_response_401_data import ReindexPageResponse401Data
from .reindex_page_response_401_data_code import ReindexPageResponse401DataCode
from .reindex_page_response_401_status import ReindexPageResponse401Status
from .reindex_page_response_403 import ReindexPageResponse403
from .reindex_page_response_403_data import ReindexPageResponse403Data
from .reindex_page_response_403_data_code import ReindexPageResponse403DataCode
from .reindex_page_response_403_data_message import ReindexPageResponse403DataMessage
from .reindex_page_response_403_status import ReindexPageResponse403Status
from .reindex_page_response_500 import ReindexPageResponse500
from .reindex_page_response_500_data import ReindexPageResponse500Data
from .reindex_page_response_500_data_code import ReindexPageResponse500DataCode
from .reindex_page_response_500_status import ReindexPageResponse500Status
from .send_message_json_body import SendMessageJsonBody
from .send_message_response_200 import SendMessageResponse200
from .send_message_response_200_data import SendMessageResponse200Data
from .send_message_response_200_data_metadata import SendMessageResponse200DataMetadata
from .send_message_response_200_status import SendMessageResponse200Status
from .send_message_response_400 import SendMessageResponse400
from .send_message_response_400_data import SendMessageResponse400Data
from .send_message_response_400_data_code import SendMessageResponse400DataCode
from .send_message_response_400_status import SendMessageResponse400Status
from .send_message_response_401 import SendMessageResponse401
from .send_message_response_401_data import SendMessageResponse401Data
from .send_message_response_401_data_code import SendMessageResponse401DataCode
from .send_message_response_401_status import SendMessageResponse401Status
from .send_message_response_404 import SendMessageResponse404
from .send_message_response_404_data import SendMessageResponse404Data
from .send_message_response_404_data_code import SendMessageResponse404DataCode
from .send_message_response_404_data_message import SendMessageResponse404DataMessage
from .send_message_response_404_status import SendMessageResponse404Status
from .send_message_response_500 import SendMessageResponse500
from .send_message_response_500_data import SendMessageResponse500Data
from .send_message_response_500_data_code import SendMessageResponse500DataCode
from .send_message_response_500_status import SendMessageResponse500Status
from .stats_project_response_200 import StatsProjectResponse200
from .stats_project_response_200_data import StatsProjectResponse200Data
from .stats_project_response_200_status import StatsProjectResponse200Status
from .stats_project_response_400 import StatsProjectResponse400
from .stats_project_response_400_data import StatsProjectResponse400Data
from .stats_project_response_400_data_code import StatsProjectResponse400DataCode
from .stats_project_response_400_status import StatsProjectResponse400Status
from .stats_project_response_401 import StatsProjectResponse401
from .stats_project_response_401_data import StatsProjectResponse401Data
from .stats_project_response_401_data_code import StatsProjectResponse401DataCode
from .stats_project_response_401_status import StatsProjectResponse401Status
from .stats_project_response_404 import StatsProjectResponse404
from .stats_project_response_404_data import StatsProjectResponse404Data
from .stats_project_response_404_data_code import StatsProjectResponse404DataCode
from .stats_project_response_404_data_message import StatsProjectResponse404DataMessage
from .stats_project_response_404_status import StatsProjectResponse404Status
from .stats_project_response_500 import StatsProjectResponse500
from .stats_project_response_500_data import StatsProjectResponse500Data
from .stats_project_response_500_data_code import StatsProjectResponse500DataCode
from .stats_project_response_500_status import StatsProjectResponse500Status
from .update_conversation_json_body import UpdateConversationJsonBody
from .update_conversation_response_200 import UpdateConversationResponse200
from .update_conversation_response_200_data import UpdateConversationResponse200Data
from .update_conversation_response_200_status import UpdateConversationResponse200Status
from .update_conversation_response_400 import UpdateConversationResponse400
from .update_conversation_response_400_data import UpdateConversationResponse400Data
from .update_conversation_response_400_data_code import UpdateConversationResponse400DataCode
from .update_conversation_response_400_status import UpdateConversationResponse400Status
from .update_conversation_response_401 import UpdateConversationResponse401
from .update_conversation_response_401_data import UpdateConversationResponse401Data
from .update_conversation_response_401_data_code import UpdateConversationResponse401DataCode
from .update_conversation_response_401_status import UpdateConversationResponse401Status
from .update_conversation_response_404 import UpdateConversationResponse404
from .update_conversation_response_404_data import UpdateConversationResponse404Data
from .update_conversation_response_404_data_code import UpdateConversationResponse404DataCode
from .update_conversation_response_404_data_message import UpdateConversationResponse404DataMessage
from .update_conversation_response_404_status import UpdateConversationResponse404Status
from .update_conversation_response_500 import UpdateConversationResponse500
from .update_conversation_response_500_data import UpdateConversationResponse500Data
from .update_conversation_response_500_data_code import UpdateConversationResponse500DataCode
from .update_conversation_response_500_status import UpdateConversationResponse500Status
from .update_page_metadata_json_body import UpdatePageMetadataJsonBody
from .update_page_metadata_response_200 import UpdatePageMetadataResponse200
from .update_page_metadata_response_200_data import UpdatePageMetadataResponse200Data
from .update_page_metadata_response_200_status import UpdatePageMetadataResponse200Status
from .update_page_metadata_response_400 import UpdatePageMetadataResponse400
from .update_page_metadata_response_400_data import UpdatePageMetadataResponse400Data
from .update_page_metadata_response_400_data_code import UpdatePageMetadataResponse400DataCode
from .update_page_metadata_response_400_status import UpdatePageMetadataResponse400Status
from .update_page_metadata_response_401 import UpdatePageMetadataResponse401
from .update_page_metadata_response_401_data import UpdatePageMetadataResponse401Data
from .update_page_metadata_response_401_data_code import UpdatePageMetadataResponse401DataCode
from .update_page_metadata_response_401_status import UpdatePageMetadataResponse401Status
from .update_page_metadata_response_404 import UpdatePageMetadataResponse404
from .update_page_metadata_response_404_data import UpdatePageMetadataResponse404Data
from .update_page_metadata_response_404_data_code import UpdatePageMetadataResponse404DataCode
from .update_page_metadata_response_404_data_message import UpdatePageMetadataResponse404DataMessage
from .update_page_metadata_response_404_status import UpdatePageMetadataResponse404Status
from .update_page_metadata_response_500 import UpdatePageMetadataResponse500
from .update_page_metadata_response_500_data import UpdatePageMetadataResponse500Data
from .update_page_metadata_response_500_data_code import UpdatePageMetadataResponse500DataCode
from .update_page_metadata_response_500_status import UpdatePageMetadataResponse500Status
from .update_plugin_json_body import UpdatePluginJsonBody
from .update_plugin_response_200 import UpdatePluginResponse200
from .update_plugin_response_200_data import UpdatePluginResponse200Data
from .update_plugin_response_200_status import UpdatePluginResponse200Status
from .update_plugin_response_400 import UpdatePluginResponse400
from .update_plugin_response_400_data import UpdatePluginResponse400Data
from .update_plugin_response_400_data_code import UpdatePluginResponse400DataCode
from .update_plugin_response_400_status import UpdatePluginResponse400Status
from .update_plugin_response_401 import UpdatePluginResponse401
from .update_plugin_response_401_data import UpdatePluginResponse401Data
from .update_plugin_response_401_data_code import UpdatePluginResponse401DataCode
from .update_plugin_response_401_status import UpdatePluginResponse401Status
from .update_plugin_response_404 import UpdatePluginResponse404
from .update_plugin_response_404_data import UpdatePluginResponse404Data
from .update_plugin_response_404_data_code import UpdatePluginResponse404DataCode
from .update_plugin_response_404_data_message import UpdatePluginResponse404DataMessage
from .update_plugin_response_404_status import UpdatePluginResponse404Status
from .update_plugin_response_500 import UpdatePluginResponse500
from .update_plugin_response_500_data import UpdatePluginResponse500Data
from .update_plugin_response_500_data_code import UpdatePluginResponse500DataCode
from .update_plugin_response_500_status import UpdatePluginResponse500Status
from .update_project_multipart_data import UpdateProjectMultipartData
from .update_project_response_200 import UpdateProjectResponse200
from .update_project_response_200_data import UpdateProjectResponse200Data
from .update_project_response_200_data_type import UpdateProjectResponse200DataType
from .update_project_response_200_status import UpdateProjectResponse200Status
from .update_project_response_400 import UpdateProjectResponse400
from .update_project_response_400_data import UpdateProjectResponse400Data
from .update_project_response_400_data_code import UpdateProjectResponse400DataCode
from .update_project_response_400_status import UpdateProjectResponse400Status
from .update_project_response_401 import UpdateProjectResponse401
from .update_project_response_401_data import UpdateProjectResponse401Data
from .update_project_response_401_data_code import UpdateProjectResponse401DataCode
from .update_project_response_401_status import UpdateProjectResponse401Status
from .update_project_response_404 import UpdateProjectResponse404
from .update_project_response_404_data import UpdateProjectResponse404Data
from .update_project_response_404_data_code import UpdateProjectResponse404DataCode
from .update_project_response_404_data_message import UpdateProjectResponse404DataMessage
from .update_project_response_404_status import UpdateProjectResponse404Status
from .update_project_response_500 import UpdateProjectResponse500
from .update_project_response_500_data import UpdateProjectResponse500Data
from .update_project_response_500_data_code import UpdateProjectResponse500DataCode
from .update_project_response_500_status import UpdateProjectResponse500Status
from .update_settings_multipart_data import UpdateSettingsMultipartData
from .update_settings_multipart_data_citations_view_type import UpdateSettingsMultipartDataCitationsViewType
from .update_settings_response_200 import UpdateSettingsResponse200
from .update_settings_response_200_data import UpdateSettingsResponse200Data
from .update_settings_response_200_status import UpdateSettingsResponse200Status
from .update_settings_response_400 import UpdateSettingsResponse400
from .update_settings_response_400_data import UpdateSettingsResponse400Data
from .update_settings_response_400_data_code import UpdateSettingsResponse400DataCode
from .update_settings_response_400_data_message import UpdateSettingsResponse400DataMessage
from .update_settings_response_400_status import UpdateSettingsResponse400Status
from .update_settings_response_401 import UpdateSettingsResponse401
from .update_settings_response_401_data import UpdateSettingsResponse401Data
from .update_settings_response_401_data_code import UpdateSettingsResponse401DataCode
from .update_settings_response_401_status import UpdateSettingsResponse401Status
from .update_settings_response_500 import UpdateSettingsResponse500
from .update_settings_response_500_data import UpdateSettingsResponse500Data
from .update_settings_response_500_data_code import UpdateSettingsResponse500DataCode
from .update_settings_response_500_status import UpdateSettingsResponse500Status
from .update_user_multipart_data import UpdateUserMultipartData
from .update_user_response_200 import UpdateUserResponse200
from .update_user_response_200_data import UpdateUserResponse200Data
from .update_user_response_200_status import UpdateUserResponse200Status
from .update_user_response_401 import UpdateUserResponse401
from .update_user_response_401_data import UpdateUserResponse401Data
from .update_user_response_401_data_code import UpdateUserResponse401DataCode
from .update_user_response_401_status import UpdateUserResponse401Status
from .update_user_response_500 import UpdateUserResponse500
from .update_user_response_500_data import UpdateUserResponse500Data
from .update_user_response_500_data_code import UpdateUserResponse500DataCode
from .update_user_response_500_status import UpdateUserResponse500Status
from .user import User

__all__ = (
    "Conversation",
    "CreateConversationJsonBody",
    "CreateConversationResponse201",
    "CreateConversationResponse201Data",
    "CreateConversationResponse201Status",
    "CreateConversationResponse400",
    "CreateConversationResponse400Data",
    "CreateConversationResponse400DataCode",
    "CreateConversationResponse400Status",
    "CreateConversationResponse401",
    "CreateConversationResponse401Data",
    "CreateConversationResponse401DataCode",
    "CreateConversationResponse401Status",
    "CreateConversationResponse404",
    "CreateConversationResponse404Data",
    "CreateConversationResponse404DataCode",
    "CreateConversationResponse404DataMessage",
    "CreateConversationResponse404Status",
    "CreateConversationResponse500",
    "CreateConversationResponse500Data",
    "CreateConversationResponse500DataCode",
    "CreateConversationResponse500Status",
    "CreatePluginJsonBody",
    "CreatePluginResponse201",
    "CreatePluginResponse201Data",
    "CreatePluginResponse201Status",
    "CreatePluginResponse400",
    "CreatePluginResponse400Data",
    "CreatePluginResponse400DataCode",
    "CreatePluginResponse400Status",
    "CreatePluginResponse401",
    "CreatePluginResponse401Data",
    "CreatePluginResponse401DataCode",
    "CreatePluginResponse401Status",
    "CreatePluginResponse404",
    "CreatePluginResponse404Data",
    "CreatePluginResponse404DataCode",
    "CreatePluginResponse404DataMessage",
    "CreatePluginResponse404Status",
    "CreatePluginResponse500",
    "CreatePluginResponse500Data",
    "CreatePluginResponse500DataCode",
    "CreatePluginResponse500Status",
    "CreateProjectMultipartData",
    "CreateProjectResponse201",
    "CreateProjectResponse201Data",
    "CreateProjectResponse201DataType",
    "CreateProjectResponse201Status",
    "CreateProjectResponse400",
    "CreateProjectResponse400Data",
    "CreateProjectResponse400DataCode",
    "CreateProjectResponse400DataMessage",
    "CreateProjectResponse400Status",
    "CreateProjectResponse401",
    "CreateProjectResponse401Data",
    "CreateProjectResponse401DataCode",
    "CreateProjectResponse401Status",
    "CreateProjectResponse500",
    "CreateProjectResponse500Data",
    "CreateProjectResponse500DataCode",
    "CreateProjectResponse500Status",
    "CreateSourceMultipartData",
    "CreateSourceResponse201",
    "CreateSourceResponse201Data",
    "CreateSourceResponse201DataPagesItem",
    "CreateSourceResponse201DataPagesItemCrawlStatus",
    "CreateSourceResponse201DataPagesItemIndexStatus",
    "CreateSourceResponse201DataSettings",
    "CreateSourceResponse201DataType",
    "CreateSourceResponse201Status",
    "CreateSourceResponse400",
    "CreateSourceResponse400Data",
    "CreateSourceResponse400DataCode",
    "CreateSourceResponse400DataMessage",
    "CreateSourceResponse400Status",
    "CreateSourceResponse401",
    "CreateSourceResponse401Data",
    "CreateSourceResponse401DataCode",
    "CreateSourceResponse401Status",
    "CreateSourceResponse404",
    "CreateSourceResponse404Data",
    "CreateSourceResponse404DataCode",
    "CreateSourceResponse404DataMessage",
    "CreateSourceResponse404Status",
    "CreateSourceResponse500",
    "CreateSourceResponse500Data",
    "CreateSourceResponse500DataCode",
    "CreateSourceResponse500Status",
    "DeleteConversationResponse200",
    "DeleteConversationResponse200Data",
    "DeleteConversationResponse200Status",
    "DeleteConversationResponse400",
    "DeleteConversationResponse400Data",
    "DeleteConversationResponse400DataCode",
    "DeleteConversationResponse400Status",
    "DeleteConversationResponse401",
    "DeleteConversationResponse401Data",
    "DeleteConversationResponse401DataCode",
    "DeleteConversationResponse401Status",
    "DeleteConversationResponse404",
    "DeleteConversationResponse404Data",
    "DeleteConversationResponse404DataCode",
    "DeleteConversationResponse404DataMessage",
    "DeleteConversationResponse404Status",
    "DeleteConversationResponse500",
    "DeleteConversationResponse500Data",
    "DeleteConversationResponse500DataCode",
    "DeleteConversationResponse500Status",
    "DeletePageResponse200",
    "DeletePageResponse200Data",
    "DeletePageResponse200Status",
    "DeletePageResponse400",
    "DeletePageResponse400Data",
    "DeletePageResponse400DataCode",
    "DeletePageResponse400Status",
    "DeletePageResponse401",
    "DeletePageResponse401Data",
    "DeletePageResponse401DataCode",
    "DeletePageResponse401Status",
    "DeletePageResponse404",
    "DeletePageResponse404Data",
    "DeletePageResponse404DataCode",
    "DeletePageResponse404DataMessage",
    "DeletePageResponse404Status",
    "DeletePageResponse500",
    "DeletePageResponse500Data",
    "DeletePageResponse500DataCode",
    "DeletePageResponse500Status",
    "DeleteProjectResponse200",
    "DeleteProjectResponse200Data",
    "DeleteProjectResponse200Status",
    "DeleteProjectResponse400",
    "DeleteProjectResponse400Data",
    "DeleteProjectResponse400DataCode",
    "DeleteProjectResponse400Status",
    "DeleteProjectResponse401",
    "DeleteProjectResponse401Data",
    "DeleteProjectResponse401DataCode",
    "DeleteProjectResponse401Status",
    "DeleteProjectResponse404",
    "DeleteProjectResponse404Data",
    "DeleteProjectResponse404DataCode",
    "DeleteProjectResponse404DataMessage",
    "DeleteProjectResponse404Status",
    "DeleteProjectResponse500",
    "DeleteProjectResponse500Data",
    "DeleteProjectResponse500DataCode",
    "DeleteProjectResponse500Status",
    "DeleteSourceResponse200",
    "DeleteSourceResponse200Data",
    "DeleteSourceResponse200Status",
    "DeleteSourceResponse400",
    "DeleteSourceResponse400Data",
    "DeleteSourceResponse400DataCode",
    "DeleteSourceResponse400Status",
    "DeleteSourceResponse401",
    "DeleteSourceResponse401Data",
    "DeleteSourceResponse401DataCode",
    "DeleteSourceResponse401Status",
    "DeleteSourceResponse404",
    "DeleteSourceResponse404Data",
    "DeleteSourceResponse404DataCode",
    "DeleteSourceResponse404DataMessage",
    "DeleteSourceResponse404Status",
    "DeleteSourceResponse500",
    "DeleteSourceResponse500Data",
    "DeleteSourceResponse500DataCode",
    "DeleteSourceResponse500Status",
    "GetCitationResponse200",
    "GetCitationResponse200Data",
    "GetCitationResponse200Status",
    "GetCitationResponse400",
    "GetCitationResponse400Data",
    "GetCitationResponse400DataCode",
    "GetCitationResponse400Status",
    "GetCitationResponse401",
    "GetCitationResponse401Data",
    "GetCitationResponse401DataCode",
    "GetCitationResponse401Status",
    "GetCitationResponse404",
    "GetCitationResponse404Data",
    "GetCitationResponse404DataCode",
    "GetCitationResponse404DataMessage",
    "GetCitationResponse404Status",
    "GetConversationsOrder",
    "GetConversationsResponse200",
    "GetConversationsResponse200Data",
    "GetConversationsResponse200DataDataItem",
    "GetConversationsResponse200Status",
    "GetConversationsResponse400",
    "GetConversationsResponse400Data",
    "GetConversationsResponse400DataCode",
    "GetConversationsResponse400Status",
    "GetConversationsResponse401",
    "GetConversationsResponse401Data",
    "GetConversationsResponse401DataCode",
    "GetConversationsResponse401Status",
    "GetConversationsResponse404",
    "GetConversationsResponse404Data",
    "GetConversationsResponse404DataCode",
    "GetConversationsResponse404DataMessage",
    "GetConversationsResponse404Status",
    "GetConversationsResponse500",
    "GetConversationsResponse500Data",
    "GetConversationsResponse500DataCode",
    "GetConversationsResponse500Status",
    "GetConversationsUserFilter",
    "GetPageMetadataResponse200",
    "GetPageMetadataResponse200Data",
    "GetPageMetadataResponse200Status",
    "GetPageMetadataResponse400",
    "GetPageMetadataResponse400Data",
    "GetPageMetadataResponse400DataCode",
    "GetPageMetadataResponse400Status",
    "GetPageMetadataResponse401",
    "GetPageMetadataResponse401Data",
    "GetPageMetadataResponse401DataCode",
    "GetPageMetadataResponse401Status",
    "GetPageMetadataResponse404",
    "GetPageMetadataResponse404Data",
    "GetPageMetadataResponse404DataCode",
    "GetPageMetadataResponse404DataMessage",
    "GetPageMetadataResponse404Status",
    "GetPagesOrder",
    "GetPagesResponse200",
    "GetPagesResponse200Data",
    "GetPagesResponse200DataPages",
    "GetPagesResponse200DataPagesDataItem",
    "GetPagesResponse200DataPagesDataItemCrawlStatus",
    "GetPagesResponse200DataPagesDataItemIndexStatus",
    "GetPagesResponse200DataProject",
    "GetPagesResponse200DataProjectType",
    "GetPagesResponse200Status",
    "GetPagesResponse400",
    "GetPagesResponse400Data",
    "GetPagesResponse400DataCode",
    "GetPagesResponse400Status",
    "GetPagesResponse401",
    "GetPagesResponse401Data",
    "GetPagesResponse401DataCode",
    "GetPagesResponse401Status",
    "GetPagesResponse404",
    "GetPagesResponse404Data",
    "GetPagesResponse404DataCode",
    "GetPagesResponse404DataMessage",
    "GetPagesResponse404Status",
    "GetPagesResponse500",
    "GetPagesResponse500Data",
    "GetPagesResponse500DataCode",
    "GetPagesResponse500Status",
    "GetPluginResponse200",
    "GetPluginResponse200Data",
    "GetPluginResponse200Status",
    "GetPluginResponse400",
    "GetPluginResponse400Data",
    "GetPluginResponse400DataCode",
    "GetPluginResponse400Status",
    "GetPluginResponse401",
    "GetPluginResponse401Data",
    "GetPluginResponse401DataCode",
    "GetPluginResponse401Status",
    "GetPluginResponse404",
    "GetPluginResponse404Data",
    "GetPluginResponse404DataCode",
    "GetPluginResponse404DataMessage",
    "GetPluginResponse404Status",
    "GetPluginResponse500",
    "GetPluginResponse500Data",
    "GetPluginResponse500DataCode",
    "GetPluginResponse500Status",
    "GetProjectResponse200",
    "GetProjectResponse200Data",
    "GetProjectResponse200DataType",
    "GetProjectResponse200Status",
    "GetProjectResponse400",
    "GetProjectResponse400Data",
    "GetProjectResponse400DataCode",
    "GetProjectResponse400Status",
    "GetProjectResponse401",
    "GetProjectResponse401Data",
    "GetProjectResponse401DataCode",
    "GetProjectResponse401Status",
    "GetProjectResponse404",
    "GetProjectResponse404Data",
    "GetProjectResponse404DataCode",
    "GetProjectResponse404DataMessage",
    "GetProjectResponse404Status",
    "GetProjectResponse500",
    "GetProjectResponse500Data",
    "GetProjectResponse500DataCode",
    "GetProjectResponse500Status",
    "GetSettingsResponse200",
    "GetSettingsResponse200Data",
    "GetSettingsResponse200DataCitationsViewType",
    "GetSettingsResponse200Status",
    "GetSettingsResponse400",
    "GetSettingsResponse400Data",
    "GetSettingsResponse400DataCode",
    "GetSettingsResponse400Status",
    "GetSettingsResponse401",
    "GetSettingsResponse401Data",
    "GetSettingsResponse401DataCode",
    "GetSettingsResponse401Status",
    "GetSettingsResponse404",
    "GetSettingsResponse404Data",
    "GetSettingsResponse404DataCode",
    "GetSettingsResponse404DataMessage",
    "GetSettingsResponse404Status",
    "GetSettingsResponse500",
    "GetSettingsResponse500Data",
    "GetSettingsResponse500DataCode",
    "GetSettingsResponse500Status",
    "GetUserResponse200",
    "GetUserResponse200Data",
    "GetUserResponse200Status",
    "GetUserResponse401",
    "GetUserResponse401Data",
    "GetUserResponse401DataCode",
    "GetUserResponse401Status",
    "GetUserResponse500",
    "GetUserResponse500Data",
    "GetUserResponse500DataCode",
    "GetUserResponse500Status",
    "ListProjectsOrder",
    "ListProjectsResponse200",
    "ListProjectsResponse200Data",
    "ListProjectsResponse200DataDataItem",
    "ListProjectsResponse200DataDataItemType",
    "ListProjectsResponse200Status",
    "ListProjectsResponse401",
    "ListProjectsResponse401Data",
    "ListProjectsResponse401DataCode",
    "ListProjectsResponse401Status",
    "ListProjectsResponse500",
    "ListProjectsResponse500Data",
    "ListProjectsResponse500DataCode",
    "ListProjectsResponse500Status",
    "ListSourcesResponse200",
    "ListSourcesResponse200Data",
    "ListSourcesResponse200DataSitemapsItem",
    "ListSourcesResponse200DataSitemapsItemPagesItem",
    "ListSourcesResponse200DataSitemapsItemPagesItemCrawlStatus",
    "ListSourcesResponse200DataSitemapsItemPagesItemIndexStatus",
    "ListSourcesResponse200DataSitemapsItemSettings",
    "ListSourcesResponse200DataSitemapsItemType",
    "ListSourcesResponse200DataUploads",
    "ListSourcesResponse200DataUploadsPagesItem",
    "ListSourcesResponse200DataUploadsPagesItemCrawlStatus",
    "ListSourcesResponse200DataUploadsPagesItemIndexStatus",
    "ListSourcesResponse200DataUploadsSettings",
    "ListSourcesResponse200DataUploadsType",
    "ListSourcesResponse200Status",
    "ListSourcesResponse400",
    "ListSourcesResponse400Data",
    "ListSourcesResponse400DataCode",
    "ListSourcesResponse400Status",
    "ListSourcesResponse401",
    "ListSourcesResponse401Data",
    "ListSourcesResponse401DataCode",
    "ListSourcesResponse401Status",
    "ListSourcesResponse404",
    "ListSourcesResponse404Data",
    "ListSourcesResponse404DataCode",
    "ListSourcesResponse404DataMessage",
    "ListSourcesResponse404Status",
    "ListSourcesResponse500",
    "ListSourcesResponse500Data",
    "ListSourcesResponse500DataCode",
    "ListSourcesResponse500Status",
    "MessagesConversationOrder",
    "MessagesConversationResponse200",
    "MessagesConversationResponse200Data",
    "MessagesConversationResponse200DataConversation",
    "MessagesConversationResponse200DataMessages",
    "MessagesConversationResponse200DataMessagesDataItem",
    "MessagesConversationResponse200DataMessagesDataItemMetadata",
    "MessagesConversationResponse200Status",
    "MessagesConversationResponse400",
    "MessagesConversationResponse400Data",
    "MessagesConversationResponse400DataCode",
    "MessagesConversationResponse400Status",
    "MessagesConversationResponse401",
    "MessagesConversationResponse401Data",
    "MessagesConversationResponse401DataCode",
    "MessagesConversationResponse401Status",
    "MessagesConversationResponse404",
    "MessagesConversationResponse404Data",
    "MessagesConversationResponse404DataCode",
    "MessagesConversationResponse404DataMessage",
    "MessagesConversationResponse404Status",
    "MessagesConversationResponse500",
    "MessagesConversationResponse500Data",
    "MessagesConversationResponse500DataCode",
    "MessagesConversationResponse500Status",
    "OpenGraphCache",
    "Page",
    "PageCrawlStatus",
    "PageIndexStatus",
    "PageMetadata",
    "PreviewCitationResponse400",
    "PreviewCitationResponse400Data",
    "PreviewCitationResponse400DataCode",
    "PreviewCitationResponse400Status",
    "PreviewCitationResponse401",
    "PreviewCitationResponse401Data",
    "PreviewCitationResponse401DataCode",
    "PreviewCitationResponse401Status",
    "PreviewCitationResponse404",
    "PreviewCitationResponse404Data",
    "PreviewCitationResponse404DataCode",
    "PreviewCitationResponse404DataMessage",
    "PreviewCitationResponse404Status",
    "PreviewCitationResponse500",
    "PreviewCitationResponse500Data",
    "PreviewCitationResponse500DataCode",
    "PreviewCitationResponse500Status",
    "Project",
    "ProjectPlugin",
    "ProjectSettings",
    "ProjectSettingsCitationsViewType",
    "ProjectSettingsResponseSource",
    "ProjectSource",
    "ProjectSourceSettings",
    "ProjectSourceType",
    "ProjectType",
    "PromptHistory",
    "PromptHistoryMetadata",
    "ReindexPageResponse200",
    "ReindexPageResponse200Data",
    "ReindexPageResponse200Status",
    "ReindexPageResponse400",
    "ReindexPageResponse400Data",
    "ReindexPageResponse400DataCode",
    "ReindexPageResponse400Status",
    "ReindexPageResponse401",
    "ReindexPageResponse401Data",
    "ReindexPageResponse401DataCode",
    "ReindexPageResponse401Status",
    "ReindexPageResponse403",
    "ReindexPageResponse403Data",
    "ReindexPageResponse403DataCode",
    "ReindexPageResponse403DataMessage",
    "ReindexPageResponse403Status",
    "ReindexPageResponse500",
    "ReindexPageResponse500Data",
    "ReindexPageResponse500DataCode",
    "ReindexPageResponse500Status",
    "SendMessageJsonBody",
    "SendMessageResponse200",
    "SendMessageResponse200Data",
    "SendMessageResponse200DataMetadata",
    "SendMessageResponse200Status",
    "SendMessageResponse400",
    "SendMessageResponse400Data",
    "SendMessageResponse400DataCode",
    "SendMessageResponse400Status",
    "SendMessageResponse401",
    "SendMessageResponse401Data",
    "SendMessageResponse401DataCode",
    "SendMessageResponse401Status",
    "SendMessageResponse404",
    "SendMessageResponse404Data",
    "SendMessageResponse404DataCode",
    "SendMessageResponse404DataMessage",
    "SendMessageResponse404Status",
    "SendMessageResponse500",
    "SendMessageResponse500Data",
    "SendMessageResponse500DataCode",
    "SendMessageResponse500Status",
    "StatsProjectResponse200",
    "StatsProjectResponse200Data",
    "StatsProjectResponse200Status",
    "StatsProjectResponse400",
    "StatsProjectResponse400Data",
    "StatsProjectResponse400DataCode",
    "StatsProjectResponse400Status",
    "StatsProjectResponse401",
    "StatsProjectResponse401Data",
    "StatsProjectResponse401DataCode",
    "StatsProjectResponse401Status",
    "StatsProjectResponse404",
    "StatsProjectResponse404Data",
    "StatsProjectResponse404DataCode",
    "StatsProjectResponse404DataMessage",
    "StatsProjectResponse404Status",
    "StatsProjectResponse500",
    "StatsProjectResponse500Data",
    "StatsProjectResponse500DataCode",
    "StatsProjectResponse500Status",
    "UpdateConversationJsonBody",
    "UpdateConversationResponse200",
    "UpdateConversationResponse200Data",
    "UpdateConversationResponse200Status",
    "UpdateConversationResponse400",
    "UpdateConversationResponse400Data",
    "UpdateConversationResponse400DataCode",
    "UpdateConversationResponse400Status",
    "UpdateConversationResponse401",
    "UpdateConversationResponse401Data",
    "UpdateConversationResponse401DataCode",
    "UpdateConversationResponse401Status",
    "UpdateConversationResponse404",
    "UpdateConversationResponse404Data",
    "UpdateConversationResponse404DataCode",
    "UpdateConversationResponse404DataMessage",
    "UpdateConversationResponse404Status",
    "UpdateConversationResponse500",
    "UpdateConversationResponse500Data",
    "UpdateConversationResponse500DataCode",
    "UpdateConversationResponse500Status",
    "UpdatePageMetadataJsonBody",
    "UpdatePageMetadataResponse200",
    "UpdatePageMetadataResponse200Data",
    "UpdatePageMetadataResponse200Status",
    "UpdatePageMetadataResponse400",
    "UpdatePageMetadataResponse400Data",
    "UpdatePageMetadataResponse400DataCode",
    "UpdatePageMetadataResponse400Status",
    "UpdatePageMetadataResponse401",
    "UpdatePageMetadataResponse401Data",
    "UpdatePageMetadataResponse401DataCode",
    "UpdatePageMetadataResponse401Status",
    "UpdatePageMetadataResponse404",
    "UpdatePageMetadataResponse404Data",
    "UpdatePageMetadataResponse404DataCode",
    "UpdatePageMetadataResponse404DataMessage",
    "UpdatePageMetadataResponse404Status",
    "UpdatePageMetadataResponse500",
    "UpdatePageMetadataResponse500Data",
    "UpdatePageMetadataResponse500DataCode",
    "UpdatePageMetadataResponse500Status",
    "UpdatePluginJsonBody",
    "UpdatePluginResponse200",
    "UpdatePluginResponse200Data",
    "UpdatePluginResponse200Status",
    "UpdatePluginResponse400",
    "UpdatePluginResponse400Data",
    "UpdatePluginResponse400DataCode",
    "UpdatePluginResponse400Status",
    "UpdatePluginResponse401",
    "UpdatePluginResponse401Data",
    "UpdatePluginResponse401DataCode",
    "UpdatePluginResponse401Status",
    "UpdatePluginResponse404",
    "UpdatePluginResponse404Data",
    "UpdatePluginResponse404DataCode",
    "UpdatePluginResponse404DataMessage",
    "UpdatePluginResponse404Status",
    "UpdatePluginResponse500",
    "UpdatePluginResponse500Data",
    "UpdatePluginResponse500DataCode",
    "UpdatePluginResponse500Status",
    "UpdateProjectMultipartData",
    "UpdateProjectResponse200",
    "UpdateProjectResponse200Data",
    "UpdateProjectResponse200DataType",
    "UpdateProjectResponse200Status",
    "UpdateProjectResponse400",
    "UpdateProjectResponse400Data",
    "UpdateProjectResponse400DataCode",
    "UpdateProjectResponse400Status",
    "UpdateProjectResponse401",
    "UpdateProjectResponse401Data",
    "UpdateProjectResponse401DataCode",
    "UpdateProjectResponse401Status",
    "UpdateProjectResponse404",
    "UpdateProjectResponse404Data",
    "UpdateProjectResponse404DataCode",
    "UpdateProjectResponse404DataMessage",
    "UpdateProjectResponse404Status",
    "UpdateProjectResponse500",
    "UpdateProjectResponse500Data",
    "UpdateProjectResponse500DataCode",
    "UpdateProjectResponse500Status",
    "UpdateSettingsMultipartData",
    "UpdateSettingsMultipartDataCitationsViewType",
    "UpdateSettingsResponse200",
    "UpdateSettingsResponse200Data",
    "UpdateSettingsResponse200Status",
    "UpdateSettingsResponse400",
    "UpdateSettingsResponse400Data",
    "UpdateSettingsResponse400DataCode",
    "UpdateSettingsResponse400DataMessage",
    "UpdateSettingsResponse400Status",
    "UpdateSettingsResponse401",
    "UpdateSettingsResponse401Data",
    "UpdateSettingsResponse401DataCode",
    "UpdateSettingsResponse401Status",
    "UpdateSettingsResponse500",
    "UpdateSettingsResponse500Data",
    "UpdateSettingsResponse500DataCode",
    "UpdateSettingsResponse500Status",
    "UpdateUserMultipartData",
    "UpdateUserResponse200",
    "UpdateUserResponse200Data",
    "UpdateUserResponse200Status",
    "UpdateUserResponse401",
    "UpdateUserResponse401Data",
    "UpdateUserResponse401DataCode",
    "UpdateUserResponse401Status",
    "UpdateUserResponse500",
    "UpdateUserResponse500Data",
    "UpdateUserResponse500DataCode",
    "UpdateUserResponse500Status",
    "User",
)

```

Contents of customgpt-client/customgpt_client/models/conversation.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="Conversation")


@attr.s(auto_attribs=True)
class Conversation:
    """
    Attributes:
        created_at (Union[Unset, datetime.datetime]): When was this conversation created? Example: 2023-04-30 16:43:53.
        updated_at (Union[Unset, datetime.datetime]): When was this conversation updated? Example: 2023-04-30 16:43:53.
        deleted_at (Union[Unset, datetime.datetime]): When was this conversation deleted? Example: 2023-04-30 16:43:53.
        id (Union[Unset, int]): Conversation ID Example: 1.
        name (Union[Unset, str]): Conversation name Example: Conversation 1.
        project_id (Union[Unset, str]): Project ID for this conversation Example: 1.
        created_by (Union[Unset, str]): User ID for the user who created this conversation Example: 1.
        session_id (Union[Unset, str]): Session ID for this conversation Example: f1b9aaf0-5e4e-11eb-ae93-0242ac130002.
    """

    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    deleted_at: Union[Unset, datetime.datetime] = UNSET
    id: Union[Unset, int] = UNSET
    name: Union[Unset, str] = UNSET
    project_id: Union[Unset, str] = UNSET
    created_by: Union[Unset, str] = UNSET
    session_id: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat()

        id = self.id
        name = self.name
        project_id = self.project_id
        created_by = self.created_by
        session_id = self.session_id

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at
        if id is not UNSET:
            field_dict["id"] = id
        if name is not UNSET:
            field_dict["name"] = name
        if project_id is not UNSET:
            field_dict["project_id"] = project_id
        if created_by is not UNSET:
            field_dict["created_by"] = created_by
        if session_id is not UNSET:
            field_dict["session_id"] = session_id

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, datetime.datetime]
        if isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        id = src_dict.get("id")

        name = src_dict.get("name")

        project_id = src_dict.get("project_id")

        created_by = src_dict.get("created_by")

        session_id = src_dict.get("session_id")

        conversation = cls(
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
            id=id,
            name=name,
            project_id=project_id,
            created_by=created_by,
            session_id=session_id,
        )

        conversation.additional_properties = src_dict
        return conversation

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_conversation_json_body.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateConversationJsonBody")


@attr.s(auto_attribs=True)
class CreateConversationJsonBody:
    """
    Attributes:
        name (Union[Unset, str]): Conversation name Example: My conversation.
    """

    name: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        name = self.name

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if name is not UNSET:
            field_dict["name"] = name

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        name = src_dict.get("name")

        create_conversation_json_body = cls(
            name=name,
        )

        create_conversation_json_body.additional_properties = src_dict
        return create_conversation_json_body

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_201.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_conversation_response_201_data import CreateConversationResponse201Data


T = TypeVar("T", bound="CreateConversationResponse201")


@attr.s(auto_attribs=True)
class CreateConversationResponse201:
    """
    Attributes:
        status (Union[Unset, CreateConversationResponse201Status]): The status of the response Example: success.
        data (Union[Unset, CreateConversationResponse201Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "CreateConversationResponse201Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_conversation_response_201_data import CreateConversationResponse201Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, CreateConversationResponse201Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateConversationResponse201Data.from_dict(_data)

        create_conversation_response_201 = cls(
            status=status,
            data=data,
        )

        create_conversation_response_201.additional_properties = src_dict
        return create_conversation_response_201

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_201_data.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateConversationResponse201Data")


@attr.s(auto_attribs=True)
class CreateConversationResponse201Data:
    """
    Attributes:
        created_at (Union[Unset, datetime.datetime]): When was this conversation created? Example: 2023-04-30 16:43:53.
        updated_at (Union[Unset, datetime.datetime]): When was this conversation updated? Example: 2023-04-30 16:43:53.
        deleted_at (Union[Unset, None, datetime.datetime]): When was this conversation deleted? Example: 2023-04-30
            16:43:53.
        id (Union[Unset, int]): Conversation ID Example: 1.
        name (Union[Unset, str]): Conversation name Example: Conversation 1.
        project_id (Union[Unset, str]): Project ID for this conversation Example: 1.
        created_by (Union[Unset, str]): User ID for the user who created this conversation Example: 1.
        session_id (Union[Unset, str]): Session ID for this conversation Example: f1b9aaf0-5e4e-11eb-ae93-0242ac130002.
    """

    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    id: Union[Unset, int] = UNSET
    name: Union[Unset, str] = UNSET
    project_id: Union[Unset, str] = UNSET
    created_by: Union[Unset, str] = UNSET
    session_id: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        id = self.id
        name = self.name
        project_id = self.project_id
        created_by = self.created_by
        session_id = self.session_id

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at
        if id is not UNSET:
            field_dict["id"] = id
        if name is not UNSET:
            field_dict["name"] = name
        if project_id is not UNSET:
            field_dict["project_id"] = project_id
        if created_by is not UNSET:
            field_dict["created_by"] = created_by
        if session_id is not UNSET:
            field_dict["session_id"] = session_id

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        id = src_dict.get("id")

        name = src_dict.get("name")

        project_id = src_dict.get("project_id")

        created_by = src_dict.get("created_by")

        session_id = src_dict.get("session_id")

        create_conversation_response_201_data = cls(
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
            id=id,
            name=name,
            project_id=project_id,
            created_by=created_by,
            session_id=session_id,
        )

        create_conversation_response_201_data.additional_properties = src_dict
        return create_conversation_response_201_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_201_status.py:
```
from enum import Enum


class CreateConversationResponse201Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_conversation_response_400_data import CreateConversationResponse400Data


T = TypeVar("T", bound="CreateConversationResponse400")


@attr.s(auto_attribs=True)
class CreateConversationResponse400:
    """
    Attributes:
        status (Union[Unset, CreateConversationResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreateConversationResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreateConversationResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_conversation_response_400_data import CreateConversationResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreateConversationResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateConversationResponse400Data.from_dict(_data)

        create_conversation_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_conversation_response_400.additional_properties = src_dict
        return create_conversation_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateConversationResponse400Data")


@attr.s(auto_attribs=True)
class CreateConversationResponse400Data:
    """
    Attributes:
        code (Union[Unset, CreateConversationResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_conversation_response_400_data = cls(
            code=code,
            message=message,
        )

        create_conversation_response_400_data.additional_properties = src_dict
        return create_conversation_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_400_data_code.py:
```
from enum import IntEnum


class CreateConversationResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_400_status.py:
```
from enum import Enum


class CreateConversationResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_conversation_response_401_data import CreateConversationResponse401Data


T = TypeVar("T", bound="CreateConversationResponse401")


@attr.s(auto_attribs=True)
class CreateConversationResponse401:
    """
    Attributes:
        status (Union[Unset, CreateConversationResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreateConversationResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreateConversationResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_conversation_response_401_data import CreateConversationResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreateConversationResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateConversationResponse401Data.from_dict(_data)

        create_conversation_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_conversation_response_401.additional_properties = src_dict
        return create_conversation_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateConversationResponse401Data")


@attr.s(auto_attribs=True)
class CreateConversationResponse401Data:
    """
    Attributes:
        code (Union[Unset, CreateConversationResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_conversation_response_401_data = cls(
            code=code,
            message=message,
        )

        create_conversation_response_401_data.additional_properties = src_dict
        return create_conversation_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_401_data_code.py:
```
from enum import IntEnum


class CreateConversationResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_401_status.py:
```
from enum import Enum


class CreateConversationResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_conversation_response_404_data import CreateConversationResponse404Data


T = TypeVar("T", bound="CreateConversationResponse404")


@attr.s(auto_attribs=True)
class CreateConversationResponse404:
    """
    Attributes:
        status (Union[Unset, CreateConversationResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreateConversationResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreateConversationResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_conversation_response_404_data import CreateConversationResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreateConversationResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateConversationResponse404Data.from_dict(_data)

        create_conversation_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_conversation_response_404.additional_properties = src_dict
        return create_conversation_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateConversationResponse404Data")


@attr.s(auto_attribs=True)
class CreateConversationResponse404Data:
    """
    Attributes:
        code (Union[Unset, CreateConversationResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, CreateConversationResponse404DataMessage]): The error message Example: Project with id 1
            not found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_conversation_response_404_data = cls(
            code=code,
            message=message,
        )

        create_conversation_response_404_data.additional_properties = src_dict
        return create_conversation_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_404_data_code.py:
```
from enum import IntEnum


class CreateConversationResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_404_data_message.py:
```
from enum import Enum


class CreateConversationResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_404_status.py:
```
from enum import Enum


class CreateConversationResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_conversation_response_500_data import CreateConversationResponse500Data


T = TypeVar("T", bound="CreateConversationResponse500")


@attr.s(auto_attribs=True)
class CreateConversationResponse500:
    """
    Attributes:
        status (Union[Unset, CreateConversationResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreateConversationResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreateConversationResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_conversation_response_500_data import CreateConversationResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreateConversationResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateConversationResponse500Data.from_dict(_data)

        create_conversation_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_conversation_response_500.additional_properties = src_dict
        return create_conversation_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateConversationResponse500Data")


@attr.s(auto_attribs=True)
class CreateConversationResponse500Data:
    """
    Attributes:
        code (Union[Unset, CreateConversationResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_conversation_response_500_data = cls(
            code=code,
            message=message,
        )

        create_conversation_response_500_data.additional_properties = src_dict
        return create_conversation_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_500_data_code.py:
```
from enum import IntEnum


class CreateConversationResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_conversation_response_500_status.py:
```
from enum import Enum


class CreateConversationResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_plugin_json_body.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreatePluginJsonBody")


@attr.s(auto_attribs=True)
class CreatePluginJsonBody:
    """
    Attributes:
        model_name (Union[Unset, str]): Model Name Example: IndoorPlants.
        human_name (Union[Unset, str]): Name For Human Example: The Indoor Plants Channel.
        keywords (Union[Unset, str]): Keywords For Model Example: Indoor plants, Gardening, Trusted information..
        description (Union[Unset, str]): Description For Human Example: Trusted information about indoor plants and
            gardening..
        is_active (Union[Unset, bool]): Whether the project plugin is active or not Example: True.
    """

    model_name: Union[Unset, str] = UNSET
    human_name: Union[Unset, str] = UNSET
    keywords: Union[Unset, str] = UNSET
    description: Union[Unset, str] = UNSET
    is_active: Union[Unset, bool] = False
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        model_name = self.model_name
        human_name = self.human_name
        keywords = self.keywords
        description = self.description
        is_active = self.is_active

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if model_name is not UNSET:
            field_dict["model_name"] = model_name
        if human_name is not UNSET:
            field_dict["human_name"] = human_name
        if keywords is not UNSET:
            field_dict["keywords"] = keywords
        if description is not UNSET:
            field_dict["description"] = description
        if is_active is not UNSET:
            field_dict["is_active"] = is_active

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        model_name = src_dict.get("model_name")

        human_name = src_dict.get("human_name")

        keywords = src_dict.get("keywords")

        description = src_dict.get("description")

        is_active = src_dict.get("is_active")

        create_plugin_json_body = cls(
            model_name=model_name,
            human_name=human_name,
            keywords=keywords,
            description=description,
            is_active=is_active,
        )

        create_plugin_json_body.additional_properties = src_dict
        return create_plugin_json_body

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_201.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_plugin_response_201_data import CreatePluginResponse201Data


T = TypeVar("T", bound="CreatePluginResponse201")


@attr.s(auto_attribs=True)
class CreatePluginResponse201:
    """
    Attributes:
        status (Union[Unset, CreatePluginResponse201Status]): The status of the response Example: success.
        data (Union[Unset, CreatePluginResponse201Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "CreatePluginResponse201Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_plugin_response_201_data import CreatePluginResponse201Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, CreatePluginResponse201Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreatePluginResponse201Data.from_dict(_data)

        create_plugin_response_201 = cls(
            status=status,
            data=data,
        )

        create_plugin_response_201.additional_properties = src_dict
        return create_plugin_response_201

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_201_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreatePluginResponse201Data")


@attr.s(auto_attribs=True)
class CreatePluginResponse201Data:
    """
    Attributes:
        model_name (Union[Unset, str]): Model Name Example: IndoorPlants.
        human_name (Union[Unset, str]): Name For Human Example: The Indoor Plants Channel.
        keywords (Union[Unset, str]): Keywords For Model Example: Indoor plants, Gardening, Trusted information..
        description (Union[Unset, str]): Description For Human Example: Trusted information about indoor plants and
            gardening..
        logo (Union[Unset, str]): Project plugin logo Example: https://app.customgpt.ai/logo.svg.
        is_active (Union[Unset, bool]): Whether the project plugin is active or not Example: True.
    """

    model_name: Union[Unset, str] = UNSET
    human_name: Union[Unset, str] = UNSET
    keywords: Union[Unset, str] = UNSET
    description: Union[Unset, str] = UNSET
    logo: Union[Unset, str] = UNSET
    is_active: Union[Unset, bool] = False
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        model_name = self.model_name
        human_name = self.human_name
        keywords = self.keywords
        description = self.description
        logo = self.logo
        is_active = self.is_active

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if model_name is not UNSET:
            field_dict["model_name"] = model_name
        if human_name is not UNSET:
            field_dict["human_name"] = human_name
        if keywords is not UNSET:
            field_dict["keywords"] = keywords
        if description is not UNSET:
            field_dict["description"] = description
        if logo is not UNSET:
            field_dict["logo"] = logo
        if is_active is not UNSET:
            field_dict["is_active"] = is_active

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        model_name = src_dict.get("model_name")

        human_name = src_dict.get("human_name")

        keywords = src_dict.get("keywords")

        description = src_dict.get("description")

        logo = src_dict.get("logo")

        is_active = src_dict.get("is_active")

        create_plugin_response_201_data = cls(
            model_name=model_name,
            human_name=human_name,
            keywords=keywords,
            description=description,
            logo=logo,
            is_active=is_active,
        )

        create_plugin_response_201_data.additional_properties = src_dict
        return create_plugin_response_201_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_201_status.py:
```
from enum import Enum


class CreatePluginResponse201Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_plugin_response_400_data import CreatePluginResponse400Data


T = TypeVar("T", bound="CreatePluginResponse400")


@attr.s(auto_attribs=True)
class CreatePluginResponse400:
    """
    Attributes:
        status (Union[Unset, CreatePluginResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreatePluginResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreatePluginResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_plugin_response_400_data import CreatePluginResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreatePluginResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreatePluginResponse400Data.from_dict(_data)

        create_plugin_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_plugin_response_400.additional_properties = src_dict
        return create_plugin_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreatePluginResponse400Data")


@attr.s(auto_attribs=True)
class CreatePluginResponse400Data:
    """
    Attributes:
        code (Union[Unset, CreatePluginResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_plugin_response_400_data = cls(
            code=code,
            message=message,
        )

        create_plugin_response_400_data.additional_properties = src_dict
        return create_plugin_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_400_data_code.py:
```
from enum import IntEnum


class CreatePluginResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_400_status.py:
```
from enum import Enum


class CreatePluginResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_plugin_response_401_data import CreatePluginResponse401Data


T = TypeVar("T", bound="CreatePluginResponse401")


@attr.s(auto_attribs=True)
class CreatePluginResponse401:
    """
    Attributes:
        status (Union[Unset, CreatePluginResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreatePluginResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreatePluginResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_plugin_response_401_data import CreatePluginResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreatePluginResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreatePluginResponse401Data.from_dict(_data)

        create_plugin_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_plugin_response_401.additional_properties = src_dict
        return create_plugin_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreatePluginResponse401Data")


@attr.s(auto_attribs=True)
class CreatePluginResponse401Data:
    """
    Attributes:
        code (Union[Unset, CreatePluginResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_plugin_response_401_data = cls(
            code=code,
            message=message,
        )

        create_plugin_response_401_data.additional_properties = src_dict
        return create_plugin_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_401_data_code.py:
```
from enum import IntEnum


class CreatePluginResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_401_status.py:
```
from enum import Enum


class CreatePluginResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_plugin_response_404_data import CreatePluginResponse404Data


T = TypeVar("T", bound="CreatePluginResponse404")


@attr.s(auto_attribs=True)
class CreatePluginResponse404:
    """
    Attributes:
        status (Union[Unset, CreatePluginResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreatePluginResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreatePluginResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_plugin_response_404_data import CreatePluginResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreatePluginResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreatePluginResponse404Data.from_dict(_data)

        create_plugin_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_plugin_response_404.additional_properties = src_dict
        return create_plugin_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreatePluginResponse404Data")


@attr.s(auto_attribs=True)
class CreatePluginResponse404Data:
    """
    Attributes:
        code (Union[Unset, CreatePluginResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, CreatePluginResponse404DataMessage]): The error message Example: Project with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_plugin_response_404_data = cls(
            code=code,
            message=message,
        )

        create_plugin_response_404_data.additional_properties = src_dict
        return create_plugin_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_404_data_code.py:
```
from enum import IntEnum


class CreatePluginResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_404_data_message.py:
```
from enum import Enum


class CreatePluginResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_404_status.py:
```
from enum import Enum


class CreatePluginResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_plugin_response_500_data import CreatePluginResponse500Data


T = TypeVar("T", bound="CreatePluginResponse500")


@attr.s(auto_attribs=True)
class CreatePluginResponse500:
    """
    Attributes:
        status (Union[Unset, CreatePluginResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreatePluginResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreatePluginResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_plugin_response_500_data import CreatePluginResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreatePluginResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreatePluginResponse500Data.from_dict(_data)

        create_plugin_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_plugin_response_500.additional_properties = src_dict
        return create_plugin_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreatePluginResponse500Data")


@attr.s(auto_attribs=True)
class CreatePluginResponse500Data:
    """
    Attributes:
        code (Union[Unset, CreatePluginResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_plugin_response_500_data = cls(
            code=code,
            message=message,
        )

        create_plugin_response_500_data.additional_properties = src_dict
        return create_plugin_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_500_data_code.py:
```
from enum import IntEnum


class CreatePluginResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_plugin_response_500_status.py:
```
from enum import Enum


class CreatePluginResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_project_multipart_data.py:
```
from io import BytesIO
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, File, FileJsonType, Unset

T = TypeVar("T", bound="CreateProjectMultipartData")


@attr.s(auto_attribs=True)
class CreateProjectMultipartData:
    """
    Attributes:
        project_name (Union[Unset, str]): Project name Example: My project.
        sitemap_path (Union[Unset, str]): The sitemap path Example: https://example.com/sitemap.xml.
        file_data_retension (Union[Unset, bool]): File data retension Example: True.
        file (Union[Unset, File]): The submitted file. Example: file.pdf.
    """

    project_name: Union[Unset, str] = UNSET
    sitemap_path: Union[Unset, str] = UNSET
    file_data_retension: Union[Unset, bool] = UNSET
    file: Union[Unset, File] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        project_name = self.project_name
        sitemap_path = self.sitemap_path
        file_data_retension = self.file_data_retension
        file: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.file, Unset):
            file = self.file.to_tuple()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if project_name is not UNSET:
            field_dict["project_name"] = project_name
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path
        if file_data_retension is not UNSET:
            field_dict["file_data_retension"] = file_data_retension
        if file is not UNSET:
            field_dict["file"] = file

        return field_dict

    def to_multipart(self) -> Dict[str, Any]:
        project_name = (
            self.project_name
            if isinstance(self.project_name, Unset)
            else (None, str(self.project_name).encode(), "text/plain")
        )
        sitemap_path = (
            self.sitemap_path
            if isinstance(self.sitemap_path, Unset)
            else (None, str(self.sitemap_path).encode(), "text/plain")
        )
        file_data_retension = (
            self.file_data_retension
            if isinstance(self.file_data_retension, Unset)
            else (None, str(self.file_data_retension).lower().encode(), "text/plain")
        )
        file: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.file, Unset):
            file = self.file.to_tuple()

        field_dict: Dict[str, Any] = {}
        field_dict.update(
            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
        )
        field_dict.update({})
        if project_name is not UNSET:
            field_dict["project_name"] = project_name
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path
        if file_data_retension is not UNSET:
            field_dict["file_data_retension"] = file_data_retension
        if file is not UNSET:
            field_dict["file"] = file

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        project_name = src_dict.get("project_name")

        sitemap_path = src_dict.get("sitemap_path")

        file_data_retension = src_dict.get("file_data_retension")

        _file = src_dict.get("file")
        file: Union[Unset, File]
        if isinstance(_file, Unset):
            file = UNSET
        else:
            file = File(payload=BytesIO(_file))

        create_project_multipart_data = cls(
            project_name=project_name,
            sitemap_path=sitemap_path,
            file_data_retension=file_data_retension,
            file=file,
        )

        create_project_multipart_data.additional_properties = src_dict
        return create_project_multipart_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_project_response_201.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_project_response_201_data import CreateProjectResponse201Data


T = TypeVar("T", bound="CreateProjectResponse201")


@attr.s(auto_attribs=True)
class CreateProjectResponse201:
    """
    Attributes:
        status (Union[Unset, CreateProjectResponse201Status]): The status of the response Example: success.
        data (Union[Unset, CreateProjectResponse201Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "CreateProjectResponse201Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_project_response_201_data import CreateProjectResponse201Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, CreateProjectResponse201Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateProjectResponse201Data.from_dict(_data)

        create_project_response_201 = cls(
            status=status,
            data=data,
        )

        create_project_response_201.additional_properties = src_dict
        return create_project_response_201

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_project_response_201_data.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateProjectResponse201Data")


@attr.s(auto_attribs=True)
class CreateProjectResponse201Data:
    """
    Attributes:
        id (Union[Unset, int]): Project ID Example: 1.
        project_name (Union[Unset, str]): Project name Example: My Project.
        sitemap_path (Union[Unset, str]): Project sitemap Example: https://www.example.com/sitemap.xml.
        is_chat_active (Union[Unset, bool]): Whether the chat bot is active or not Example: True.
        user_id (Union[Unset, int]): User ID of the project owner Example: 1.
        created_at (Union[Unset, datetime.datetime]): Date and time when the project was created Default:
            isoparse('2023-05-08 13:06:55'). Example: 2021-01-01 00:00:00.
        updated_at (Union[Unset, datetime.datetime]): Date and time when the project was last updated Default:
            isoparse('2023-05-08 13:06:55'). Example: 2021-01-01 00:00:00.
        deleted_at (Union[Unset, None, datetime.datetime]): Date and time when the project was deleted Example:
            2021-01-01 00:00:00.
        type (Union[Unset, CreateProjectResponse201DataType]): Project type Default:
            CreateProjectResponse201DataType.SITEMAP. Example: SITEMAP.
        is_shared (Union[Unset, bool]): Whether the project is shared or not Example: True.
        shareable_slug (Union[Unset, None, str]): Shareable slug that can be used to share the project Example:
            1234567890abcdef1234567890abcdef.
        shareable_link (Union[Unset, None, str]): Shareable link that can be used to share the project
        embed_code (Union[Unset, None, str]): Embed code that can be used to embed the project
        live_chat_code (Union[Unset, None, str]): Live chat code that can be used to embed the live chat
    """

    id: Union[Unset, int] = UNSET
    project_name: Union[Unset, str] = UNSET
    sitemap_path: Union[Unset, str] = UNSET
    is_chat_active: Union[Unset, bool] = False
    user_id: Union[Unset, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = isoparse("2023-05-08 13:06:55")
    updated_at: Union[Unset, datetime.datetime] = isoparse("2023-05-08 13:06:55")
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    type: Union[Unset, str] = "SITEMAP"
    is_shared: Union[Unset, bool] = False
    shareable_slug: Union[Unset, None, str] = UNSET
    shareable_link: Union[Unset, None, str] = UNSET
    embed_code: Union[Unset, None, str] = UNSET
    live_chat_code: Union[Unset, None, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        project_name = self.project_name
        sitemap_path = self.sitemap_path
        is_chat_active = self.is_chat_active
        user_id = self.user_id
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        type: Union[Unset, str] = UNSET
        if not isinstance(self.type, Unset):
            type = self.type

        is_shared = self.is_shared
        shareable_slug = self.shareable_slug
        shareable_link = self.shareable_link
        embed_code = self.embed_code
        live_chat_code = self.live_chat_code

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if project_name is not UNSET:
            field_dict["project_name"] = project_name
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path
        if is_chat_active is not UNSET:
            field_dict["is_chat_active"] = is_chat_active
        if user_id is not UNSET:
            field_dict["user_id"] = user_id
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at
        if type is not UNSET:
            field_dict["type"] = type
        if is_shared is not UNSET:
            field_dict["is_shared"] = is_shared
        if shareable_slug is not UNSET:
            field_dict["shareable_slug"] = shareable_slug
        if shareable_link is not UNSET:
            field_dict["shareable_link"] = shareable_link
        if embed_code is not UNSET:
            field_dict["embed_code"] = embed_code
        if live_chat_code is not UNSET:
            field_dict["live_chat_code"] = live_chat_code

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        id = src_dict.get("id")

        project_name = src_dict.get("project_name")

        sitemap_path = src_dict.get("sitemap_path")

        is_chat_active = src_dict.get("is_chat_active")

        user_id = src_dict.get("user_id")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        type = src_dict.get("type")

        is_shared = src_dict.get("is_shared")

        shareable_slug = src_dict.get("shareable_slug")

        shareable_link = src_dict.get("shareable_link")

        embed_code = src_dict.get("embed_code")

        live_chat_code = src_dict.get("live_chat_code")

        create_project_response_201_data = cls(
            id=id,
            project_name=project_name,
            sitemap_path=sitemap_path,
            is_chat_active=is_chat_active,
            user_id=user_id,
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
            type=type,
            is_shared=is_shared,
            shareable_slug=shareable_slug,
            shareable_link=shareable_link,
            embed_code=embed_code,
            live_chat_code=live_chat_code,
        )

        create_project_response_201_data.additional_properties = src_dict
        return create_project_response_201_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_project_response_201_data_type.py:
```
from enum import Enum


class CreateProjectResponse201DataType(str, Enum):
    SITEMAP = "SITEMAP"
    URL = "URL"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_project_response_201_status.py:
```
from enum import Enum


class CreateProjectResponse201Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_project_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_project_response_400_data import CreateProjectResponse400Data


T = TypeVar("T", bound="CreateProjectResponse400")


@attr.s(auto_attribs=True)
class CreateProjectResponse400:
    """
    Attributes:
        status (Union[Unset, CreateProjectResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreateProjectResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreateProjectResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_project_response_400_data import CreateProjectResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreateProjectResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateProjectResponse400Data.from_dict(_data)

        create_project_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_project_response_400.additional_properties = src_dict
        return create_project_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_project_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateProjectResponse400Data")


@attr.s(auto_attribs=True)
class CreateProjectResponse400Data:
    """
    Attributes:
        code (Union[Unset, CreateProjectResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, CreateProjectResponse400DataMessage]): The error message Example: Project name can't be
            empty.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = "Project name can't be empty"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_project_response_400_data = cls(
            code=code,
            message=message,
        )

        create_project_response_400_data.additional_properties = src_dict
        return create_project_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_project_response_400_data_code.py:
```
from enum import IntEnum


class CreateProjectResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_project_response_400_data_message.py:
```
from enum import Enum


class CreateProjectResponse400DataMessage(str, Enum):
    PROJECT_NAME_CANT_BE_EMPTY = "Project name can't be empty"
    SITEMAP_PATH_CANT_BE_EMPTY = "Sitemap path can't be empty"
    YOU_HAVE_REACHED_YOUR_MONTHLY_PROJECT_LIMIT = "You have reached your monthly project limit"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_project_response_400_status.py:
```
from enum import Enum


class CreateProjectResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_project_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_project_response_401_data import CreateProjectResponse401Data


T = TypeVar("T", bound="CreateProjectResponse401")


@attr.s(auto_attribs=True)
class CreateProjectResponse401:
    """
    Attributes:
        status (Union[Unset, CreateProjectResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreateProjectResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreateProjectResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_project_response_401_data import CreateProjectResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreateProjectResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateProjectResponse401Data.from_dict(_data)

        create_project_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_project_response_401.additional_properties = src_dict
        return create_project_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_project_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateProjectResponse401Data")


@attr.s(auto_attribs=True)
class CreateProjectResponse401Data:
    """
    Attributes:
        code (Union[Unset, CreateProjectResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_project_response_401_data = cls(
            code=code,
            message=message,
        )

        create_project_response_401_data.additional_properties = src_dict
        return create_project_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_project_response_401_data_code.py:
```
from enum import IntEnum


class CreateProjectResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_project_response_401_status.py:
```
from enum import Enum


class CreateProjectResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_project_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_project_response_500_data import CreateProjectResponse500Data


T = TypeVar("T", bound="CreateProjectResponse500")


@attr.s(auto_attribs=True)
class CreateProjectResponse500:
    """
    Attributes:
        status (Union[Unset, CreateProjectResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreateProjectResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreateProjectResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_project_response_500_data import CreateProjectResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreateProjectResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateProjectResponse500Data.from_dict(_data)

        create_project_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_project_response_500.additional_properties = src_dict
        return create_project_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_project_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateProjectResponse500Data")


@attr.s(auto_attribs=True)
class CreateProjectResponse500Data:
    """
    Attributes:
        code (Union[Unset, CreateProjectResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_project_response_500_data = cls(
            code=code,
            message=message,
        )

        create_project_response_500_data.additional_properties = src_dict
        return create_project_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_project_response_500_data_code.py:
```
from enum import IntEnum


class CreateProjectResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_project_response_500_status.py:
```
from enum import Enum


class CreateProjectResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_multipart_data.py:
```
from io import BytesIO
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, File, FileJsonType, Unset

T = TypeVar("T", bound="CreateSourceMultipartData")


@attr.s(auto_attribs=True)
class CreateSourceMultipartData:
    """
    Attributes:
        sitemap_path (Union[Unset, str]): The sitemap path Example: https://example.com/sitemap.xml.
        file_data_retension (Union[Unset, bool]): File data retension Example: True.
        file (Union[Unset, File]): The submitted file. Example: file.pdf.
    """

    sitemap_path: Union[Unset, str] = UNSET
    file_data_retension: Union[Unset, bool] = UNSET
    file: Union[Unset, File] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        sitemap_path = self.sitemap_path
        file_data_retension = self.file_data_retension
        file: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.file, Unset):
            file = self.file.to_tuple()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path
        if file_data_retension is not UNSET:
            field_dict["file_data_retension"] = file_data_retension
        if file is not UNSET:
            field_dict["file"] = file

        return field_dict

    def to_multipart(self) -> Dict[str, Any]:
        sitemap_path = (
            self.sitemap_path
            if isinstance(self.sitemap_path, Unset)
            else (None, str(self.sitemap_path).encode(), "text/plain")
        )
        file_data_retension = (
            self.file_data_retension
            if isinstance(self.file_data_retension, Unset)
            else (None, str(self.file_data_retension).lower().encode(), "text/plain")
        )
        file: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.file, Unset):
            file = self.file.to_tuple()

        field_dict: Dict[str, Any] = {}
        field_dict.update(
            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
        )
        field_dict.update({})
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path
        if file_data_retension is not UNSET:
            field_dict["file_data_retension"] = file_data_retension
        if file is not UNSET:
            field_dict["file"] = file

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        sitemap_path = src_dict.get("sitemap_path")

        file_data_retension = src_dict.get("file_data_retension")

        _file = src_dict.get("file")
        file: Union[Unset, File]
        if isinstance(_file, Unset):
            file = UNSET
        else:
            file = File(payload=BytesIO(_file))

        create_source_multipart_data = cls(
            sitemap_path=sitemap_path,
            file_data_retension=file_data_retension,
            file=file,
        )

        create_source_multipart_data.additional_properties = src_dict
        return create_source_multipart_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_source_response_201.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_source_response_201_data import CreateSourceResponse201Data


T = TypeVar("T", bound="CreateSourceResponse201")


@attr.s(auto_attribs=True)
class CreateSourceResponse201:
    """
    Attributes:
        status (Union[Unset, CreateSourceResponse201Status]): The status of the response Example: success.
        data (Union[Unset, CreateSourceResponse201Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "CreateSourceResponse201Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_source_response_201_data import CreateSourceResponse201Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, CreateSourceResponse201Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateSourceResponse201Data.from_dict(_data)

        create_source_response_201 = cls(
            status=status,
            data=data,
        )

        create_source_response_201.additional_properties = src_dict
        return create_source_response_201

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_source_response_201_data.py:
```
import datetime
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_source_response_201_data_pages_item import CreateSourceResponse201DataPagesItem
    from ..models.create_source_response_201_data_settings import CreateSourceResponse201DataSettings


T = TypeVar("T", bound="CreateSourceResponse201Data")


@attr.s(auto_attribs=True)
class CreateSourceResponse201Data:
    """
    Attributes:
        id (Union[Unset, int]): The project source ID Example: 1.
        created_at (Union[Unset, datetime.datetime]): The project source creation date Example: 2021-01-01 00:00:00.
        updated_at (Union[Unset, datetime.datetime]): The project source update date Example: 2021-01-01 00:00:00.
        type (Union[Unset, CreateSourceResponse201DataType]): The project source type Example: sitemap.
        settings (Union[Unset, CreateSourceResponse201DataSettings]): The project source settings
        pages (Union[Unset, None, List['CreateSourceResponse201DataPagesItem']]): The project source pages
    """

    id: Union[Unset, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    type: Union[Unset, str] = "sitemap"
    settings: Union[Unset, "CreateSourceResponse201DataSettings"] = UNSET
    pages: Union[Unset, None, List["CreateSourceResponse201DataPagesItem"]] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        type: Union[Unset, str] = UNSET
        if not isinstance(self.type, Unset):
            type = self.type

        settings: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.settings, Unset):
            settings = self.settings.to_dict()

        pages: Union[Unset, None, List[Dict[str, Any]]] = UNSET
        if not isinstance(self.pages, Unset):
            if self.pages is None:
                pages = None
            else:
                pages = []
                for pages_item_data in self.pages:
                    pages_item = pages_item_data.to_dict()

                    pages.append(pages_item)

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if type is not UNSET:
            field_dict["type"] = type
        if settings is not UNSET:
            field_dict["settings"] = settings
        if pages is not UNSET:
            for index, field_value in enumerate(pages):
                field_dict[f"pages[]"] = field_value

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_source_response_201_data_pages_item import CreateSourceResponse201DataPagesItem
        from ..models.create_source_response_201_data_settings import CreateSourceResponse201DataSettings

        id = src_dict.get("id")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        type = src_dict.get("type")

        _settings = src_dict.get("settings")
        settings: Union[Unset, CreateSourceResponse201DataSettings]
        if isinstance(_settings, Unset):
            settings = UNSET
        else:
            settings = CreateSourceResponse201DataSettings.from_dict(_settings)

        pages = []
        _pages = src_dict.get("pages")
        for pages_item_data in _pages or []:
            pages_item = CreateSourceResponse201DataPagesItem.from_dict(pages_item_data)

            pages.append(pages_item)

        create_source_response_201_data = cls(
            id=id,
            created_at=created_at,
            updated_at=updated_at,
            type=type,
            settings=settings,
            pages=pages,
        )

        create_source_response_201_data.additional_properties = src_dict
        return create_source_response_201_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_source_response_201_data_pages_item.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateSourceResponse201DataPagesItem")


@attr.s(auto_attribs=True)
class CreateSourceResponse201DataPagesItem:
    r"""
    Attributes:
        id (Union[Unset, int]): Page ID Example: 1.
        page_url (Union[Unset, str]): URL of the page or file Example: https://example.com.
        page_url_hash (Union[Unset, str]): Hash of the URL of the page or file Example:
            d41d8cd98f00b204e9800998ecf8427e.
        project_id (Union[Unset, int]): Project ID Example: 1.
        s3_path (Union[Unset, None, str]): This is the path where the page is stored in S3.\nNote: This is omitted in
            the response if the page is not a file Example: project-1/page-1/file.pdf.
        crawl_status (Union[Unset, CreateSourceResponse201DataPagesItemCrawlStatus]): Crawl status of the page Default:
            CreateSourceResponse201DataPagesItemCrawlStatus.QUEUED. Example: queued.
        index_status (Union[Unset, CreateSourceResponse201DataPagesItemIndexStatus]): Index status of the page Default:
            CreateSourceResponse201DataPagesItemIndexStatus.QUEUED. Example: queued.
        is_file (Union[Unset, bool]): Whether the page is a file or not Example: True.
        is_file_kept (Union[Unset, bool]): Whether the file is kept after processing or not.\nNote: This is omitted in
            the response if the page is not a file Default: True. Example: True.
        filename (Union[Unset, None, str]): Filename of the page.\nNote: This is omitted in the response if the page is
            not a file Example: file.pdf.
        filesize (Union[Unset, None, int]): Filesize of the page.\nNote: This is omitted in the response if the page is
            not a file Example: 100.
        created_at (Union[Unset, datetime.datetime]): Date and time when the page was created Example: 2021-01-01
            00:00:00.
        updated_at (Union[Unset, datetime.datetime]): Date and time when the page was updated Example: 2021-01-01
            00:00:00.
        deleted_at (Union[Unset, None, datetime.datetime]): Date and time when the page was deleted Example: 2021-01-01
            00:00:00.
    """

    id: Union[Unset, int] = UNSET
    page_url: Union[Unset, str] = UNSET
    page_url_hash: Union[Unset, str] = UNSET
    project_id: Union[Unset, int] = UNSET
    s3_path: Union[Unset, None, str] = UNSET
    crawl_status: Union[Unset, str] = "queued"
    index_status: Union[Unset, str] = "queued"
    is_file: Union[Unset, bool] = False
    is_file_kept: Union[Unset, bool] = True
    filename: Union[Unset, None, str] = UNSET
    filesize: Union[Unset, None, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        page_url = self.page_url
        page_url_hash = self.page_url_hash
        project_id = self.project_id
        s3_path = self.s3_path
        crawl_status: Union[Unset, str] = UNSET
        if not isinstance(self.crawl_status, Unset):
            crawl_status = self.crawl_status

        index_status: Union[Unset, str] = UNSET
        if not isinstance(self.index_status, Unset):
            index_status = self.index_status

        is_file = self.is_file
        is_file_kept = self.is_file_kept
        filename = self.filename
        filesize = self.filesize
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if page_url is not UNSET:
            field_dict["page_url"] = page_url
        if page_url_hash is not UNSET:
            field_dict["page_url_hash"] = page_url_hash
        if project_id is not UNSET:
            field_dict["project_id"] = project_id
        if s3_path is not UNSET:
            field_dict["s3_path"] = s3_path
        if crawl_status is not UNSET:
            field_dict["crawl_status"] = crawl_status
        if index_status is not UNSET:
            field_dict["index_status"] = index_status
        if is_file is not UNSET:
            field_dict["is_file"] = is_file
        if is_file_kept is not UNSET:
            field_dict["is_file_kept"] = is_file_kept
        if filename is not UNSET:
            field_dict["filename"] = filename
        if filesize is not UNSET:
            field_dict["filesize"] = filesize
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        id = src_dict.get("id")

        page_url = src_dict.get("page_url")

        page_url_hash = src_dict.get("page_url_hash")

        project_id = src_dict.get("project_id")

        s3_path = src_dict.get("s3_path")

        crawl_status = src_dict.get("crawl_status")

        index_status = src_dict.get("index_status")

        is_file = src_dict.get("is_file")

        is_file_kept = src_dict.get("is_file_kept")

        filename = src_dict.get("filename")

        filesize = src_dict.get("filesize")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        create_source_response_201_data_pages_item = cls(
            id=id,
            page_url=page_url,
            page_url_hash=page_url_hash,
            project_id=project_id,
            s3_path=s3_path,
            crawl_status=crawl_status,
            index_status=index_status,
            is_file=is_file,
            is_file_kept=is_file_kept,
            filename=filename,
            filesize=filesize,
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
        )

        create_source_response_201_data_pages_item.additional_properties = src_dict
        return create_source_response_201_data_pages_item

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_source_response_201_data_pages_item_crawl_status.py:
```
from enum import Enum


class CreateSourceResponse201DataPagesItemCrawlStatus(str, Enum):
    FAILED = "failed"
    LIMITED = "limited"
    NA = "n/a"
    OK = "ok"
    QUEUED = "queued"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_response_201_data_pages_item_index_status.py:
```
from enum import Enum


class CreateSourceResponse201DataPagesItemIndexStatus(str, Enum):
    FAILED = "failed"
    LIMITED = "limited"
    NA = "n/a"
    OK = "ok"
    QUEUED = "queued"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_response_201_data_settings.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateSourceResponse201DataSettings")


@attr.s(auto_attribs=True)
class CreateSourceResponse201DataSettings:
    """The project source settings

    Attributes:
        data_refresh (Union[Unset, bool]): Whether the project source data should be refreshed Example: True.
        executive_js (Union[Unset, bool]): Whether the project source should execute JavaScript Default: True. Example:
            True.
        data_refresh_frequency (Union[Unset, str]): The project source data refresh frequency Default: 'never'. Example:
            never.
        sitemap_path (Union[Unset, str]): The project source sitemap path Example: https://example.com/sitemap.xml.
    """

    data_refresh: Union[Unset, bool] = False
    executive_js: Union[Unset, bool] = True
    data_refresh_frequency: Union[Unset, str] = "never"
    sitemap_path: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        data_refresh = self.data_refresh
        executive_js = self.executive_js
        data_refresh_frequency = self.data_refresh_frequency
        sitemap_path = self.sitemap_path

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if data_refresh is not UNSET:
            field_dict["data_refresh"] = data_refresh
        if executive_js is not UNSET:
            field_dict["executive_js"] = executive_js
        if data_refresh_frequency is not UNSET:
            field_dict["data_refresh_frequency"] = data_refresh_frequency
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        data_refresh = src_dict.get("data_refresh")

        executive_js = src_dict.get("executive_js")

        data_refresh_frequency = src_dict.get("data_refresh_frequency")

        sitemap_path = src_dict.get("sitemap_path")

        create_source_response_201_data_settings = cls(
            data_refresh=data_refresh,
            executive_js=executive_js,
            data_refresh_frequency=data_refresh_frequency,
            sitemap_path=sitemap_path,
        )

        create_source_response_201_data_settings.additional_properties = src_dict
        return create_source_response_201_data_settings

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_source_response_201_data_type.py:
```
from enum import Enum


class CreateSourceResponse201DataType(str, Enum):
    SITEMAP = "sitemap"
    UPLOAD = "upload"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_response_201_status.py:
```
from enum import Enum


class CreateSourceResponse201Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_source_response_400_data import CreateSourceResponse400Data


T = TypeVar("T", bound="CreateSourceResponse400")


@attr.s(auto_attribs=True)
class CreateSourceResponse400:
    """
    Attributes:
        status (Union[Unset, CreateSourceResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreateSourceResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreateSourceResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_source_response_400_data import CreateSourceResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreateSourceResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateSourceResponse400Data.from_dict(_data)

        create_source_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_source_response_400.additional_properties = src_dict
        return create_source_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_source_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateSourceResponse400Data")


@attr.s(auto_attribs=True)
class CreateSourceResponse400Data:
    """
    Attributes:
        code (Union[Unset, CreateSourceResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, CreateSourceResponse400DataMessage]): The error message Example: Sitemap URL is empty.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = "Sitemap URL is empty"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_source_response_400_data = cls(
            code=code,
            message=message,
        )

        create_source_response_400_data.additional_properties = src_dict
        return create_source_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_source_response_400_data_code.py:
```
from enum import IntEnum


class CreateSourceResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_response_400_data_message.py:
```
from enum import Enum


class CreateSourceResponse400DataMessage(str, Enum):
    OUR_SYSTEM_COULD_NOT_DETECT_ANY_PAGES_IN_YOUR_SITEMAP = "Our system could not detect any pages in your sitemap"
    OUR_SYSTEM_COULD_NOT_VALIDATE_YOUR_SITEMAP = "Our system could not validate your sitemap"
    SITEMAP_URL_IS_EMPTY = "Sitemap URL is empty"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_response_400_status.py:
```
from enum import Enum


class CreateSourceResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_source_response_401_data import CreateSourceResponse401Data


T = TypeVar("T", bound="CreateSourceResponse401")


@attr.s(auto_attribs=True)
class CreateSourceResponse401:
    """
    Attributes:
        status (Union[Unset, CreateSourceResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreateSourceResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreateSourceResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_source_response_401_data import CreateSourceResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreateSourceResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateSourceResponse401Data.from_dict(_data)

        create_source_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_source_response_401.additional_properties = src_dict
        return create_source_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_source_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateSourceResponse401Data")


@attr.s(auto_attribs=True)
class CreateSourceResponse401Data:
    """
    Attributes:
        code (Union[Unset, CreateSourceResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_source_response_401_data = cls(
            code=code,
            message=message,
        )

        create_source_response_401_data.additional_properties = src_dict
        return create_source_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_source_response_401_data_code.py:
```
from enum import IntEnum


class CreateSourceResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_response_401_status.py:
```
from enum import Enum


class CreateSourceResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_source_response_404_data import CreateSourceResponse404Data


T = TypeVar("T", bound="CreateSourceResponse404")


@attr.s(auto_attribs=True)
class CreateSourceResponse404:
    """
    Attributes:
        status (Union[Unset, CreateSourceResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreateSourceResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreateSourceResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_source_response_404_data import CreateSourceResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreateSourceResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateSourceResponse404Data.from_dict(_data)

        create_source_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_source_response_404.additional_properties = src_dict
        return create_source_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_source_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateSourceResponse404Data")


@attr.s(auto_attribs=True)
class CreateSourceResponse404Data:
    """
    Attributes:
        code (Union[Unset, CreateSourceResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, CreateSourceResponse404DataMessage]): The error message Example: Project with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_source_response_404_data = cls(
            code=code,
            message=message,
        )

        create_source_response_404_data.additional_properties = src_dict
        return create_source_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_source_response_404_data_code.py:
```
from enum import IntEnum


class CreateSourceResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_response_404_data_message.py:
```
from enum import Enum


class CreateSourceResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_response_404_status.py:
```
from enum import Enum


class CreateSourceResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.create_source_response_500_data import CreateSourceResponse500Data


T = TypeVar("T", bound="CreateSourceResponse500")


@attr.s(auto_attribs=True)
class CreateSourceResponse500:
    """
    Attributes:
        status (Union[Unset, CreateSourceResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, CreateSourceResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "CreateSourceResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.create_source_response_500_data import CreateSourceResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, CreateSourceResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = CreateSourceResponse500Data.from_dict(_data)

        create_source_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        create_source_response_500.additional_properties = src_dict
        return create_source_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_source_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="CreateSourceResponse500Data")


@attr.s(auto_attribs=True)
class CreateSourceResponse500Data:
    """
    Attributes:
        code (Union[Unset, CreateSourceResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        create_source_response_500_data = cls(
            code=code,
            message=message,
        )

        create_source_response_500_data.additional_properties = src_dict
        return create_source_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/create_source_response_500_data_code.py:
```
from enum import IntEnum


class CreateSourceResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/create_source_response_500_status.py:
```
from enum import Enum


class CreateSourceResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_conversation_response_200_data import DeleteConversationResponse200Data


T = TypeVar("T", bound="DeleteConversationResponse200")


@attr.s(auto_attribs=True)
class DeleteConversationResponse200:
    """
    Attributes:
        status (Union[Unset, DeleteConversationResponse200Status]): The status of the response Example: success.
        data (Union[Unset, DeleteConversationResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "DeleteConversationResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_conversation_response_200_data import DeleteConversationResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteConversationResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteConversationResponse200Data.from_dict(_data)

        delete_conversation_response_200 = cls(
            status=status,
            data=data,
        )

        delete_conversation_response_200.additional_properties = src_dict
        return delete_conversation_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_200_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteConversationResponse200Data")


@attr.s(auto_attribs=True)
class DeleteConversationResponse200Data:
    """
    Attributes:
        deleted (Union[Unset, bool]): Whether the project was deleted successfully or not Example: True.
    """

    deleted: Union[Unset, bool] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        deleted = self.deleted

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if deleted is not UNSET:
            field_dict["deleted"] = deleted

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        deleted = src_dict.get("deleted")

        delete_conversation_response_200_data = cls(
            deleted=deleted,
        )

        delete_conversation_response_200_data.additional_properties = src_dict
        return delete_conversation_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_200_status.py:
```
from enum import Enum


class DeleteConversationResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_conversation_response_400_data import DeleteConversationResponse400Data


T = TypeVar("T", bound="DeleteConversationResponse400")


@attr.s(auto_attribs=True)
class DeleteConversationResponse400:
    """
    Attributes:
        status (Union[Unset, DeleteConversationResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeleteConversationResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeleteConversationResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_conversation_response_400_data import DeleteConversationResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteConversationResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteConversationResponse400Data.from_dict(_data)

        delete_conversation_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_conversation_response_400.additional_properties = src_dict
        return delete_conversation_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteConversationResponse400Data")


@attr.s(auto_attribs=True)
class DeleteConversationResponse400Data:
    """
    Attributes:
        code (Union[Unset, DeleteConversationResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_conversation_response_400_data = cls(
            code=code,
            message=message,
        )

        delete_conversation_response_400_data.additional_properties = src_dict
        return delete_conversation_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_400_data_code.py:
```
from enum import IntEnum


class DeleteConversationResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_400_status.py:
```
from enum import Enum


class DeleteConversationResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_conversation_response_401_data import DeleteConversationResponse401Data


T = TypeVar("T", bound="DeleteConversationResponse401")


@attr.s(auto_attribs=True)
class DeleteConversationResponse401:
    """
    Attributes:
        status (Union[Unset, DeleteConversationResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeleteConversationResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeleteConversationResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_conversation_response_401_data import DeleteConversationResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteConversationResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteConversationResponse401Data.from_dict(_data)

        delete_conversation_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_conversation_response_401.additional_properties = src_dict
        return delete_conversation_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteConversationResponse401Data")


@attr.s(auto_attribs=True)
class DeleteConversationResponse401Data:
    """
    Attributes:
        code (Union[Unset, DeleteConversationResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_conversation_response_401_data = cls(
            code=code,
            message=message,
        )

        delete_conversation_response_401_data.additional_properties = src_dict
        return delete_conversation_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_401_data_code.py:
```
from enum import IntEnum


class DeleteConversationResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_401_status.py:
```
from enum import Enum


class DeleteConversationResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_conversation_response_404_data import DeleteConversationResponse404Data


T = TypeVar("T", bound="DeleteConversationResponse404")


@attr.s(auto_attribs=True)
class DeleteConversationResponse404:
    """
    Attributes:
        status (Union[Unset, DeleteConversationResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeleteConversationResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeleteConversationResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_conversation_response_404_data import DeleteConversationResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteConversationResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteConversationResponse404Data.from_dict(_data)

        delete_conversation_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_conversation_response_404.additional_properties = src_dict
        return delete_conversation_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteConversationResponse404Data")


@attr.s(auto_attribs=True)
class DeleteConversationResponse404Data:
    """
    Attributes:
        code (Union[Unset, DeleteConversationResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, DeleteConversationResponse404DataMessage]): The error message Example: Project with id 1
            not found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_conversation_response_404_data = cls(
            code=code,
            message=message,
        )

        delete_conversation_response_404_data.additional_properties = src_dict
        return delete_conversation_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_404_data_code.py:
```
from enum import IntEnum


class DeleteConversationResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_404_data_message.py:
```
from enum import Enum


class DeleteConversationResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_404_status.py:
```
from enum import Enum


class DeleteConversationResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_conversation_response_500_data import DeleteConversationResponse500Data


T = TypeVar("T", bound="DeleteConversationResponse500")


@attr.s(auto_attribs=True)
class DeleteConversationResponse500:
    """
    Attributes:
        status (Union[Unset, DeleteConversationResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeleteConversationResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeleteConversationResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_conversation_response_500_data import DeleteConversationResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteConversationResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteConversationResponse500Data.from_dict(_data)

        delete_conversation_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_conversation_response_500.additional_properties = src_dict
        return delete_conversation_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteConversationResponse500Data")


@attr.s(auto_attribs=True)
class DeleteConversationResponse500Data:
    """
    Attributes:
        code (Union[Unset, DeleteConversationResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_conversation_response_500_data = cls(
            code=code,
            message=message,
        )

        delete_conversation_response_500_data.additional_properties = src_dict
        return delete_conversation_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_500_data_code.py:
```
from enum import IntEnum


class DeleteConversationResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_conversation_response_500_status.py:
```
from enum import Enum


class DeleteConversationResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_page_response_200_data import DeletePageResponse200Data


T = TypeVar("T", bound="DeletePageResponse200")


@attr.s(auto_attribs=True)
class DeletePageResponse200:
    """
    Attributes:
        status (Union[Unset, DeletePageResponse200Status]): The status of the response Example: success.
        data (Union[Unset, DeletePageResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "DeletePageResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_page_response_200_data import DeletePageResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, DeletePageResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeletePageResponse200Data.from_dict(_data)

        delete_page_response_200 = cls(
            status=status,
            data=data,
        )

        delete_page_response_200.additional_properties = src_dict
        return delete_page_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_200_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeletePageResponse200Data")


@attr.s(auto_attribs=True)
class DeletePageResponse200Data:
    """
    Attributes:
        deleted (Union[Unset, bool]): Whether the project was deleted successfully or not Example: True.
    """

    deleted: Union[Unset, bool] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        deleted = self.deleted

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if deleted is not UNSET:
            field_dict["deleted"] = deleted

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        deleted = src_dict.get("deleted")

        delete_page_response_200_data = cls(
            deleted=deleted,
        )

        delete_page_response_200_data.additional_properties = src_dict
        return delete_page_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_200_status.py:
```
from enum import Enum


class DeletePageResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_page_response_400_data import DeletePageResponse400Data


T = TypeVar("T", bound="DeletePageResponse400")


@attr.s(auto_attribs=True)
class DeletePageResponse400:
    """
    Attributes:
        status (Union[Unset, DeletePageResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeletePageResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeletePageResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_page_response_400_data import DeletePageResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeletePageResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeletePageResponse400Data.from_dict(_data)

        delete_page_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_page_response_400.additional_properties = src_dict
        return delete_page_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeletePageResponse400Data")


@attr.s(auto_attribs=True)
class DeletePageResponse400Data:
    """
    Attributes:
        code (Union[Unset, DeletePageResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_page_response_400_data = cls(
            code=code,
            message=message,
        )

        delete_page_response_400_data.additional_properties = src_dict
        return delete_page_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_400_data_code.py:
```
from enum import IntEnum


class DeletePageResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_400_status.py:
```
from enum import Enum


class DeletePageResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_page_response_401_data import DeletePageResponse401Data


T = TypeVar("T", bound="DeletePageResponse401")


@attr.s(auto_attribs=True)
class DeletePageResponse401:
    """
    Attributes:
        status (Union[Unset, DeletePageResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeletePageResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeletePageResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_page_response_401_data import DeletePageResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeletePageResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeletePageResponse401Data.from_dict(_data)

        delete_page_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_page_response_401.additional_properties = src_dict
        return delete_page_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeletePageResponse401Data")


@attr.s(auto_attribs=True)
class DeletePageResponse401Data:
    """
    Attributes:
        code (Union[Unset, DeletePageResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_page_response_401_data = cls(
            code=code,
            message=message,
        )

        delete_page_response_401_data.additional_properties = src_dict
        return delete_page_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_401_data_code.py:
```
from enum import IntEnum


class DeletePageResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_401_status.py:
```
from enum import Enum


class DeletePageResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_page_response_404_data import DeletePageResponse404Data


T = TypeVar("T", bound="DeletePageResponse404")


@attr.s(auto_attribs=True)
class DeletePageResponse404:
    """
    Attributes:
        status (Union[Unset, DeletePageResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeletePageResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeletePageResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_page_response_404_data import DeletePageResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeletePageResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeletePageResponse404Data.from_dict(_data)

        delete_page_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_page_response_404.additional_properties = src_dict
        return delete_page_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeletePageResponse404Data")


@attr.s(auto_attribs=True)
class DeletePageResponse404Data:
    """
    Attributes:
        code (Union[Unset, DeletePageResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, DeletePageResponse404DataMessage]): The error message Example: Project with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_page_response_404_data = cls(
            code=code,
            message=message,
        )

        delete_page_response_404_data.additional_properties = src_dict
        return delete_page_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_404_data_code.py:
```
from enum import IntEnum


class DeletePageResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_404_data_message.py:
```
from enum import Enum


class DeletePageResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_404_status.py:
```
from enum import Enum


class DeletePageResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_page_response_500_data import DeletePageResponse500Data


T = TypeVar("T", bound="DeletePageResponse500")


@attr.s(auto_attribs=True)
class DeletePageResponse500:
    """
    Attributes:
        status (Union[Unset, DeletePageResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeletePageResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeletePageResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_page_response_500_data import DeletePageResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeletePageResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeletePageResponse500Data.from_dict(_data)

        delete_page_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_page_response_500.additional_properties = src_dict
        return delete_page_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeletePageResponse500Data")


@attr.s(auto_attribs=True)
class DeletePageResponse500Data:
    """
    Attributes:
        code (Union[Unset, DeletePageResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_page_response_500_data = cls(
            code=code,
            message=message,
        )

        delete_page_response_500_data.additional_properties = src_dict
        return delete_page_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_500_data_code.py:
```
from enum import IntEnum


class DeletePageResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_page_response_500_status.py:
```
from enum import Enum


class DeletePageResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_project_response_200_data import DeleteProjectResponse200Data


T = TypeVar("T", bound="DeleteProjectResponse200")


@attr.s(auto_attribs=True)
class DeleteProjectResponse200:
    """
    Attributes:
        status (Union[Unset, DeleteProjectResponse200Status]): The status of the response Example: success.
        data (Union[Unset, DeleteProjectResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "DeleteProjectResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_project_response_200_data import DeleteProjectResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteProjectResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteProjectResponse200Data.from_dict(_data)

        delete_project_response_200 = cls(
            status=status,
            data=data,
        )

        delete_project_response_200.additional_properties = src_dict
        return delete_project_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_200_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteProjectResponse200Data")


@attr.s(auto_attribs=True)
class DeleteProjectResponse200Data:
    """
    Attributes:
        deleted (Union[Unset, bool]): Whether the project was deleted successfully or not Example: True.
    """

    deleted: Union[Unset, bool] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        deleted = self.deleted

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if deleted is not UNSET:
            field_dict["deleted"] = deleted

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        deleted = src_dict.get("deleted")

        delete_project_response_200_data = cls(
            deleted=deleted,
        )

        delete_project_response_200_data.additional_properties = src_dict
        return delete_project_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_200_status.py:
```
from enum import Enum


class DeleteProjectResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_project_response_400_data import DeleteProjectResponse400Data


T = TypeVar("T", bound="DeleteProjectResponse400")


@attr.s(auto_attribs=True)
class DeleteProjectResponse400:
    """
    Attributes:
        status (Union[Unset, DeleteProjectResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeleteProjectResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeleteProjectResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_project_response_400_data import DeleteProjectResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteProjectResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteProjectResponse400Data.from_dict(_data)

        delete_project_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_project_response_400.additional_properties = src_dict
        return delete_project_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteProjectResponse400Data")


@attr.s(auto_attribs=True)
class DeleteProjectResponse400Data:
    """
    Attributes:
        code (Union[Unset, DeleteProjectResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_project_response_400_data = cls(
            code=code,
            message=message,
        )

        delete_project_response_400_data.additional_properties = src_dict
        return delete_project_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_400_data_code.py:
```
from enum import IntEnum


class DeleteProjectResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_400_status.py:
```
from enum import Enum


class DeleteProjectResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_project_response_401_data import DeleteProjectResponse401Data


T = TypeVar("T", bound="DeleteProjectResponse401")


@attr.s(auto_attribs=True)
class DeleteProjectResponse401:
    """
    Attributes:
        status (Union[Unset, DeleteProjectResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeleteProjectResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeleteProjectResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_project_response_401_data import DeleteProjectResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteProjectResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteProjectResponse401Data.from_dict(_data)

        delete_project_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_project_response_401.additional_properties = src_dict
        return delete_project_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteProjectResponse401Data")


@attr.s(auto_attribs=True)
class DeleteProjectResponse401Data:
    """
    Attributes:
        code (Union[Unset, DeleteProjectResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_project_response_401_data = cls(
            code=code,
            message=message,
        )

        delete_project_response_401_data.additional_properties = src_dict
        return delete_project_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_401_data_code.py:
```
from enum import IntEnum


class DeleteProjectResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_401_status.py:
```
from enum import Enum


class DeleteProjectResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_project_response_404_data import DeleteProjectResponse404Data


T = TypeVar("T", bound="DeleteProjectResponse404")


@attr.s(auto_attribs=True)
class DeleteProjectResponse404:
    """
    Attributes:
        status (Union[Unset, DeleteProjectResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeleteProjectResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeleteProjectResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_project_response_404_data import DeleteProjectResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteProjectResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteProjectResponse404Data.from_dict(_data)

        delete_project_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_project_response_404.additional_properties = src_dict
        return delete_project_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteProjectResponse404Data")


@attr.s(auto_attribs=True)
class DeleteProjectResponse404Data:
    """
    Attributes:
        code (Union[Unset, DeleteProjectResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, DeleteProjectResponse404DataMessage]): The error message Example: Project with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_project_response_404_data = cls(
            code=code,
            message=message,
        )

        delete_project_response_404_data.additional_properties = src_dict
        return delete_project_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_404_data_code.py:
```
from enum import IntEnum


class DeleteProjectResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_404_data_message.py:
```
from enum import Enum


class DeleteProjectResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_404_status.py:
```
from enum import Enum


class DeleteProjectResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_project_response_500_data import DeleteProjectResponse500Data


T = TypeVar("T", bound="DeleteProjectResponse500")


@attr.s(auto_attribs=True)
class DeleteProjectResponse500:
    """
    Attributes:
        status (Union[Unset, DeleteProjectResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeleteProjectResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeleteProjectResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_project_response_500_data import DeleteProjectResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteProjectResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteProjectResponse500Data.from_dict(_data)

        delete_project_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_project_response_500.additional_properties = src_dict
        return delete_project_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteProjectResponse500Data")


@attr.s(auto_attribs=True)
class DeleteProjectResponse500Data:
    """
    Attributes:
        code (Union[Unset, DeleteProjectResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_project_response_500_data = cls(
            code=code,
            message=message,
        )

        delete_project_response_500_data.additional_properties = src_dict
        return delete_project_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_500_data_code.py:
```
from enum import IntEnum


class DeleteProjectResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_project_response_500_status.py:
```
from enum import Enum


class DeleteProjectResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_source_response_200_data import DeleteSourceResponse200Data


T = TypeVar("T", bound="DeleteSourceResponse200")


@attr.s(auto_attribs=True)
class DeleteSourceResponse200:
    """
    Attributes:
        status (Union[Unset, DeleteSourceResponse200Status]): The status of the response Example: success.
        data (Union[Unset, DeleteSourceResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "DeleteSourceResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_source_response_200_data import DeleteSourceResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteSourceResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteSourceResponse200Data.from_dict(_data)

        delete_source_response_200 = cls(
            status=status,
            data=data,
        )

        delete_source_response_200.additional_properties = src_dict
        return delete_source_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_200_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteSourceResponse200Data")


@attr.s(auto_attribs=True)
class DeleteSourceResponse200Data:
    """
    Attributes:
        deleted (Union[Unset, bool]): Whether the project source was deleted successfully or not Example: True.
    """

    deleted: Union[Unset, bool] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        deleted = self.deleted

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if deleted is not UNSET:
            field_dict["deleted"] = deleted

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        deleted = src_dict.get("deleted")

        delete_source_response_200_data = cls(
            deleted=deleted,
        )

        delete_source_response_200_data.additional_properties = src_dict
        return delete_source_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_200_status.py:
```
from enum import Enum


class DeleteSourceResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_source_response_400_data import DeleteSourceResponse400Data


T = TypeVar("T", bound="DeleteSourceResponse400")


@attr.s(auto_attribs=True)
class DeleteSourceResponse400:
    """
    Attributes:
        status (Union[Unset, DeleteSourceResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeleteSourceResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeleteSourceResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_source_response_400_data import DeleteSourceResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteSourceResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteSourceResponse400Data.from_dict(_data)

        delete_source_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_source_response_400.additional_properties = src_dict
        return delete_source_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteSourceResponse400Data")


@attr.s(auto_attribs=True)
class DeleteSourceResponse400Data:
    """
    Attributes:
        code (Union[Unset, DeleteSourceResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_source_response_400_data = cls(
            code=code,
            message=message,
        )

        delete_source_response_400_data.additional_properties = src_dict
        return delete_source_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_400_data_code.py:
```
from enum import IntEnum


class DeleteSourceResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_400_status.py:
```
from enum import Enum


class DeleteSourceResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_source_response_401_data import DeleteSourceResponse401Data


T = TypeVar("T", bound="DeleteSourceResponse401")


@attr.s(auto_attribs=True)
class DeleteSourceResponse401:
    """
    Attributes:
        status (Union[Unset, DeleteSourceResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeleteSourceResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeleteSourceResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_source_response_401_data import DeleteSourceResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteSourceResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteSourceResponse401Data.from_dict(_data)

        delete_source_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_source_response_401.additional_properties = src_dict
        return delete_source_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteSourceResponse401Data")


@attr.s(auto_attribs=True)
class DeleteSourceResponse401Data:
    """
    Attributes:
        code (Union[Unset, DeleteSourceResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_source_response_401_data = cls(
            code=code,
            message=message,
        )

        delete_source_response_401_data.additional_properties = src_dict
        return delete_source_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_401_data_code.py:
```
from enum import IntEnum


class DeleteSourceResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_401_status.py:
```
from enum import Enum


class DeleteSourceResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_source_response_404_data import DeleteSourceResponse404Data


T = TypeVar("T", bound="DeleteSourceResponse404")


@attr.s(auto_attribs=True)
class DeleteSourceResponse404:
    """
    Attributes:
        status (Union[Unset, DeleteSourceResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeleteSourceResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeleteSourceResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_source_response_404_data import DeleteSourceResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteSourceResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteSourceResponse404Data.from_dict(_data)

        delete_source_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_source_response_404.additional_properties = src_dict
        return delete_source_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteSourceResponse404Data")


@attr.s(auto_attribs=True)
class DeleteSourceResponse404Data:
    """
    Attributes:
        code (Union[Unset, DeleteSourceResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, DeleteSourceResponse404DataMessage]): The error message Example: Project with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_source_response_404_data = cls(
            code=code,
            message=message,
        )

        delete_source_response_404_data.additional_properties = src_dict
        return delete_source_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_404_data_code.py:
```
from enum import IntEnum


class DeleteSourceResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_404_data_message.py:
```
from enum import Enum


class DeleteSourceResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_404_status.py:
```
from enum import Enum


class DeleteSourceResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.delete_source_response_500_data import DeleteSourceResponse500Data


T = TypeVar("T", bound="DeleteSourceResponse500")


@attr.s(auto_attribs=True)
class DeleteSourceResponse500:
    """
    Attributes:
        status (Union[Unset, DeleteSourceResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, DeleteSourceResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "DeleteSourceResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.delete_source_response_500_data import DeleteSourceResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, DeleteSourceResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = DeleteSourceResponse500Data.from_dict(_data)

        delete_source_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        delete_source_response_500.additional_properties = src_dict
        return delete_source_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="DeleteSourceResponse500Data")


@attr.s(auto_attribs=True)
class DeleteSourceResponse500Data:
    """
    Attributes:
        code (Union[Unset, DeleteSourceResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        delete_source_response_500_data = cls(
            code=code,
            message=message,
        )

        delete_source_response_500_data.additional_properties = src_dict
        return delete_source_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_500_data_code.py:
```
from enum import IntEnum


class DeleteSourceResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/delete_source_response_500_status.py:
```
from enum import Enum


class DeleteSourceResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_citation_response_200_data import GetCitationResponse200Data


T = TypeVar("T", bound="GetCitationResponse200")


@attr.s(auto_attribs=True)
class GetCitationResponse200:
    """
    Attributes:
        status (Union[Unset, GetCitationResponse200Status]): The status of the response Example: success.
        data (Union[Unset, GetCitationResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "GetCitationResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_citation_response_200_data import GetCitationResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, GetCitationResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetCitationResponse200Data.from_dict(_data)

        get_citation_response_200 = cls(
            status=status,
            data=data,
        )

        get_citation_response_200.additional_properties = src_dict
        return get_citation_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_200_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetCitationResponse200Data")


@attr.s(auto_attribs=True)
class GetCitationResponse200Data:
    """
    Attributes:
        page_url (Union[Unset, str]): The URL of the page Example: https://www.example.com.
        title (Union[Unset, str]): The title of the page Example: Example Domain.
        description (Union[Unset, str]): The description of the page Example: This domain is for use in illustrative
            examples in documents. You may use this domain in literature without prior coordination or asking for
            permission..
        image (Union[Unset, str]): The image of the page Example: https://www.example.com/image.png.
        image_width (Union[Unset, int]): The width of the image of the page Example: 1200.
        image_height (Union[Unset, int]): The height of the image of the page Example: 630.
        url (Union[Unset, str]): The URL of the page Example: https://www.example.com.
        favicon (Union[Unset, str]): The favicon of the page Example: https://www.example.com/favicon.ico.
        site_name (Union[Unset, str]): The site name of the page Example: Example Domain.
    """

    page_url: Union[Unset, str] = UNSET
    title: Union[Unset, str] = UNSET
    description: Union[Unset, str] = UNSET
    image: Union[Unset, str] = UNSET
    image_width: Union[Unset, int] = UNSET
    image_height: Union[Unset, int] = UNSET
    url: Union[Unset, str] = UNSET
    favicon: Union[Unset, str] = UNSET
    site_name: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        page_url = self.page_url
        title = self.title
        description = self.description
        image = self.image
        image_width = self.image_width
        image_height = self.image_height
        url = self.url
        favicon = self.favicon
        site_name = self.site_name

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if page_url is not UNSET:
            field_dict["page_url"] = page_url
        if title is not UNSET:
            field_dict["title"] = title
        if description is not UNSET:
            field_dict["description"] = description
        if image is not UNSET:
            field_dict["image"] = image
        if image_width is not UNSET:
            field_dict["image_width"] = image_width
        if image_height is not UNSET:
            field_dict["image_height"] = image_height
        if url is not UNSET:
            field_dict["url"] = url
        if favicon is not UNSET:
            field_dict["favicon"] = favicon
        if site_name is not UNSET:
            field_dict["site_name"] = site_name

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        page_url = src_dict.get("page_url")

        title = src_dict.get("title")

        description = src_dict.get("description")

        image = src_dict.get("image")

        image_width = src_dict.get("image_width")

        image_height = src_dict.get("image_height")

        url = src_dict.get("url")

        favicon = src_dict.get("favicon")

        site_name = src_dict.get("site_name")

        get_citation_response_200_data = cls(
            page_url=page_url,
            title=title,
            description=description,
            image=image,
            image_width=image_width,
            image_height=image_height,
            url=url,
            favicon=favicon,
            site_name=site_name,
        )

        get_citation_response_200_data.additional_properties = src_dict
        return get_citation_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_200_status.py:
```
from enum import Enum


class GetCitationResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_citation_response_400_data import GetCitationResponse400Data


T = TypeVar("T", bound="GetCitationResponse400")


@attr.s(auto_attribs=True)
class GetCitationResponse400:
    """
    Attributes:
        status (Union[Unset, GetCitationResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetCitationResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetCitationResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_citation_response_400_data import GetCitationResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetCitationResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetCitationResponse400Data.from_dict(_data)

        get_citation_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_citation_response_400.additional_properties = src_dict
        return get_citation_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetCitationResponse400Data")


@attr.s(auto_attribs=True)
class GetCitationResponse400Data:
    """
    Attributes:
        code (Union[Unset, GetCitationResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_citation_response_400_data = cls(
            code=code,
            message=message,
        )

        get_citation_response_400_data.additional_properties = src_dict
        return get_citation_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_400_data_code.py:
```
from enum import IntEnum


class GetCitationResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_400_status.py:
```
from enum import Enum


class GetCitationResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_citation_response_401_data import GetCitationResponse401Data


T = TypeVar("T", bound="GetCitationResponse401")


@attr.s(auto_attribs=True)
class GetCitationResponse401:
    """
    Attributes:
        status (Union[Unset, GetCitationResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetCitationResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetCitationResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_citation_response_401_data import GetCitationResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetCitationResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetCitationResponse401Data.from_dict(_data)

        get_citation_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_citation_response_401.additional_properties = src_dict
        return get_citation_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetCitationResponse401Data")


@attr.s(auto_attribs=True)
class GetCitationResponse401Data:
    """
    Attributes:
        code (Union[Unset, GetCitationResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_citation_response_401_data = cls(
            code=code,
            message=message,
        )

        get_citation_response_401_data.additional_properties = src_dict
        return get_citation_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_401_data_code.py:
```
from enum import IntEnum


class GetCitationResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_401_status.py:
```
from enum import Enum


class GetCitationResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_citation_response_404_data import GetCitationResponse404Data


T = TypeVar("T", bound="GetCitationResponse404")


@attr.s(auto_attribs=True)
class GetCitationResponse404:
    """
    Attributes:
        status (Union[Unset, GetCitationResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetCitationResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetCitationResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_citation_response_404_data import GetCitationResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetCitationResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetCitationResponse404Data.from_dict(_data)

        get_citation_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_citation_response_404.additional_properties = src_dict
        return get_citation_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetCitationResponse404Data")


@attr.s(auto_attribs=True)
class GetCitationResponse404Data:
    """
    Attributes:
        code (Union[Unset, GetCitationResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, GetCitationResponse404DataMessage]): The error message Example: Project with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_citation_response_404_data = cls(
            code=code,
            message=message,
        )

        get_citation_response_404_data.additional_properties = src_dict
        return get_citation_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_404_data_code.py:
```
from enum import IntEnum


class GetCitationResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_404_data_message.py:
```
from enum import Enum


class GetCitationResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_citation_response_404_status.py:
```
from enum import Enum


class GetCitationResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_conversations_order.py:
```
from enum import Enum


class GetConversationsOrder(str, Enum):
    ASC = "asc"
    DESC = "desc"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_conversations_response_200_data import GetConversationsResponse200Data


T = TypeVar("T", bound="GetConversationsResponse200")


@attr.s(auto_attribs=True)
class GetConversationsResponse200:
    """
    Attributes:
        status (Union[Unset, GetConversationsResponse200Status]): The status of the response Example: success.
        data (Union[Unset, GetConversationsResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "GetConversationsResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_conversations_response_200_data import GetConversationsResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, GetConversationsResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetConversationsResponse200Data.from_dict(_data)

        get_conversations_response_200 = cls(
            status=status,
            data=data,
        )

        get_conversations_response_200.additional_properties = src_dict
        return get_conversations_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_200_data.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_conversations_response_200_data_data_item import GetConversationsResponse200DataDataItem


T = TypeVar("T", bound="GetConversationsResponse200Data")


@attr.s(auto_attribs=True)
class GetConversationsResponse200Data:
    """
    Attributes:
        current_page (Union[Unset, int]): The current page number Example: 1.
        data (Union[Unset, List['GetConversationsResponse200DataDataItem']]):
        first_page_url (Union[Unset, str]): The first page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        from_ (Union[Unset, int]): The first item number of the current page Example: 1.
        last_page (Union[Unset, int]): The last page number Example: 1.
        last_page_url (Union[Unset, str]): The last page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        next_page_url (Union[Unset, str]): The next page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        path (Union[Unset, str]): The current page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        per_page (Union[Unset, int]): The number of items per page Example: 10.
        prev_page_url (Union[Unset, str]): The previous page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        to (Union[Unset, int]): The last item number of the current page Example: 1.
        total (Union[Unset, int]): The total number of items Example: 1.
    """

    current_page: Union[Unset, int] = UNSET
    data: Union[Unset, List["GetConversationsResponse200DataDataItem"]] = UNSET
    first_page_url: Union[Unset, str] = UNSET
    from_: Union[Unset, int] = UNSET
    last_page: Union[Unset, int] = UNSET
    last_page_url: Union[Unset, str] = UNSET
    next_page_url: Union[Unset, str] = UNSET
    path: Union[Unset, str] = UNSET
    per_page: Union[Unset, int] = UNSET
    prev_page_url: Union[Unset, str] = UNSET
    to: Union[Unset, int] = UNSET
    total: Union[Unset, int] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        current_page = self.current_page
        data: Union[Unset, List[Dict[str, Any]]] = UNSET
        if not isinstance(self.data, Unset):
            data = []
            for data_item_data in self.data:
                data_item = data_item_data.to_dict()

                data.append(data_item)

        first_page_url = self.first_page_url
        from_ = self.from_
        last_page = self.last_page
        last_page_url = self.last_page_url
        next_page_url = self.next_page_url
        path = self.path
        per_page = self.per_page
        prev_page_url = self.prev_page_url
        to = self.to
        total = self.total

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if current_page is not UNSET:
            field_dict["current_page"] = current_page
        if data is not UNSET:
            for index, field_value in enumerate(data):
                field_dict[f"data[]"] = field_value
        if first_page_url is not UNSET:
            field_dict["first_page_url"] = first_page_url
        if from_ is not UNSET:
            field_dict["from"] = from_
        if last_page is not UNSET:
            field_dict["last_page"] = last_page
        if last_page_url is not UNSET:
            field_dict["last_page_url"] = last_page_url
        if next_page_url is not UNSET:
            field_dict["next_page_url"] = next_page_url
        if path is not UNSET:
            field_dict["path"] = path
        if per_page is not UNSET:
            field_dict["per_page"] = per_page
        if prev_page_url is not UNSET:
            field_dict["prev_page_url"] = prev_page_url
        if to is not UNSET:
            field_dict["to"] = to
        if total is not UNSET:
            field_dict["total"] = total

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_conversations_response_200_data_data_item import GetConversationsResponse200DataDataItem

        current_page = src_dict.get("current_page")

        data = []
        _data = src_dict.get("data")
        for data_item_data in _data or []:
            data_item = GetConversationsResponse200DataDataItem.from_dict(data_item_data)

            data.append(data_item)

        first_page_url = src_dict.get("first_page_url")

        from_ = src_dict.get("from")

        last_page = src_dict.get("last_page")

        last_page_url = src_dict.get("last_page_url")

        next_page_url = src_dict.get("next_page_url")

        path = src_dict.get("path")

        per_page = src_dict.get("per_page")

        prev_page_url = src_dict.get("prev_page_url")

        to = src_dict.get("to")

        total = src_dict.get("total")

        get_conversations_response_200_data = cls(
            current_page=current_page,
            data=data,
            first_page_url=first_page_url,
            from_=from_,
            last_page=last_page,
            last_page_url=last_page_url,
            next_page_url=next_page_url,
            path=path,
            per_page=per_page,
            prev_page_url=prev_page_url,
            to=to,
            total=total,
        )

        get_conversations_response_200_data.additional_properties = src_dict
        return get_conversations_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_200_data_data_item.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetConversationsResponse200DataDataItem")


@attr.s(auto_attribs=True)
class GetConversationsResponse200DataDataItem:
    """
    Attributes:
        created_at (Union[Unset, datetime.datetime]): When was this conversation created? Example: 2023-04-30 16:43:53.
        updated_at (Union[Unset, datetime.datetime]): When was this conversation updated? Example: 2023-04-30 16:43:53.
        deleted_at (Union[Unset, None, datetime.datetime]): When was this conversation deleted? Example: 2023-04-30
            16:43:53.
        id (Union[Unset, int]): Conversation ID Example: 1.
        name (Union[Unset, str]): Conversation name Example: Conversation 1.
        project_id (Union[Unset, str]): Project ID for this conversation Example: 1.
        created_by (Union[Unset, str]): User ID for the user who created this conversation Example: 1.
        session_id (Union[Unset, str]): Session ID for this conversation Example: f1b9aaf0-5e4e-11eb-ae93-0242ac130002.
    """

    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    id: Union[Unset, int] = UNSET
    name: Union[Unset, str] = UNSET
    project_id: Union[Unset, str] = UNSET
    created_by: Union[Unset, str] = UNSET
    session_id: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        id = self.id
        name = self.name
        project_id = self.project_id
        created_by = self.created_by
        session_id = self.session_id

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at
        if id is not UNSET:
            field_dict["id"] = id
        if name is not UNSET:
            field_dict["name"] = name
        if project_id is not UNSET:
            field_dict["project_id"] = project_id
        if created_by is not UNSET:
            field_dict["created_by"] = created_by
        if session_id is not UNSET:
            field_dict["session_id"] = session_id

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        id = src_dict.get("id")

        name = src_dict.get("name")

        project_id = src_dict.get("project_id")

        created_by = src_dict.get("created_by")

        session_id = src_dict.get("session_id")

        get_conversations_response_200_data_data_item = cls(
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
            id=id,
            name=name,
            project_id=project_id,
            created_by=created_by,
            session_id=session_id,
        )

        get_conversations_response_200_data_data_item.additional_properties = src_dict
        return get_conversations_response_200_data_data_item

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_200_status.py:
```
from enum import Enum


class GetConversationsResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_conversations_response_400_data import GetConversationsResponse400Data


T = TypeVar("T", bound="GetConversationsResponse400")


@attr.s(auto_attribs=True)
class GetConversationsResponse400:
    """
    Attributes:
        status (Union[Unset, GetConversationsResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetConversationsResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetConversationsResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_conversations_response_400_data import GetConversationsResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetConversationsResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetConversationsResponse400Data.from_dict(_data)

        get_conversations_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_conversations_response_400.additional_properties = src_dict
        return get_conversations_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetConversationsResponse400Data")


@attr.s(auto_attribs=True)
class GetConversationsResponse400Data:
    """
    Attributes:
        code (Union[Unset, GetConversationsResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_conversations_response_400_data = cls(
            code=code,
            message=message,
        )

        get_conversations_response_400_data.additional_properties = src_dict
        return get_conversations_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_400_data_code.py:
```
from enum import IntEnum


class GetConversationsResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_400_status.py:
```
from enum import Enum


class GetConversationsResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_conversations_response_401_data import GetConversationsResponse401Data


T = TypeVar("T", bound="GetConversationsResponse401")


@attr.s(auto_attribs=True)
class GetConversationsResponse401:
    """
    Attributes:
        status (Union[Unset, GetConversationsResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetConversationsResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetConversationsResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_conversations_response_401_data import GetConversationsResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetConversationsResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetConversationsResponse401Data.from_dict(_data)

        get_conversations_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_conversations_response_401.additional_properties = src_dict
        return get_conversations_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetConversationsResponse401Data")


@attr.s(auto_attribs=True)
class GetConversationsResponse401Data:
    """
    Attributes:
        code (Union[Unset, GetConversationsResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_conversations_response_401_data = cls(
            code=code,
            message=message,
        )

        get_conversations_response_401_data.additional_properties = src_dict
        return get_conversations_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_401_data_code.py:
```
from enum import IntEnum


class GetConversationsResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_401_status.py:
```
from enum import Enum


class GetConversationsResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_conversations_response_404_data import GetConversationsResponse404Data


T = TypeVar("T", bound="GetConversationsResponse404")


@attr.s(auto_attribs=True)
class GetConversationsResponse404:
    """
    Attributes:
        status (Union[Unset, GetConversationsResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetConversationsResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetConversationsResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_conversations_response_404_data import GetConversationsResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetConversationsResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetConversationsResponse404Data.from_dict(_data)

        get_conversations_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_conversations_response_404.additional_properties = src_dict
        return get_conversations_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetConversationsResponse404Data")


@attr.s(auto_attribs=True)
class GetConversationsResponse404Data:
    """
    Attributes:
        code (Union[Unset, GetConversationsResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, GetConversationsResponse404DataMessage]): The error message Example: Project with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_conversations_response_404_data = cls(
            code=code,
            message=message,
        )

        get_conversations_response_404_data.additional_properties = src_dict
        return get_conversations_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_404_data_code.py:
```
from enum import IntEnum


class GetConversationsResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_404_data_message.py:
```
from enum import Enum


class GetConversationsResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_404_status.py:
```
from enum import Enum


class GetConversationsResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_conversations_response_500_data import GetConversationsResponse500Data


T = TypeVar("T", bound="GetConversationsResponse500")


@attr.s(auto_attribs=True)
class GetConversationsResponse500:
    """
    Attributes:
        status (Union[Unset, GetConversationsResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetConversationsResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetConversationsResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_conversations_response_500_data import GetConversationsResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetConversationsResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetConversationsResponse500Data.from_dict(_data)

        get_conversations_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_conversations_response_500.additional_properties = src_dict
        return get_conversations_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetConversationsResponse500Data")


@attr.s(auto_attribs=True)
class GetConversationsResponse500Data:
    """
    Attributes:
        code (Union[Unset, GetConversationsResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_conversations_response_500_data = cls(
            code=code,
            message=message,
        )

        get_conversations_response_500_data.additional_properties = src_dict
        return get_conversations_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_500_data_code.py:
```
from enum import IntEnum


class GetConversationsResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_conversations_response_500_status.py:
```
from enum import Enum


class GetConversationsResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_conversations_user_filter.py:
```
from enum import Enum


class GetConversationsUserFilter(str, Enum):
    ALL = "all"
    ANONYMOUS = "anonymous"
    TEAM_MEMBER = "team_member"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_page_metadata_response_200_data import GetPageMetadataResponse200Data


T = TypeVar("T", bound="GetPageMetadataResponse200")


@attr.s(auto_attribs=True)
class GetPageMetadataResponse200:
    """
    Attributes:
        status (Union[Unset, GetPageMetadataResponse200Status]): The status of the response Example: success.
        data (Union[Unset, GetPageMetadataResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "GetPageMetadataResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_page_metadata_response_200_data import GetPageMetadataResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, GetPageMetadataResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPageMetadataResponse200Data.from_dict(_data)

        get_page_metadata_response_200 = cls(
            status=status,
            data=data,
        )

        get_page_metadata_response_200.additional_properties = src_dict
        return get_page_metadata_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_200_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPageMetadataResponse200Data")


@attr.s(auto_attribs=True)
class GetPageMetadataResponse200Data:
    """
    Attributes:
        url (Union[Unset, str]): The URL of the page Example: https://www.example.com.
        title (Union[Unset, str]): The title of the page Example: Example Domain.
        description (Union[Unset, str]): The description of the page Example: This domain is for use in illustrative
            examples in documents. You may use this domain in literature without prior coordination or asking for
            permission..
        image (Union[Unset, str]): The image of the page Example: https://www.example.com/image.png.
    """

    url: Union[Unset, str] = UNSET
    title: Union[Unset, str] = UNSET
    description: Union[Unset, str] = UNSET
    image: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        url = self.url
        title = self.title
        description = self.description
        image = self.image

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if url is not UNSET:
            field_dict["url"] = url
        if title is not UNSET:
            field_dict["title"] = title
        if description is not UNSET:
            field_dict["description"] = description
        if image is not UNSET:
            field_dict["image"] = image

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        url = src_dict.get("url")

        title = src_dict.get("title")

        description = src_dict.get("description")

        image = src_dict.get("image")

        get_page_metadata_response_200_data = cls(
            url=url,
            title=title,
            description=description,
            image=image,
        )

        get_page_metadata_response_200_data.additional_properties = src_dict
        return get_page_metadata_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_200_status.py:
```
from enum import Enum


class GetPageMetadataResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_page_metadata_response_400_data import GetPageMetadataResponse400Data


T = TypeVar("T", bound="GetPageMetadataResponse400")


@attr.s(auto_attribs=True)
class GetPageMetadataResponse400:
    """
    Attributes:
        status (Union[Unset, GetPageMetadataResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetPageMetadataResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetPageMetadataResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_page_metadata_response_400_data import GetPageMetadataResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetPageMetadataResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPageMetadataResponse400Data.from_dict(_data)

        get_page_metadata_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_page_metadata_response_400.additional_properties = src_dict
        return get_page_metadata_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPageMetadataResponse400Data")


@attr.s(auto_attribs=True)
class GetPageMetadataResponse400Data:
    """
    Attributes:
        code (Union[Unset, GetPageMetadataResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Something went wrong..
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_page_metadata_response_400_data = cls(
            code=code,
            message=message,
        )

        get_page_metadata_response_400_data.additional_properties = src_dict
        return get_page_metadata_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_400_data_code.py:
```
from enum import IntEnum


class GetPageMetadataResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_400_status.py:
```
from enum import Enum


class GetPageMetadataResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_page_metadata_response_401_data import GetPageMetadataResponse401Data


T = TypeVar("T", bound="GetPageMetadataResponse401")


@attr.s(auto_attribs=True)
class GetPageMetadataResponse401:
    """
    Attributes:
        status (Union[Unset, GetPageMetadataResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetPageMetadataResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetPageMetadataResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_page_metadata_response_401_data import GetPageMetadataResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetPageMetadataResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPageMetadataResponse401Data.from_dict(_data)

        get_page_metadata_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_page_metadata_response_401.additional_properties = src_dict
        return get_page_metadata_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPageMetadataResponse401Data")


@attr.s(auto_attribs=True)
class GetPageMetadataResponse401Data:
    """
    Attributes:
        code (Union[Unset, GetPageMetadataResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_page_metadata_response_401_data = cls(
            code=code,
            message=message,
        )

        get_page_metadata_response_401_data.additional_properties = src_dict
        return get_page_metadata_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_401_data_code.py:
```
from enum import IntEnum


class GetPageMetadataResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_401_status.py:
```
from enum import Enum


class GetPageMetadataResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_page_metadata_response_404_data import GetPageMetadataResponse404Data


T = TypeVar("T", bound="GetPageMetadataResponse404")


@attr.s(auto_attribs=True)
class GetPageMetadataResponse404:
    """
    Attributes:
        status (Union[Unset, GetPageMetadataResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetPageMetadataResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetPageMetadataResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_page_metadata_response_404_data import GetPageMetadataResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetPageMetadataResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPageMetadataResponse404Data.from_dict(_data)

        get_page_metadata_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_page_metadata_response_404.additional_properties = src_dict
        return get_page_metadata_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPageMetadataResponse404Data")


@attr.s(auto_attribs=True)
class GetPageMetadataResponse404Data:
    """
    Attributes:
        code (Union[Unset, GetPageMetadataResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, GetPageMetadataResponse404DataMessage]): The error message Example: Page with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Page with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_page_metadata_response_404_data = cls(
            code=code,
            message=message,
        )

        get_page_metadata_response_404_data.additional_properties = src_dict
        return get_page_metadata_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_404_data_code.py:
```
from enum import IntEnum


class GetPageMetadataResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_404_data_message.py:
```
from enum import Enum


class GetPageMetadataResponse404DataMessage(str, Enum):
    PAGE_ID_IS_REQUIRED = "Page id is required"
    PAGE_WITH_ID_PAGEID_NOT_FOUND = "Page with id {pageId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_page_metadata_response_404_status.py:
```
from enum import Enum


class GetPageMetadataResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_order.py:
```
from enum import Enum


class GetPagesOrder(str, Enum):
    ASC = "asc"
    DESC = "desc"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_pages_response_200_data import GetPagesResponse200Data


T = TypeVar("T", bound="GetPagesResponse200")


@attr.s(auto_attribs=True)
class GetPagesResponse200:
    """
    Attributes:
        status (Union[Unset, GetPagesResponse200Status]): The status of the response Example: success.
        data (Union[Unset, GetPagesResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "GetPagesResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_pages_response_200_data import GetPagesResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, GetPagesResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPagesResponse200Data.from_dict(_data)

        get_pages_response_200 = cls(
            status=status,
            data=data,
        )

        get_pages_response_200.additional_properties = src_dict
        return get_pages_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_200_data.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_pages_response_200_data_pages import GetPagesResponse200DataPages
    from ..models.get_pages_response_200_data_project import GetPagesResponse200DataProject


T = TypeVar("T", bound="GetPagesResponse200Data")


@attr.s(auto_attribs=True)
class GetPagesResponse200Data:
    """
    Attributes:
        project (Union[Unset, GetPagesResponse200DataProject]):
        pages (Union[Unset, GetPagesResponse200DataPages]):
    """

    project: Union[Unset, "GetPagesResponse200DataProject"] = UNSET
    pages: Union[Unset, "GetPagesResponse200DataPages"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        project: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.project, Unset):
            project = self.project.to_dict()

        pages: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.pages, Unset):
            pages = self.pages.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if project is not UNSET:
            field_dict["project"] = project
        if pages is not UNSET:
            field_dict["pages"] = pages

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_pages_response_200_data_pages import GetPagesResponse200DataPages
        from ..models.get_pages_response_200_data_project import GetPagesResponse200DataProject

        _project = src_dict.get("project")
        project: Union[Unset, GetPagesResponse200DataProject]
        if isinstance(_project, Unset):
            project = UNSET
        else:
            project = GetPagesResponse200DataProject.from_dict(_project)

        _pages = src_dict.get("pages")
        pages: Union[Unset, GetPagesResponse200DataPages]
        if isinstance(_pages, Unset):
            pages = UNSET
        else:
            pages = GetPagesResponse200DataPages.from_dict(_pages)

        get_pages_response_200_data = cls(
            project=project,
            pages=pages,
        )

        get_pages_response_200_data.additional_properties = src_dict
        return get_pages_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_200_data_pages.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_pages_response_200_data_pages_data_item import GetPagesResponse200DataPagesDataItem


T = TypeVar("T", bound="GetPagesResponse200DataPages")


@attr.s(auto_attribs=True)
class GetPagesResponse200DataPages:
    """
    Attributes:
        current_page (Union[Unset, int]): The current page number Example: 1.
        data (Union[Unset, List['GetPagesResponse200DataPagesDataItem']]):
        first_page_url (Union[Unset, str]): The first page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        from_ (Union[Unset, int]): The first item number of the current page Example: 1.
        last_page (Union[Unset, int]): The last page number Example: 1.
        last_page_url (Union[Unset, str]): The last page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        next_page_url (Union[Unset, str]): The next page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        path (Union[Unset, str]): The current page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        per_page (Union[Unset, int]): The number of items per page Example: 10.
        prev_page_url (Union[Unset, str]): The previous page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        to (Union[Unset, int]): The last item number of the current page Example: 1.
        total (Union[Unset, int]): The total number of items Example: 1.
    """

    current_page: Union[Unset, int] = UNSET
    data: Union[Unset, List["GetPagesResponse200DataPagesDataItem"]] = UNSET
    first_page_url: Union[Unset, str] = UNSET
    from_: Union[Unset, int] = UNSET
    last_page: Union[Unset, int] = UNSET
    last_page_url: Union[Unset, str] = UNSET
    next_page_url: Union[Unset, str] = UNSET
    path: Union[Unset, str] = UNSET
    per_page: Union[Unset, int] = UNSET
    prev_page_url: Union[Unset, str] = UNSET
    to: Union[Unset, int] = UNSET
    total: Union[Unset, int] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        current_page = self.current_page
        data: Union[Unset, List[Dict[str, Any]]] = UNSET
        if not isinstance(self.data, Unset):
            data = []
            for data_item_data in self.data:
                data_item = data_item_data.to_dict()

                data.append(data_item)

        first_page_url = self.first_page_url
        from_ = self.from_
        last_page = self.last_page
        last_page_url = self.last_page_url
        next_page_url = self.next_page_url
        path = self.path
        per_page = self.per_page
        prev_page_url = self.prev_page_url
        to = self.to
        total = self.total

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if current_page is not UNSET:
            field_dict["current_page"] = current_page
        if data is not UNSET:
            for index, field_value in enumerate(data):
                field_dict[f"data[]"] = field_value
        if first_page_url is not UNSET:
            field_dict["first_page_url"] = first_page_url
        if from_ is not UNSET:
            field_dict["from"] = from_
        if last_page is not UNSET:
            field_dict["last_page"] = last_page
        if last_page_url is not UNSET:
            field_dict["last_page_url"] = last_page_url
        if next_page_url is not UNSET:
            field_dict["next_page_url"] = next_page_url
        if path is not UNSET:
            field_dict["path"] = path
        if per_page is not UNSET:
            field_dict["per_page"] = per_page
        if prev_page_url is not UNSET:
            field_dict["prev_page_url"] = prev_page_url
        if to is not UNSET:
            field_dict["to"] = to
        if total is not UNSET:
            field_dict["total"] = total

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_pages_response_200_data_pages_data_item import GetPagesResponse200DataPagesDataItem

        current_page = src_dict.get("current_page")

        data = []
        _data = src_dict.get("data")
        for data_item_data in _data or []:
            data_item = GetPagesResponse200DataPagesDataItem.from_dict(data_item_data)

            data.append(data_item)

        first_page_url = src_dict.get("first_page_url")

        from_ = src_dict.get("from")

        last_page = src_dict.get("last_page")

        last_page_url = src_dict.get("last_page_url")

        next_page_url = src_dict.get("next_page_url")

        path = src_dict.get("path")

        per_page = src_dict.get("per_page")

        prev_page_url = src_dict.get("prev_page_url")

        to = src_dict.get("to")

        total = src_dict.get("total")

        get_pages_response_200_data_pages = cls(
            current_page=current_page,
            data=data,
            first_page_url=first_page_url,
            from_=from_,
            last_page=last_page,
            last_page_url=last_page_url,
            next_page_url=next_page_url,
            path=path,
            per_page=per_page,
            prev_page_url=prev_page_url,
            to=to,
            total=total,
        )

        get_pages_response_200_data_pages.additional_properties = src_dict
        return get_pages_response_200_data_pages

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_200_data_pages_data_item.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPagesResponse200DataPagesDataItem")


@attr.s(auto_attribs=True)
class GetPagesResponse200DataPagesDataItem:
    r"""
    Attributes:
        id (Union[Unset, int]): Page ID Example: 1.
        page_url (Union[Unset, str]): URL of the page or file Example: https://example.com.
        page_url_hash (Union[Unset, str]): Hash of the URL of the page or file Example:
            d41d8cd98f00b204e9800998ecf8427e.
        project_id (Union[Unset, int]): Project ID Example: 1.
        s3_path (Union[Unset, None, str]): This is the path where the page is stored in S3.\nNote: This is omitted in
            the response if the page is not a file Example: project-1/page-1/file.pdf.
        crawl_status (Union[Unset, GetPagesResponse200DataPagesDataItemCrawlStatus]): Crawl status of the page Default:
            GetPagesResponse200DataPagesDataItemCrawlStatus.QUEUED. Example: queued.
        index_status (Union[Unset, GetPagesResponse200DataPagesDataItemIndexStatus]): Index status of the page Default:
            GetPagesResponse200DataPagesDataItemIndexStatus.QUEUED. Example: queued.
        is_file (Union[Unset, bool]): Whether the page is a file or not Example: True.
        is_file_kept (Union[Unset, bool]): Whether the file is kept after processing or not.\nNote: This is omitted in
            the response if the page is not a file Default: True. Example: True.
        filename (Union[Unset, None, str]): Filename of the page.\nNote: This is omitted in the response if the page is
            not a file Example: file.pdf.
        filesize (Union[Unset, None, int]): Filesize of the page.\nNote: This is omitted in the response if the page is
            not a file Example: 100.
        created_at (Union[Unset, datetime.datetime]): Date and time when the page was created Example: 2021-01-01
            00:00:00.
        updated_at (Union[Unset, datetime.datetime]): Date and time when the page was updated Example: 2021-01-01
            00:00:00.
        deleted_at (Union[Unset, None, datetime.datetime]): Date and time when the page was deleted Example: 2021-01-01
            00:00:00.
    """

    id: Union[Unset, int] = UNSET
    page_url: Union[Unset, str] = UNSET
    page_url_hash: Union[Unset, str] = UNSET
    project_id: Union[Unset, int] = UNSET
    s3_path: Union[Unset, None, str] = UNSET
    crawl_status: Union[Unset, str] = "queued"
    index_status: Union[Unset, str] = "queued"
    is_file: Union[Unset, bool] = False
    is_file_kept: Union[Unset, bool] = True
    filename: Union[Unset, None, str] = UNSET
    filesize: Union[Unset, None, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        page_url = self.page_url
        page_url_hash = self.page_url_hash
        project_id = self.project_id
        s3_path = self.s3_path
        crawl_status: Union[Unset, str] = UNSET
        if not isinstance(self.crawl_status, Unset):
            crawl_status = self.crawl_status

        index_status: Union[Unset, str] = UNSET
        if not isinstance(self.index_status, Unset):
            index_status = self.index_status

        is_file = self.is_file
        is_file_kept = self.is_file_kept
        filename = self.filename
        filesize = self.filesize
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if page_url is not UNSET:
            field_dict["page_url"] = page_url
        if page_url_hash is not UNSET:
            field_dict["page_url_hash"] = page_url_hash
        if project_id is not UNSET:
            field_dict["project_id"] = project_id
        if s3_path is not UNSET:
            field_dict["s3_path"] = s3_path
        if crawl_status is not UNSET:
            field_dict["crawl_status"] = crawl_status
        if index_status is not UNSET:
            field_dict["index_status"] = index_status
        if is_file is not UNSET:
            field_dict["is_file"] = is_file
        if is_file_kept is not UNSET:
            field_dict["is_file_kept"] = is_file_kept
        if filename is not UNSET:
            field_dict["filename"] = filename
        if filesize is not UNSET:
            field_dict["filesize"] = filesize
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        id = src_dict.get("id")

        page_url = src_dict.get("page_url")

        page_url_hash = src_dict.get("page_url_hash")

        project_id = src_dict.get("project_id")

        s3_path = src_dict.get("s3_path")

        crawl_status = src_dict.get("crawl_status")

        index_status = src_dict.get("index_status")

        is_file = src_dict.get("is_file")

        is_file_kept = src_dict.get("is_file_kept")

        filename = src_dict.get("filename")

        filesize = src_dict.get("filesize")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        get_pages_response_200_data_pages_data_item = cls(
            id=id,
            page_url=page_url,
            page_url_hash=page_url_hash,
            project_id=project_id,
            s3_path=s3_path,
            crawl_status=crawl_status,
            index_status=index_status,
            is_file=is_file,
            is_file_kept=is_file_kept,
            filename=filename,
            filesize=filesize,
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
        )

        get_pages_response_200_data_pages_data_item.additional_properties = src_dict
        return get_pages_response_200_data_pages_data_item

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_200_data_pages_data_item_crawl_status.py:
```
from enum import Enum


class GetPagesResponse200DataPagesDataItemCrawlStatus(str, Enum):
    FAILED = "failed"
    LIMITED = "limited"
    NA = "n/a"
    OK = "ok"
    QUEUED = "queued"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_200_data_pages_data_item_index_status.py:
```
from enum import Enum


class GetPagesResponse200DataPagesDataItemIndexStatus(str, Enum):
    FAILED = "failed"
    LIMITED = "limited"
    NA = "n/a"
    OK = "ok"
    QUEUED = "queued"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_200_data_project.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPagesResponse200DataProject")


@attr.s(auto_attribs=True)
class GetPagesResponse200DataProject:
    """
    Attributes:
        id (Union[Unset, int]): Project ID Example: 1.
        project_name (Union[Unset, str]): Project name Example: My Project.
        sitemap_path (Union[Unset, str]): Project sitemap Example: https://www.example.com/sitemap.xml.
        is_chat_active (Union[Unset, bool]): Whether the chat bot is active or not Example: True.
        user_id (Union[Unset, int]): User ID of the project owner Example: 1.
        created_at (Union[Unset, datetime.datetime]): Date and time when the project was created Default:
            isoparse('2023-05-08 13:06:55'). Example: 2021-01-01 00:00:00.
        updated_at (Union[Unset, datetime.datetime]): Date and time when the project was last updated Default:
            isoparse('2023-05-08 13:06:55'). Example: 2021-01-01 00:00:00.
        deleted_at (Union[Unset, None, datetime.datetime]): Date and time when the project was deleted Example:
            2021-01-01 00:00:00.
        type (Union[Unset, GetPagesResponse200DataProjectType]): Project type Default:
            GetPagesResponse200DataProjectType.SITEMAP. Example: SITEMAP.
        is_shared (Union[Unset, bool]): Whether the project is shared or not Example: True.
        shareable_slug (Union[Unset, None, str]): Shareable slug that can be used to share the project Example:
            1234567890abcdef1234567890abcdef.
        shareable_link (Union[Unset, None, str]): Shareable link that can be used to share the project
        embed_code (Union[Unset, None, str]): Embed code that can be used to embed the project
        live_chat_code (Union[Unset, None, str]): Live chat code that can be used to embed the live chat
    """

    id: Union[Unset, int] = UNSET
    project_name: Union[Unset, str] = UNSET
    sitemap_path: Union[Unset, str] = UNSET
    is_chat_active: Union[Unset, bool] = False
    user_id: Union[Unset, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = isoparse("2023-05-08 13:06:55")
    updated_at: Union[Unset, datetime.datetime] = isoparse("2023-05-08 13:06:55")
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    type: Union[Unset, str] = "SITEMAP"
    is_shared: Union[Unset, bool] = False
    shareable_slug: Union[Unset, None, str] = UNSET
    shareable_link: Union[Unset, None, str] = UNSET
    embed_code: Union[Unset, None, str] = UNSET
    live_chat_code: Union[Unset, None, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        project_name = self.project_name
        sitemap_path = self.sitemap_path
        is_chat_active = self.is_chat_active
        user_id = self.user_id
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        type: Union[Unset, str] = UNSET
        if not isinstance(self.type, Unset):
            type = self.type

        is_shared = self.is_shared
        shareable_slug = self.shareable_slug
        shareable_link = self.shareable_link
        embed_code = self.embed_code
        live_chat_code = self.live_chat_code

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if project_name is not UNSET:
            field_dict["project_name"] = project_name
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path
        if is_chat_active is not UNSET:
            field_dict["is_chat_active"] = is_chat_active
        if user_id is not UNSET:
            field_dict["user_id"] = user_id
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at
        if type is not UNSET:
            field_dict["type"] = type
        if is_shared is not UNSET:
            field_dict["is_shared"] = is_shared
        if shareable_slug is not UNSET:
            field_dict["shareable_slug"] = shareable_slug
        if shareable_link is not UNSET:
            field_dict["shareable_link"] = shareable_link
        if embed_code is not UNSET:
            field_dict["embed_code"] = embed_code
        if live_chat_code is not UNSET:
            field_dict["live_chat_code"] = live_chat_code

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        id = src_dict.get("id")

        project_name = src_dict.get("project_name")

        sitemap_path = src_dict.get("sitemap_path")

        is_chat_active = src_dict.get("is_chat_active")

        user_id = src_dict.get("user_id")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        type = src_dict.get("type")

        is_shared = src_dict.get("is_shared")

        shareable_slug = src_dict.get("shareable_slug")

        shareable_link = src_dict.get("shareable_link")

        embed_code = src_dict.get("embed_code")

        live_chat_code = src_dict.get("live_chat_code")

        get_pages_response_200_data_project = cls(
            id=id,
            project_name=project_name,
            sitemap_path=sitemap_path,
            is_chat_active=is_chat_active,
            user_id=user_id,
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
            type=type,
            is_shared=is_shared,
            shareable_slug=shareable_slug,
            shareable_link=shareable_link,
            embed_code=embed_code,
            live_chat_code=live_chat_code,
        )

        get_pages_response_200_data_project.additional_properties = src_dict
        return get_pages_response_200_data_project

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_200_data_project_type.py:
```
from enum import Enum


class GetPagesResponse200DataProjectType(str, Enum):
    SITEMAP = "SITEMAP"
    URL = "URL"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_200_status.py:
```
from enum import Enum


class GetPagesResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_pages_response_400_data import GetPagesResponse400Data


T = TypeVar("T", bound="GetPagesResponse400")


@attr.s(auto_attribs=True)
class GetPagesResponse400:
    """
    Attributes:
        status (Union[Unset, GetPagesResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetPagesResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetPagesResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_pages_response_400_data import GetPagesResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetPagesResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPagesResponse400Data.from_dict(_data)

        get_pages_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_pages_response_400.additional_properties = src_dict
        return get_pages_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPagesResponse400Data")


@attr.s(auto_attribs=True)
class GetPagesResponse400Data:
    """
    Attributes:
        code (Union[Unset, GetPagesResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_pages_response_400_data = cls(
            code=code,
            message=message,
        )

        get_pages_response_400_data.additional_properties = src_dict
        return get_pages_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_400_data_code.py:
```
from enum import IntEnum


class GetPagesResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_400_status.py:
```
from enum import Enum


class GetPagesResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_pages_response_401_data import GetPagesResponse401Data


T = TypeVar("T", bound="GetPagesResponse401")


@attr.s(auto_attribs=True)
class GetPagesResponse401:
    """
    Attributes:
        status (Union[Unset, GetPagesResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetPagesResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetPagesResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_pages_response_401_data import GetPagesResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetPagesResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPagesResponse401Data.from_dict(_data)

        get_pages_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_pages_response_401.additional_properties = src_dict
        return get_pages_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPagesResponse401Data")


@attr.s(auto_attribs=True)
class GetPagesResponse401Data:
    """
    Attributes:
        code (Union[Unset, GetPagesResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_pages_response_401_data = cls(
            code=code,
            message=message,
        )

        get_pages_response_401_data.additional_properties = src_dict
        return get_pages_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_401_data_code.py:
```
from enum import IntEnum


class GetPagesResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_401_status.py:
```
from enum import Enum


class GetPagesResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_pages_response_404_data import GetPagesResponse404Data


T = TypeVar("T", bound="GetPagesResponse404")


@attr.s(auto_attribs=True)
class GetPagesResponse404:
    """
    Attributes:
        status (Union[Unset, GetPagesResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetPagesResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetPagesResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_pages_response_404_data import GetPagesResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetPagesResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPagesResponse404Data.from_dict(_data)

        get_pages_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_pages_response_404.additional_properties = src_dict
        return get_pages_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPagesResponse404Data")


@attr.s(auto_attribs=True)
class GetPagesResponse404Data:
    """
    Attributes:
        code (Union[Unset, GetPagesResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, GetPagesResponse404DataMessage]): The error message Example: Project with id 1 not found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_pages_response_404_data = cls(
            code=code,
            message=message,
        )

        get_pages_response_404_data.additional_properties = src_dict
        return get_pages_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_404_data_code.py:
```
from enum import IntEnum


class GetPagesResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_404_data_message.py:
```
from enum import Enum


class GetPagesResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_404_status.py:
```
from enum import Enum


class GetPagesResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_pages_response_500_data import GetPagesResponse500Data


T = TypeVar("T", bound="GetPagesResponse500")


@attr.s(auto_attribs=True)
class GetPagesResponse500:
    """
    Attributes:
        status (Union[Unset, GetPagesResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetPagesResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetPagesResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_pages_response_500_data import GetPagesResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetPagesResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPagesResponse500Data.from_dict(_data)

        get_pages_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_pages_response_500.additional_properties = src_dict
        return get_pages_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPagesResponse500Data")


@attr.s(auto_attribs=True)
class GetPagesResponse500Data:
    """
    Attributes:
        code (Union[Unset, GetPagesResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_pages_response_500_data = cls(
            code=code,
            message=message,
        )

        get_pages_response_500_data.additional_properties = src_dict
        return get_pages_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_500_data_code.py:
```
from enum import IntEnum


class GetPagesResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_pages_response_500_status.py:
```
from enum import Enum


class GetPagesResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_plugin_response_200_data import GetPluginResponse200Data


T = TypeVar("T", bound="GetPluginResponse200")


@attr.s(auto_attribs=True)
class GetPluginResponse200:
    """
    Attributes:
        status (Union[Unset, GetPluginResponse200Status]): The status of the response Example: success.
        data (Union[Unset, GetPluginResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "GetPluginResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_plugin_response_200_data import GetPluginResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, GetPluginResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPluginResponse200Data.from_dict(_data)

        get_plugin_response_200 = cls(
            status=status,
            data=data,
        )

        get_plugin_response_200.additional_properties = src_dict
        return get_plugin_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_200_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPluginResponse200Data")


@attr.s(auto_attribs=True)
class GetPluginResponse200Data:
    """
    Attributes:
        model_name (Union[Unset, str]): Model Name Example: IndoorPlants.
        human_name (Union[Unset, str]): Name For Human Example: The Indoor Plants Channel.
        keywords (Union[Unset, str]): Keywords For Model Example: Indoor plants, Gardening, Trusted information..
        description (Union[Unset, str]): Description For Human Example: Trusted information about indoor plants and
            gardening..
        logo (Union[Unset, str]): Project plugin logo Example: https://app.customgpt.ai/logo.svg.
        is_active (Union[Unset, bool]): Whether the project plugin is active or not Example: True.
    """

    model_name: Union[Unset, str] = UNSET
    human_name: Union[Unset, str] = UNSET
    keywords: Union[Unset, str] = UNSET
    description: Union[Unset, str] = UNSET
    logo: Union[Unset, str] = UNSET
    is_active: Union[Unset, bool] = False
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        model_name = self.model_name
        human_name = self.human_name
        keywords = self.keywords
        description = self.description
        logo = self.logo
        is_active = self.is_active

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if model_name is not UNSET:
            field_dict["model_name"] = model_name
        if human_name is not UNSET:
            field_dict["human_name"] = human_name
        if keywords is not UNSET:
            field_dict["keywords"] = keywords
        if description is not UNSET:
            field_dict["description"] = description
        if logo is not UNSET:
            field_dict["logo"] = logo
        if is_active is not UNSET:
            field_dict["is_active"] = is_active

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        model_name = src_dict.get("model_name")

        human_name = src_dict.get("human_name")

        keywords = src_dict.get("keywords")

        description = src_dict.get("description")

        logo = src_dict.get("logo")

        is_active = src_dict.get("is_active")

        get_plugin_response_200_data = cls(
            model_name=model_name,
            human_name=human_name,
            keywords=keywords,
            description=description,
            logo=logo,
            is_active=is_active,
        )

        get_plugin_response_200_data.additional_properties = src_dict
        return get_plugin_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_200_status.py:
```
from enum import Enum


class GetPluginResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_plugin_response_400_data import GetPluginResponse400Data


T = TypeVar("T", bound="GetPluginResponse400")


@attr.s(auto_attribs=True)
class GetPluginResponse400:
    """
    Attributes:
        status (Union[Unset, GetPluginResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetPluginResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetPluginResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_plugin_response_400_data import GetPluginResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetPluginResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPluginResponse400Data.from_dict(_data)

        get_plugin_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_plugin_response_400.additional_properties = src_dict
        return get_plugin_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPluginResponse400Data")


@attr.s(auto_attribs=True)
class GetPluginResponse400Data:
    """
    Attributes:
        code (Union[Unset, GetPluginResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_plugin_response_400_data = cls(
            code=code,
            message=message,
        )

        get_plugin_response_400_data.additional_properties = src_dict
        return get_plugin_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_400_data_code.py:
```
from enum import IntEnum


class GetPluginResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_400_status.py:
```
from enum import Enum


class GetPluginResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_plugin_response_401_data import GetPluginResponse401Data


T = TypeVar("T", bound="GetPluginResponse401")


@attr.s(auto_attribs=True)
class GetPluginResponse401:
    """
    Attributes:
        status (Union[Unset, GetPluginResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetPluginResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetPluginResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_plugin_response_401_data import GetPluginResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetPluginResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPluginResponse401Data.from_dict(_data)

        get_plugin_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_plugin_response_401.additional_properties = src_dict
        return get_plugin_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPluginResponse401Data")


@attr.s(auto_attribs=True)
class GetPluginResponse401Data:
    """
    Attributes:
        code (Union[Unset, GetPluginResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_plugin_response_401_data = cls(
            code=code,
            message=message,
        )

        get_plugin_response_401_data.additional_properties = src_dict
        return get_plugin_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_401_data_code.py:
```
from enum import IntEnum


class GetPluginResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_401_status.py:
```
from enum import Enum


class GetPluginResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_plugin_response_404_data import GetPluginResponse404Data


T = TypeVar("T", bound="GetPluginResponse404")


@attr.s(auto_attribs=True)
class GetPluginResponse404:
    """
    Attributes:
        status (Union[Unset, GetPluginResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetPluginResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetPluginResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_plugin_response_404_data import GetPluginResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetPluginResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPluginResponse404Data.from_dict(_data)

        get_plugin_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_plugin_response_404.additional_properties = src_dict
        return get_plugin_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPluginResponse404Data")


@attr.s(auto_attribs=True)
class GetPluginResponse404Data:
    """
    Attributes:
        code (Union[Unset, GetPluginResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, GetPluginResponse404DataMessage]): The error message Example: Project plugin with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project plugin with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_plugin_response_404_data = cls(
            code=code,
            message=message,
        )

        get_plugin_response_404_data.additional_properties = src_dict
        return get_plugin_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_404_data_code.py:
```
from enum import IntEnum


class GetPluginResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_404_data_message.py:
```
from enum import Enum


class GetPluginResponse404DataMessage(str, Enum):
    PLUGIN_FOR_PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Plugin for project with id {projectId} not found"
    PROJECT_PLUGIN_ID_IS_REQUIRED = "Project plugin id is required"
    PROJECT_PLUGIN_WITH_ID_PLUGINID_NOT_FOUND = "Project plugin with id {pluginId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_404_status.py:
```
from enum import Enum


class GetPluginResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_plugin_response_500_data import GetPluginResponse500Data


T = TypeVar("T", bound="GetPluginResponse500")


@attr.s(auto_attribs=True)
class GetPluginResponse500:
    """
    Attributes:
        status (Union[Unset, GetPluginResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetPluginResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetPluginResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_plugin_response_500_data import GetPluginResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetPluginResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetPluginResponse500Data.from_dict(_data)

        get_plugin_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_plugin_response_500.additional_properties = src_dict
        return get_plugin_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetPluginResponse500Data")


@attr.s(auto_attribs=True)
class GetPluginResponse500Data:
    """
    Attributes:
        code (Union[Unset, GetPluginResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_plugin_response_500_data = cls(
            code=code,
            message=message,
        )

        get_plugin_response_500_data.additional_properties = src_dict
        return get_plugin_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_500_data_code.py:
```
from enum import IntEnum


class GetPluginResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_plugin_response_500_status.py:
```
from enum import Enum


class GetPluginResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_project_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_project_response_200_data import GetProjectResponse200Data


T = TypeVar("T", bound="GetProjectResponse200")


@attr.s(auto_attribs=True)
class GetProjectResponse200:
    """
    Attributes:
        status (Union[Unset, GetProjectResponse200Status]): The status of the response Example: success.
        data (Union[Unset, GetProjectResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "GetProjectResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_project_response_200_data import GetProjectResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, GetProjectResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetProjectResponse200Data.from_dict(_data)

        get_project_response_200 = cls(
            status=status,
            data=data,
        )

        get_project_response_200.additional_properties = src_dict
        return get_project_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_project_response_200_data.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetProjectResponse200Data")


@attr.s(auto_attribs=True)
class GetProjectResponse200Data:
    """
    Attributes:
        id (Union[Unset, int]): Project ID Example: 1.
        project_name (Union[Unset, str]): Project name Example: My Project.
        sitemap_path (Union[Unset, str]): Project sitemap Example: https://www.example.com/sitemap.xml.
        is_chat_active (Union[Unset, bool]): Whether the chat bot is active or not Example: True.
        user_id (Union[Unset, int]): User ID of the project owner Example: 1.
        created_at (Union[Unset, datetime.datetime]): Date and time when the project was created Default:
            isoparse('2023-05-08 13:06:55'). Example: 2021-01-01 00:00:00.
        updated_at (Union[Unset, datetime.datetime]): Date and time when the project was last updated Default:
            isoparse('2023-05-08 13:06:55'). Example: 2021-01-01 00:00:00.
        deleted_at (Union[Unset, None, datetime.datetime]): Date and time when the project was deleted Example:
            2021-01-01 00:00:00.
        type (Union[Unset, GetProjectResponse200DataType]): Project type Default: GetProjectResponse200DataType.SITEMAP.
            Example: SITEMAP.
        is_shared (Union[Unset, bool]): Whether the project is shared or not Example: True.
        shareable_slug (Union[Unset, None, str]): Shareable slug that can be used to share the project Example:
            1234567890abcdef1234567890abcdef.
        shareable_link (Union[Unset, None, str]): Shareable link that can be used to share the project
        embed_code (Union[Unset, None, str]): Embed code that can be used to embed the project
        live_chat_code (Union[Unset, None, str]): Live chat code that can be used to embed the live chat
    """

    id: Union[Unset, int] = UNSET
    project_name: Union[Unset, str] = UNSET
    sitemap_path: Union[Unset, str] = UNSET
    is_chat_active: Union[Unset, bool] = False
    user_id: Union[Unset, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = isoparse("2023-05-08 13:06:55")
    updated_at: Union[Unset, datetime.datetime] = isoparse("2023-05-08 13:06:55")
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    type: Union[Unset, str] = "SITEMAP"
    is_shared: Union[Unset, bool] = False
    shareable_slug: Union[Unset, None, str] = UNSET
    shareable_link: Union[Unset, None, str] = UNSET
    embed_code: Union[Unset, None, str] = UNSET
    live_chat_code: Union[Unset, None, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        project_name = self.project_name
        sitemap_path = self.sitemap_path
        is_chat_active = self.is_chat_active
        user_id = self.user_id
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        type: Union[Unset, str] = UNSET
        if not isinstance(self.type, Unset):
            type = self.type

        is_shared = self.is_shared
        shareable_slug = self.shareable_slug
        shareable_link = self.shareable_link
        embed_code = self.embed_code
        live_chat_code = self.live_chat_code

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if project_name is not UNSET:
            field_dict["project_name"] = project_name
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path
        if is_chat_active is not UNSET:
            field_dict["is_chat_active"] = is_chat_active
        if user_id is not UNSET:
            field_dict["user_id"] = user_id
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at
        if type is not UNSET:
            field_dict["type"] = type
        if is_shared is not UNSET:
            field_dict["is_shared"] = is_shared
        if shareable_slug is not UNSET:
            field_dict["shareable_slug"] = shareable_slug
        if shareable_link is not UNSET:
            field_dict["shareable_link"] = shareable_link
        if embed_code is not UNSET:
            field_dict["embed_code"] = embed_code
        if live_chat_code is not UNSET:
            field_dict["live_chat_code"] = live_chat_code

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        id = src_dict.get("id")

        project_name = src_dict.get("project_name")

        sitemap_path = src_dict.get("sitemap_path")

        is_chat_active = src_dict.get("is_chat_active")

        user_id = src_dict.get("user_id")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        type = src_dict.get("type")

        is_shared = src_dict.get("is_shared")

        shareable_slug = src_dict.get("shareable_slug")

        shareable_link = src_dict.get("shareable_link")

        embed_code = src_dict.get("embed_code")

        live_chat_code = src_dict.get("live_chat_code")

        get_project_response_200_data = cls(
            id=id,
            project_name=project_name,
            sitemap_path=sitemap_path,
            is_chat_active=is_chat_active,
            user_id=user_id,
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
            type=type,
            is_shared=is_shared,
            shareable_slug=shareable_slug,
            shareable_link=shareable_link,
            embed_code=embed_code,
            live_chat_code=live_chat_code,
        )

        get_project_response_200_data.additional_properties = src_dict
        return get_project_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_project_response_200_data_type.py:
```
from enum import Enum


class GetProjectResponse200DataType(str, Enum):
    SITEMAP = "SITEMAP"
    URL = "URL"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_project_response_200_status.py:
```
from enum import Enum


class GetProjectResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_project_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_project_response_400_data import GetProjectResponse400Data


T = TypeVar("T", bound="GetProjectResponse400")


@attr.s(auto_attribs=True)
class GetProjectResponse400:
    """
    Attributes:
        status (Union[Unset, GetProjectResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetProjectResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetProjectResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_project_response_400_data import GetProjectResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetProjectResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetProjectResponse400Data.from_dict(_data)

        get_project_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_project_response_400.additional_properties = src_dict
        return get_project_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_project_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetProjectResponse400Data")


@attr.s(auto_attribs=True)
class GetProjectResponse400Data:
    """
    Attributes:
        code (Union[Unset, GetProjectResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_project_response_400_data = cls(
            code=code,
            message=message,
        )

        get_project_response_400_data.additional_properties = src_dict
        return get_project_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_project_response_400_data_code.py:
```
from enum import IntEnum


class GetProjectResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_project_response_400_status.py:
```
from enum import Enum


class GetProjectResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_project_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_project_response_401_data import GetProjectResponse401Data


T = TypeVar("T", bound="GetProjectResponse401")


@attr.s(auto_attribs=True)
class GetProjectResponse401:
    """
    Attributes:
        status (Union[Unset, GetProjectResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetProjectResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetProjectResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_project_response_401_data import GetProjectResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetProjectResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetProjectResponse401Data.from_dict(_data)

        get_project_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_project_response_401.additional_properties = src_dict
        return get_project_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_project_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetProjectResponse401Data")


@attr.s(auto_attribs=True)
class GetProjectResponse401Data:
    """
    Attributes:
        code (Union[Unset, GetProjectResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_project_response_401_data = cls(
            code=code,
            message=message,
        )

        get_project_response_401_data.additional_properties = src_dict
        return get_project_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_project_response_401_data_code.py:
```
from enum import IntEnum


class GetProjectResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_project_response_401_status.py:
```
from enum import Enum


class GetProjectResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_project_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_project_response_404_data import GetProjectResponse404Data


T = TypeVar("T", bound="GetProjectResponse404")


@attr.s(auto_attribs=True)
class GetProjectResponse404:
    """
    Attributes:
        status (Union[Unset, GetProjectResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetProjectResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetProjectResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_project_response_404_data import GetProjectResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetProjectResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetProjectResponse404Data.from_dict(_data)

        get_project_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_project_response_404.additional_properties = src_dict
        return get_project_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_project_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetProjectResponse404Data")


@attr.s(auto_attribs=True)
class GetProjectResponse404Data:
    """
    Attributes:
        code (Union[Unset, GetProjectResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, GetProjectResponse404DataMessage]): The error message Example: Project with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_project_response_404_data = cls(
            code=code,
            message=message,
        )

        get_project_response_404_data.additional_properties = src_dict
        return get_project_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_project_response_404_data_code.py:
```
from enum import IntEnum


class GetProjectResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_project_response_404_data_message.py:
```
from enum import Enum


class GetProjectResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_project_response_404_status.py:
```
from enum import Enum


class GetProjectResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_project_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_project_response_500_data import GetProjectResponse500Data


T = TypeVar("T", bound="GetProjectResponse500")


@attr.s(auto_attribs=True)
class GetProjectResponse500:
    """
    Attributes:
        status (Union[Unset, GetProjectResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetProjectResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetProjectResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_project_response_500_data import GetProjectResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetProjectResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetProjectResponse500Data.from_dict(_data)

        get_project_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_project_response_500.additional_properties = src_dict
        return get_project_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_project_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetProjectResponse500Data")


@attr.s(auto_attribs=True)
class GetProjectResponse500Data:
    """
    Attributes:
        code (Union[Unset, GetProjectResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_project_response_500_data = cls(
            code=code,
            message=message,
        )

        get_project_response_500_data.additional_properties = src_dict
        return get_project_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_project_response_500_data_code.py:
```
from enum import IntEnum


class GetProjectResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_project_response_500_status.py:
```
from enum import Enum


class GetProjectResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_settings_response_200_data import GetSettingsResponse200Data


T = TypeVar("T", bound="GetSettingsResponse200")


@attr.s(auto_attribs=True)
class GetSettingsResponse200:
    """
    Attributes:
        status (Union[Unset, GetSettingsResponse200Status]): The status of the response Example: success.
        data (Union[Unset, GetSettingsResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "GetSettingsResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_settings_response_200_data import GetSettingsResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, GetSettingsResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetSettingsResponse200Data.from_dict(_data)

        get_settings_response_200 = cls(
            status=status,
            data=data,
        )

        get_settings_response_200.additional_properties = src_dict
        return get_settings_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_200_data.py:
```
from io import BytesIO
from typing import Any, Dict, List, Type, TypeVar, Union, cast

import attr

from ..types import UNSET, File, FileJsonType, Unset

T = TypeVar("T", bound="GetSettingsResponse200Data")


@attr.s(auto_attribs=True)
class GetSettingsResponse200Data:
    """
    Attributes:
        chat_bot_avatar (Union[Unset, File]): This is the avatar that is shown in the bot response. You can make it a
            profile picture or your company logo. Example: avatar.png.
        chat_bot_bg (Union[Unset, File]): This is the background image shown in the bot conversations widget. You can
            change it to a company logo or background image. Example: bg.png.
        default_prompt (Union[Unset, str]): This is the default prompt shown to the user. You can customize this for
            your company or client. Example: How can I help you?.
        example_questions (Union[Unset, List[str]]): These are example questions shown to guide the bot users. You can
            create customized questions to suit your company or client needs.
        response_source (Union[Unset, str]): By default, we ask ChatGPT to use only your content in its response
            (recommended). If you wish ChatGPT to improvise and use its own knowledgebase as well, you can select "My
            Content + ChatGPT" Example: own_content.
        chatbot_msg_lang (Union[Unset, str]): By default, the chatbot messages like 'Ask Me Anything' are in English.
            You can customize this to your preferred language. Please note: This setting does not control what language
            ChatGPT responds in. That is controlled by the user's question. So a user asking in Portuguese, will most likely
            get a response from ChatGPT in Portuguese. Example: en.
        chatbot_color (Union[Unset, str]): Color of the chatbot in hex format Example: #000000.
        persona_instructions (Union[Unset, None, str]): [Advanced Users] Customize your chatbot behavior by adjusting
            the system parameter to control its personality traits  and role. Example: You are a custom chatbot assistant
            called CustomGPT, a friendly lawyer who answers questions based on the given context..
        citations_answer_source_label_msg (Union[Unset, None, str]): This is the message shown to indicate where the
            response came from. You can customize this message based on your business or language. Example: Where did this
            answer come from?.
        citations_sources_label_msg (Union[Unset, None, str]): This is the message shown for the Sources label.  You can
            customize this message based on your business or language. Example: Sources.
        hang_in_there_msg (Union[Unset, None, str]): This is the message shown when the bot is thinking and waiting to
            answer. You can customize this message based on your tone, personality or language. Example: Hang in there! I'm
            thinking...
        chatbot_siesta_msg (Union[Unset, None, str]): This is the message shown when the bot has encountered a problem
            or error. You can customize this message based on your tone, personality or language. Example: Oops! The chat
            bot is taking a siesta. This usually happens when OpenAI is down! Please try again later..
        is_loading_indicator_enabled (Union[Unset, None, bool]): Show animated loading indicator while waiting for a
            response from the chatbot Default: True. Example: True.
        enable_citations (Union[Unset, None, bool]): Each chatbot response shows an option for the user to see the
            sources/citations from your content from which the response was generated. Default: True. Example: True.
        citations_view_type (Union[Unset, None, GetSettingsResponse200DataCitationsViewType]): Control how citations are
            shown. By default, the user can initiate to see the citations. You can choose to have it "Auto Shown" or "Auto
            Hide" Default: GetSettingsResponse200DataCitationsViewType.USER. Example: user.
        no_answer_message (Union[Unset, None, str]): This is the message shown when the bot cannot answer. You can
            customize it to a message asking the user to contact customer support or leave their email / phone. Example:
            Sorry, I don't have an answer for that..
        ending_message (Union[Unset, None, str]): You can instruct ChatGPT to end every response with some text like
            asking "Please email us for further support" (Not recommended for most use cases) Example: Please email us for
            further support.
        remove_branding (Union[Unset, None, bool]): Controls what branding is shown at the bottom of the chatbot.
    """

    chat_bot_avatar: Union[Unset, File] = UNSET
    chat_bot_bg: Union[Unset, File] = UNSET
    default_prompt: Union[Unset, str] = UNSET
    example_questions: Union[Unset, List[str]] = UNSET
    response_source: Union[Unset, str] = UNSET
    chatbot_msg_lang: Union[Unset, str] = UNSET
    chatbot_color: Union[Unset, str] = UNSET
    persona_instructions: Union[Unset, None, str] = UNSET
    citations_answer_source_label_msg: Union[Unset, None, str] = UNSET
    citations_sources_label_msg: Union[Unset, None, str] = UNSET
    hang_in_there_msg: Union[Unset, None, str] = UNSET
    chatbot_siesta_msg: Union[Unset, None, str] = UNSET
    is_loading_indicator_enabled: Union[Unset, None, bool] = True
    enable_citations: Union[Unset, None, bool] = True
    citations_view_type: Union[Unset, str] = "user"
    no_answer_message: Union[Unset, None, str] = UNSET
    ending_message: Union[Unset, None, str] = UNSET
    remove_branding: Union[Unset, None, bool] = False
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        chat_bot_avatar: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.chat_bot_avatar, Unset):
            chat_bot_avatar = self.chat_bot_avatar.to_tuple()

        chat_bot_bg: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.chat_bot_bg, Unset):
            chat_bot_bg = self.chat_bot_bg.to_tuple()

        default_prompt = self.default_prompt
        example_questions: Union[Unset, List[str]] = UNSET
        if not isinstance(self.example_questions, Unset):
            example_questions = self.example_questions

        response_source = self.response_source
        chatbot_msg_lang = self.chatbot_msg_lang
        chatbot_color = self.chatbot_color
        persona_instructions = self.persona_instructions
        citations_answer_source_label_msg = self.citations_answer_source_label_msg
        citations_sources_label_msg = self.citations_sources_label_msg
        hang_in_there_msg = self.hang_in_there_msg
        chatbot_siesta_msg = self.chatbot_siesta_msg
        is_loading_indicator_enabled = self.is_loading_indicator_enabled
        enable_citations = self.enable_citations
        citations_view_type: Union[Unset, None, str] = UNSET
        if not isinstance(self.citations_view_type, Unset):
            citations_view_type = self.citations_view_type if self.citations_view_type else None

        no_answer_message = self.no_answer_message
        ending_message = self.ending_message
        remove_branding = self.remove_branding

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if chat_bot_avatar is not UNSET:
            field_dict["chat_bot_avatar"] = chat_bot_avatar
        if chat_bot_bg is not UNSET:
            field_dict["chat_bot_bg"] = chat_bot_bg
        if default_prompt is not UNSET:
            field_dict["default_prompt"] = default_prompt
        if example_questions is not UNSET:
            for index, field_value in enumerate(example_questions):
                field_dict[f"example_questions[]"] = field_value
        if response_source is not UNSET:
            field_dict["response_source"] = response_source
        if chatbot_msg_lang is not UNSET:
            field_dict["chatbot_msg_lang"] = chatbot_msg_lang
        if chatbot_color is not UNSET:
            field_dict["chatbot_color"] = chatbot_color
        if persona_instructions is not UNSET:
            field_dict["persona_instructions"] = persona_instructions
        if citations_answer_source_label_msg is not UNSET:
            field_dict["citations_answer_source_label_msg"] = citations_answer_source_label_msg
        if citations_sources_label_msg is not UNSET:
            field_dict["citations_sources_label_msg"] = citations_sources_label_msg
        if hang_in_there_msg is not UNSET:
            field_dict["hang_in_there_msg"] = hang_in_there_msg
        if chatbot_siesta_msg is not UNSET:
            field_dict["chatbot_siesta_msg"] = chatbot_siesta_msg
        if is_loading_indicator_enabled is not UNSET:
            field_dict["is_loading_indicator_enabled"] = is_loading_indicator_enabled
        if enable_citations is not UNSET:
            field_dict["enable_citations"] = enable_citations
        if citations_view_type is not UNSET:
            field_dict["citations_view_type"] = citations_view_type
        if no_answer_message is not UNSET:
            field_dict["no_answer_message"] = no_answer_message
        if ending_message is not UNSET:
            field_dict["ending_message"] = ending_message
        if remove_branding is not UNSET:
            field_dict["remove_branding"] = remove_branding

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        _chat_bot_avatar = src_dict.get("chat_bot_avatar")
        chat_bot_avatar: Union[Unset, File]
        if isinstance(_chat_bot_avatar, Unset):
            chat_bot_avatar = UNSET
        else:
            chat_bot_avatar = File(payload=BytesIO(_chat_bot_avatar))

        _chat_bot_bg = src_dict.get("chat_bot_bg")
        chat_bot_bg: Union[Unset, File]
        if isinstance(_chat_bot_bg, Unset):
            chat_bot_bg = UNSET
        else:
            chat_bot_bg = File(payload=BytesIO(_chat_bot_bg))

        default_prompt = src_dict.get("default_prompt")

        example_questions = cast(List[str], src_dict.get("example_questions"))

        response_source = src_dict.get("response_source")

        chatbot_msg_lang = src_dict.get("chatbot_msg_lang")

        chatbot_color = src_dict.get("chatbot_color")

        persona_instructions = src_dict.get("persona_instructions")

        citations_answer_source_label_msg = src_dict.get("citations_answer_source_label_msg")

        citations_sources_label_msg = src_dict.get("citations_sources_label_msg")

        hang_in_there_msg = src_dict.get("hang_in_there_msg")

        chatbot_siesta_msg = src_dict.get("chatbot_siesta_msg")

        is_loading_indicator_enabled = src_dict.get("is_loading_indicator_enabled")

        enable_citations = src_dict.get("enable_citations")

        citations_view_type = src_dict.get("citations_view_type")

        no_answer_message = src_dict.get("no_answer_message")

        ending_message = src_dict.get("ending_message")

        remove_branding = src_dict.get("remove_branding")

        get_settings_response_200_data = cls(
            chat_bot_avatar=chat_bot_avatar,
            chat_bot_bg=chat_bot_bg,
            default_prompt=default_prompt,
            example_questions=example_questions,
            response_source=response_source,
            chatbot_msg_lang=chatbot_msg_lang,
            chatbot_color=chatbot_color,
            persona_instructions=persona_instructions,
            citations_answer_source_label_msg=citations_answer_source_label_msg,
            citations_sources_label_msg=citations_sources_label_msg,
            hang_in_there_msg=hang_in_there_msg,
            chatbot_siesta_msg=chatbot_siesta_msg,
            is_loading_indicator_enabled=is_loading_indicator_enabled,
            enable_citations=enable_citations,
            citations_view_type=citations_view_type,
            no_answer_message=no_answer_message,
            ending_message=ending_message,
            remove_branding=remove_branding,
        )

        get_settings_response_200_data.additional_properties = src_dict
        return get_settings_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_200_data_citations_view_type.py:
```
from enum import Enum


class GetSettingsResponse200DataCitationsViewType(str, Enum):
    HIDE = "hide"
    SHOW = "show"
    USER = "user"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_200_status.py:
```
from enum import Enum


class GetSettingsResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_settings_response_400_data import GetSettingsResponse400Data


T = TypeVar("T", bound="GetSettingsResponse400")


@attr.s(auto_attribs=True)
class GetSettingsResponse400:
    """
    Attributes:
        status (Union[Unset, GetSettingsResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetSettingsResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetSettingsResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_settings_response_400_data import GetSettingsResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetSettingsResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetSettingsResponse400Data.from_dict(_data)

        get_settings_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_settings_response_400.additional_properties = src_dict
        return get_settings_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetSettingsResponse400Data")


@attr.s(auto_attribs=True)
class GetSettingsResponse400Data:
    """
    Attributes:
        code (Union[Unset, GetSettingsResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_settings_response_400_data = cls(
            code=code,
            message=message,
        )

        get_settings_response_400_data.additional_properties = src_dict
        return get_settings_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_400_data_code.py:
```
from enum import IntEnum


class GetSettingsResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_400_status.py:
```
from enum import Enum


class GetSettingsResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_settings_response_401_data import GetSettingsResponse401Data


T = TypeVar("T", bound="GetSettingsResponse401")


@attr.s(auto_attribs=True)
class GetSettingsResponse401:
    """
    Attributes:
        status (Union[Unset, GetSettingsResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetSettingsResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetSettingsResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_settings_response_401_data import GetSettingsResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetSettingsResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetSettingsResponse401Data.from_dict(_data)

        get_settings_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_settings_response_401.additional_properties = src_dict
        return get_settings_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetSettingsResponse401Data")


@attr.s(auto_attribs=True)
class GetSettingsResponse401Data:
    """
    Attributes:
        code (Union[Unset, GetSettingsResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_settings_response_401_data = cls(
            code=code,
            message=message,
        )

        get_settings_response_401_data.additional_properties = src_dict
        return get_settings_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_401_data_code.py:
```
from enum import IntEnum


class GetSettingsResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_401_status.py:
```
from enum import Enum


class GetSettingsResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_settings_response_404_data import GetSettingsResponse404Data


T = TypeVar("T", bound="GetSettingsResponse404")


@attr.s(auto_attribs=True)
class GetSettingsResponse404:
    """
    Attributes:
        status (Union[Unset, GetSettingsResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetSettingsResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetSettingsResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_settings_response_404_data import GetSettingsResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetSettingsResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetSettingsResponse404Data.from_dict(_data)

        get_settings_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_settings_response_404.additional_properties = src_dict
        return get_settings_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetSettingsResponse404Data")


@attr.s(auto_attribs=True)
class GetSettingsResponse404Data:
    """
    Attributes:
        code (Union[Unset, GetSettingsResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, GetSettingsResponse404DataMessage]): The error message Example: Project with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_settings_response_404_data = cls(
            code=code,
            message=message,
        )

        get_settings_response_404_data.additional_properties = src_dict
        return get_settings_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_404_data_code.py:
```
from enum import IntEnum


class GetSettingsResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_404_data_message.py:
```
from enum import Enum


class GetSettingsResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_404_status.py:
```
from enum import Enum


class GetSettingsResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_settings_response_500_data import GetSettingsResponse500Data


T = TypeVar("T", bound="GetSettingsResponse500")


@attr.s(auto_attribs=True)
class GetSettingsResponse500:
    """
    Attributes:
        status (Union[Unset, GetSettingsResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetSettingsResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetSettingsResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_settings_response_500_data import GetSettingsResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetSettingsResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetSettingsResponse500Data.from_dict(_data)

        get_settings_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_settings_response_500.additional_properties = src_dict
        return get_settings_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetSettingsResponse500Data")


@attr.s(auto_attribs=True)
class GetSettingsResponse500Data:
    """
    Attributes:
        code (Union[Unset, GetSettingsResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_settings_response_500_data = cls(
            code=code,
            message=message,
        )

        get_settings_response_500_data.additional_properties = src_dict
        return get_settings_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_500_data_code.py:
```
from enum import IntEnum


class GetSettingsResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_settings_response_500_status.py:
```
from enum import Enum


class GetSettingsResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_user_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_user_response_200_data import GetUserResponse200Data


T = TypeVar("T", bound="GetUserResponse200")


@attr.s(auto_attribs=True)
class GetUserResponse200:
    """
    Attributes:
        status (Union[Unset, GetUserResponse200Status]): The status of the response Example: success.
        data (Union[Unset, GetUserResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "GetUserResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_user_response_200_data import GetUserResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, GetUserResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetUserResponse200Data.from_dict(_data)

        get_user_response_200 = cls(
            status=status,
            data=data,
        )

        get_user_response_200.additional_properties = src_dict
        return get_user_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_user_response_200_data.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetUserResponse200Data")


@attr.s(auto_attribs=True)
class GetUserResponse200Data:
    """
    Attributes:
        created_at (Union[Unset, datetime.datetime]): When was this user created? Example: 2023-04-30 16:43:53.
        email (Union[Unset, str]): User email Example: user@domain.com.
        id (Union[Unset, int]): User ID Example: 1.
        name (Union[Unset, str]): User name Example: John Doe.
        profile_photo_url (Union[Unset, str]): User profile photo URL Example:
            https://app.customgpt.ai/user/1/profile_photo_url.
        updated_at (Union[Unset, datetime.datetime]): When was this user updated? Example: 2023-04-30 16:43:53.
    """

    created_at: Union[Unset, datetime.datetime] = UNSET
    email: Union[Unset, str] = UNSET
    id: Union[Unset, int] = UNSET
    name: Union[Unset, str] = UNSET
    profile_photo_url: Union[Unset, str] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        email = self.email
        id = self.id
        name = self.name
        profile_photo_url = self.profile_photo_url
        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if email is not UNSET:
            field_dict["email"] = email
        if id is not UNSET:
            field_dict["id"] = id
        if name is not UNSET:
            field_dict["name"] = name
        if profile_photo_url is not UNSET:
            field_dict["profile_photo_url"] = profile_photo_url
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        email = src_dict.get("email")

        id = src_dict.get("id")

        name = src_dict.get("name")

        profile_photo_url = src_dict.get("profile_photo_url")

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        get_user_response_200_data = cls(
            created_at=created_at,
            email=email,
            id=id,
            name=name,
            profile_photo_url=profile_photo_url,
            updated_at=updated_at,
        )

        get_user_response_200_data.additional_properties = src_dict
        return get_user_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_user_response_200_status.py:
```
from enum import Enum


class GetUserResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_user_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_user_response_401_data import GetUserResponse401Data


T = TypeVar("T", bound="GetUserResponse401")


@attr.s(auto_attribs=True)
class GetUserResponse401:
    """
    Attributes:
        status (Union[Unset, GetUserResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetUserResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetUserResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_user_response_401_data import GetUserResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetUserResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetUserResponse401Data.from_dict(_data)

        get_user_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_user_response_401.additional_properties = src_dict
        return get_user_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_user_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetUserResponse401Data")


@attr.s(auto_attribs=True)
class GetUserResponse401Data:
    """
    Attributes:
        code (Union[Unset, GetUserResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_user_response_401_data = cls(
            code=code,
            message=message,
        )

        get_user_response_401_data.additional_properties = src_dict
        return get_user_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_user_response_401_data_code.py:
```
from enum import IntEnum


class GetUserResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_user_response_401_status.py:
```
from enum import Enum


class GetUserResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_user_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.get_user_response_500_data import GetUserResponse500Data


T = TypeVar("T", bound="GetUserResponse500")


@attr.s(auto_attribs=True)
class GetUserResponse500:
    """
    Attributes:
        status (Union[Unset, GetUserResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, GetUserResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "GetUserResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.get_user_response_500_data import GetUserResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, GetUserResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = GetUserResponse500Data.from_dict(_data)

        get_user_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        get_user_response_500.additional_properties = src_dict
        return get_user_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_user_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="GetUserResponse500Data")


@attr.s(auto_attribs=True)
class GetUserResponse500Data:
    """
    Attributes:
        code (Union[Unset, GetUserResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        get_user_response_500_data = cls(
            code=code,
            message=message,
        )

        get_user_response_500_data.additional_properties = src_dict
        return get_user_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/get_user_response_500_data_code.py:
```
from enum import IntEnum


class GetUserResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/get_user_response_500_status.py:
```
from enum import Enum


class GetUserResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_projects_order.py:
```
from enum import Enum


class ListProjectsOrder(str, Enum):
    ASC = "asc"
    DESC = "desc"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_projects_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.list_projects_response_200_data import ListProjectsResponse200Data


T = TypeVar("T", bound="ListProjectsResponse200")


@attr.s(auto_attribs=True)
class ListProjectsResponse200:
    """
    Attributes:
        status (Union[Unset, ListProjectsResponse200Status]): The status of the response Example: success.
        data (Union[Unset, ListProjectsResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "ListProjectsResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.list_projects_response_200_data import ListProjectsResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, ListProjectsResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = ListProjectsResponse200Data.from_dict(_data)

        list_projects_response_200 = cls(
            status=status,
            data=data,
        )

        list_projects_response_200.additional_properties = src_dict
        return list_projects_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_projects_response_200_data.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.list_projects_response_200_data_data_item import ListProjectsResponse200DataDataItem


T = TypeVar("T", bound="ListProjectsResponse200Data")


@attr.s(auto_attribs=True)
class ListProjectsResponse200Data:
    """
    Attributes:
        current_page (Union[Unset, int]): The current page number Example: 1.
        data (Union[Unset, List['ListProjectsResponse200DataDataItem']]):
        first_page_url (Union[Unset, str]): The first page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        from_ (Union[Unset, int]): The first item number of the current page Example: 1.
        last_page (Union[Unset, int]): The last page number Example: 1.
        last_page_url (Union[Unset, str]): The last page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        next_page_url (Union[Unset, str]): The next page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        path (Union[Unset, str]): The current page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        per_page (Union[Unset, int]): The number of items per page Example: 10.
        prev_page_url (Union[Unset, str]): The previous page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        to (Union[Unset, int]): The last item number of the current page Example: 1.
        total (Union[Unset, int]): The total number of items Example: 1.
    """

    current_page: Union[Unset, int] = UNSET
    data: Union[Unset, List["ListProjectsResponse200DataDataItem"]] = UNSET
    first_page_url: Union[Unset, str] = UNSET
    from_: Union[Unset, int] = UNSET
    last_page: Union[Unset, int] = UNSET
    last_page_url: Union[Unset, str] = UNSET
    next_page_url: Union[Unset, str] = UNSET
    path: Union[Unset, str] = UNSET
    per_page: Union[Unset, int] = UNSET
    prev_page_url: Union[Unset, str] = UNSET
    to: Union[Unset, int] = UNSET
    total: Union[Unset, int] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        current_page = self.current_page
        data: Union[Unset, List[Dict[str, Any]]] = UNSET
        if not isinstance(self.data, Unset):
            data = []
            for data_item_data in self.data:
                data_item = data_item_data.to_dict()

                data.append(data_item)

        first_page_url = self.first_page_url
        from_ = self.from_
        last_page = self.last_page
        last_page_url = self.last_page_url
        next_page_url = self.next_page_url
        path = self.path
        per_page = self.per_page
        prev_page_url = self.prev_page_url
        to = self.to
        total = self.total

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if current_page is not UNSET:
            field_dict["current_page"] = current_page
        if data is not UNSET:
            for index, field_value in enumerate(data):
                field_dict[f"data[]"] = field_value
        if first_page_url is not UNSET:
            field_dict["first_page_url"] = first_page_url
        if from_ is not UNSET:
            field_dict["from"] = from_
        if last_page is not UNSET:
            field_dict["last_page"] = last_page
        if last_page_url is not UNSET:
            field_dict["last_page_url"] = last_page_url
        if next_page_url is not UNSET:
            field_dict["next_page_url"] = next_page_url
        if path is not UNSET:
            field_dict["path"] = path
        if per_page is not UNSET:
            field_dict["per_page"] = per_page
        if prev_page_url is not UNSET:
            field_dict["prev_page_url"] = prev_page_url
        if to is not UNSET:
            field_dict["to"] = to
        if total is not UNSET:
            field_dict["total"] = total

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.list_projects_response_200_data_data_item import ListProjectsResponse200DataDataItem

        current_page = src_dict.get("current_page")

        data = []
        _data = src_dict.get("data")
        for data_item_data in _data or []:
            data_item = ListProjectsResponse200DataDataItem.from_dict(data_item_data)

            data.append(data_item)

        first_page_url = src_dict.get("first_page_url")

        from_ = src_dict.get("from")

        last_page = src_dict.get("last_page")

        last_page_url = src_dict.get("last_page_url")

        next_page_url = src_dict.get("next_page_url")

        path = src_dict.get("path")

        per_page = src_dict.get("per_page")

        prev_page_url = src_dict.get("prev_page_url")

        to = src_dict.get("to")

        total = src_dict.get("total")

        list_projects_response_200_data = cls(
            current_page=current_page,
            data=data,
            first_page_url=first_page_url,
            from_=from_,
            last_page=last_page,
            last_page_url=last_page_url,
            next_page_url=next_page_url,
            path=path,
            per_page=per_page,
            prev_page_url=prev_page_url,
            to=to,
            total=total,
        )

        list_projects_response_200_data.additional_properties = src_dict
        return list_projects_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_projects_response_200_data_data_item.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="ListProjectsResponse200DataDataItem")


@attr.s(auto_attribs=True)
class ListProjectsResponse200DataDataItem:
    """
    Attributes:
        id (Union[Unset, int]): Project ID Example: 1.
        project_name (Union[Unset, str]): Project name Example: My Project.
        sitemap_path (Union[Unset, str]): Project sitemap Example: https://www.example.com/sitemap.xml.
        is_chat_active (Union[Unset, bool]): Whether the chat bot is active or not Example: True.
        user_id (Union[Unset, int]): User ID of the project owner Example: 1.
        created_at (Union[Unset, datetime.datetime]): Date and time when the project was created Default:
            isoparse('2023-05-08 13:06:55'). Example: 2021-01-01 00:00:00.
        updated_at (Union[Unset, datetime.datetime]): Date and time when the project was last updated Default:
            isoparse('2023-05-08 13:06:55'). Example: 2021-01-01 00:00:00.
        deleted_at (Union[Unset, None, datetime.datetime]): Date and time when the project was deleted Example:
            2021-01-01 00:00:00.
        type (Union[Unset, ListProjectsResponse200DataDataItemType]): Project type Default:
            ListProjectsResponse200DataDataItemType.SITEMAP. Example: SITEMAP.
        is_shared (Union[Unset, bool]): Whether the project is shared or not Example: True.
        shareable_slug (Union[Unset, None, str]): Shareable slug that can be used to share the project Example:
            1234567890abcdef1234567890abcdef.
        shareable_link (Union[Unset, None, str]): Shareable link that can be used to share the project
        embed_code (Union[Unset, None, str]): Embed code that can be used to embed the project
        live_chat_code (Union[Unset, None, str]): Live chat code that can be used to embed the live chat
    """

    id: Union[Unset, int] = UNSET
    project_name: Union[Unset, str] = UNSET
    sitemap_path: Union[Unset, str] = UNSET
    is_chat_active: Union[Unset, bool] = False
    user_id: Union[Unset, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = isoparse("2023-05-08 13:06:55")
    updated_at: Union[Unset, datetime.datetime] = isoparse("2023-05-08 13:06:55")
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    type: Union[Unset, str] = "SITEMAP"
    is_shared: Union[Unset, bool] = False
    shareable_slug: Union[Unset, None, str] = UNSET
    shareable_link: Union[Unset, None, str] = UNSET
    embed_code: Union[Unset, None, str] = UNSET
    live_chat_code: Union[Unset, None, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        project_name = self.project_name
        sitemap_path = self.sitemap_path
        is_chat_active = self.is_chat_active
        user_id = self.user_id
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        type: Union[Unset, str] = UNSET
        if not isinstance(self.type, Unset):
            type = self.type

        is_shared = self.is_shared
        shareable_slug = self.shareable_slug
        shareable_link = self.shareable_link
        embed_code = self.embed_code
        live_chat_code = self.live_chat_code

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if project_name is not UNSET:
            field_dict["project_name"] = project_name
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path
        if is_chat_active is not UNSET:
            field_dict["is_chat_active"] = is_chat_active
        if user_id is not UNSET:
            field_dict["user_id"] = user_id
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at
        if type is not UNSET:
            field_dict["type"] = type
        if is_shared is not UNSET:
            field_dict["is_shared"] = is_shared
        if shareable_slug is not UNSET:
            field_dict["shareable_slug"] = shareable_slug
        if shareable_link is not UNSET:
            field_dict["shareable_link"] = shareable_link
        if embed_code is not UNSET:
            field_dict["embed_code"] = embed_code
        if live_chat_code is not UNSET:
            field_dict["live_chat_code"] = live_chat_code

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        id = src_dict.get("id")

        project_name = src_dict.get("project_name")

        sitemap_path = src_dict.get("sitemap_path")

        is_chat_active = src_dict.get("is_chat_active")

        user_id = src_dict.get("user_id")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        type = src_dict.get("type")

        is_shared = src_dict.get("is_shared")

        shareable_slug = src_dict.get("shareable_slug")

        shareable_link = src_dict.get("shareable_link")

        embed_code = src_dict.get("embed_code")

        live_chat_code = src_dict.get("live_chat_code")

        list_projects_response_200_data_data_item = cls(
            id=id,
            project_name=project_name,
            sitemap_path=sitemap_path,
            is_chat_active=is_chat_active,
            user_id=user_id,
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
            type=type,
            is_shared=is_shared,
            shareable_slug=shareable_slug,
            shareable_link=shareable_link,
            embed_code=embed_code,
            live_chat_code=live_chat_code,
        )

        list_projects_response_200_data_data_item.additional_properties = src_dict
        return list_projects_response_200_data_data_item

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_projects_response_200_data_data_item_type.py:
```
from enum import Enum


class ListProjectsResponse200DataDataItemType(str, Enum):
    SITEMAP = "SITEMAP"
    URL = "URL"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_projects_response_200_status.py:
```
from enum import Enum


class ListProjectsResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_projects_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.list_projects_response_401_data import ListProjectsResponse401Data


T = TypeVar("T", bound="ListProjectsResponse401")


@attr.s(auto_attribs=True)
class ListProjectsResponse401:
    """
    Attributes:
        status (Union[Unset, ListProjectsResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, ListProjectsResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "ListProjectsResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.list_projects_response_401_data import ListProjectsResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, ListProjectsResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = ListProjectsResponse401Data.from_dict(_data)

        list_projects_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        list_projects_response_401.additional_properties = src_dict
        return list_projects_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_projects_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ListProjectsResponse401Data")


@attr.s(auto_attribs=True)
class ListProjectsResponse401Data:
    """
    Attributes:
        code (Union[Unset, ListProjectsResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        list_projects_response_401_data = cls(
            code=code,
            message=message,
        )

        list_projects_response_401_data.additional_properties = src_dict
        return list_projects_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_projects_response_401_data_code.py:
```
from enum import IntEnum


class ListProjectsResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_projects_response_401_status.py:
```
from enum import Enum


class ListProjectsResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_projects_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.list_projects_response_500_data import ListProjectsResponse500Data


T = TypeVar("T", bound="ListProjectsResponse500")


@attr.s(auto_attribs=True)
class ListProjectsResponse500:
    """
    Attributes:
        status (Union[Unset, ListProjectsResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, ListProjectsResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "ListProjectsResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.list_projects_response_500_data import ListProjectsResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, ListProjectsResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = ListProjectsResponse500Data.from_dict(_data)

        list_projects_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        list_projects_response_500.additional_properties = src_dict
        return list_projects_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_projects_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ListProjectsResponse500Data")


@attr.s(auto_attribs=True)
class ListProjectsResponse500Data:
    """
    Attributes:
        code (Union[Unset, ListProjectsResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        list_projects_response_500_data = cls(
            code=code,
            message=message,
        )

        list_projects_response_500_data.additional_properties = src_dict
        return list_projects_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_projects_response_500_data_code.py:
```
from enum import IntEnum


class ListProjectsResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_projects_response_500_status.py:
```
from enum import Enum


class ListProjectsResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.list_sources_response_200_data import ListSourcesResponse200Data


T = TypeVar("T", bound="ListSourcesResponse200")


@attr.s(auto_attribs=True)
class ListSourcesResponse200:
    """
    Attributes:
        status (Union[Unset, ListSourcesResponse200Status]): The status of the response Example: success.
        data (Union[Unset, ListSourcesResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "ListSourcesResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.list_sources_response_200_data import ListSourcesResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, ListSourcesResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = ListSourcesResponse200Data.from_dict(_data)

        list_sources_response_200 = cls(
            status=status,
            data=data,
        )

        list_sources_response_200.additional_properties = src_dict
        return list_sources_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_data.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.list_sources_response_200_data_sitemaps_item import ListSourcesResponse200DataSitemapsItem
    from ..models.list_sources_response_200_data_uploads import ListSourcesResponse200DataUploads


T = TypeVar("T", bound="ListSourcesResponse200Data")


@attr.s(auto_attribs=True)
class ListSourcesResponse200Data:
    """
    Attributes:
        sitemaps (Union[Unset, List['ListSourcesResponse200DataSitemapsItem']]):
        uploads (Union[Unset, ListSourcesResponse200DataUploads]):
    """

    sitemaps: Union[Unset, List["ListSourcesResponse200DataSitemapsItem"]] = UNSET
    uploads: Union[Unset, "ListSourcesResponse200DataUploads"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        sitemaps: Union[Unset, List[Dict[str, Any]]] = UNSET
        if not isinstance(self.sitemaps, Unset):
            sitemaps = []
            for sitemaps_item_data in self.sitemaps:
                sitemaps_item = sitemaps_item_data.to_dict()

                sitemaps.append(sitemaps_item)

        uploads: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.uploads, Unset):
            uploads = self.uploads.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if sitemaps is not UNSET:
            for index, field_value in enumerate(sitemaps):
                field_dict[f"sitemaps[]"] = field_value
        if uploads is not UNSET:
            field_dict["uploads"] = uploads

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.list_sources_response_200_data_sitemaps_item import ListSourcesResponse200DataSitemapsItem
        from ..models.list_sources_response_200_data_uploads import ListSourcesResponse200DataUploads

        sitemaps = []
        _sitemaps = src_dict.get("sitemaps")
        for sitemaps_item_data in _sitemaps or []:
            sitemaps_item = ListSourcesResponse200DataSitemapsItem.from_dict(sitemaps_item_data)

            sitemaps.append(sitemaps_item)

        _uploads = src_dict.get("uploads")
        uploads: Union[Unset, ListSourcesResponse200DataUploads]
        if isinstance(_uploads, Unset):
            uploads = UNSET
        else:
            uploads = ListSourcesResponse200DataUploads.from_dict(_uploads)

        list_sources_response_200_data = cls(
            sitemaps=sitemaps,
            uploads=uploads,
        )

        list_sources_response_200_data.additional_properties = src_dict
        return list_sources_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_data_sitemaps_item.py:
```
import datetime
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.list_sources_response_200_data_sitemaps_item_pages_item import (
        ListSourcesResponse200DataSitemapsItemPagesItem,
    )
    from ..models.list_sources_response_200_data_sitemaps_item_settings import (
        ListSourcesResponse200DataSitemapsItemSettings,
    )


T = TypeVar("T", bound="ListSourcesResponse200DataSitemapsItem")


@attr.s(auto_attribs=True)
class ListSourcesResponse200DataSitemapsItem:
    """
    Attributes:
        id (Union[Unset, int]): The project source ID Example: 1.
        created_at (Union[Unset, datetime.datetime]): The project source creation date Example: 2021-01-01 00:00:00.
        updated_at (Union[Unset, datetime.datetime]): The project source update date Example: 2021-01-01 00:00:00.
        type (Union[Unset, ListSourcesResponse200DataSitemapsItemType]): The project source type Example: sitemap.
        settings (Union[Unset, ListSourcesResponse200DataSitemapsItemSettings]): The project source settings
        pages (Union[Unset, None, List['ListSourcesResponse200DataSitemapsItemPagesItem']]): The project source pages
    """

    id: Union[Unset, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    type: Union[Unset, str] = "sitemap"
    settings: Union[Unset, "ListSourcesResponse200DataSitemapsItemSettings"] = UNSET
    pages: Union[Unset, None, List["ListSourcesResponse200DataSitemapsItemPagesItem"]] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        type: Union[Unset, str] = UNSET
        if not isinstance(self.type, Unset):
            type = self.type

        settings: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.settings, Unset):
            settings = self.settings.to_dict()

        pages: Union[Unset, None, List[Dict[str, Any]]] = UNSET
        if not isinstance(self.pages, Unset):
            if self.pages is None:
                pages = None
            else:
                pages = []
                for pages_item_data in self.pages:
                    pages_item = pages_item_data.to_dict()

                    pages.append(pages_item)

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if type is not UNSET:
            field_dict["type"] = type
        if settings is not UNSET:
            field_dict["settings"] = settings
        if pages is not UNSET:
            for index, field_value in enumerate(pages):
                field_dict[f"pages[]"] = field_value

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.list_sources_response_200_data_sitemaps_item_pages_item import (
            ListSourcesResponse200DataSitemapsItemPagesItem,
        )
        from ..models.list_sources_response_200_data_sitemaps_item_settings import (
            ListSourcesResponse200DataSitemapsItemSettings,
        )

        id = src_dict.get("id")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        type = src_dict.get("type")

        _settings = src_dict.get("settings")
        settings: Union[Unset, ListSourcesResponse200DataSitemapsItemSettings]
        if isinstance(_settings, Unset):
            settings = UNSET
        else:
            settings = ListSourcesResponse200DataSitemapsItemSettings.from_dict(_settings)

        pages = []
        _pages = src_dict.get("pages")
        for pages_item_data in _pages or []:
            pages_item = ListSourcesResponse200DataSitemapsItemPagesItem.from_dict(pages_item_data)

            pages.append(pages_item)

        list_sources_response_200_data_sitemaps_item = cls(
            id=id,
            created_at=created_at,
            updated_at=updated_at,
            type=type,
            settings=settings,
            pages=pages,
        )

        list_sources_response_200_data_sitemaps_item.additional_properties = src_dict
        return list_sources_response_200_data_sitemaps_item

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_data_sitemaps_item_pages_item.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="ListSourcesResponse200DataSitemapsItemPagesItem")


@attr.s(auto_attribs=True)
class ListSourcesResponse200DataSitemapsItemPagesItem:
    r"""
    Attributes:
        id (Union[Unset, int]): Page ID Example: 1.
        page_url (Union[Unset, str]): URL of the page or file Example: https://example.com.
        page_url_hash (Union[Unset, str]): Hash of the URL of the page or file Example:
            d41d8cd98f00b204e9800998ecf8427e.
        project_id (Union[Unset, int]): Project ID Example: 1.
        s3_path (Union[Unset, None, str]): This is the path where the page is stored in S3.\nNote: This is omitted in
            the response if the page is not a file Example: project-1/page-1/file.pdf.
        crawl_status (Union[Unset, ListSourcesResponse200DataSitemapsItemPagesItemCrawlStatus]): Crawl status of the
            page Default: ListSourcesResponse200DataSitemapsItemPagesItemCrawlStatus.QUEUED. Example: queued.
        index_status (Union[Unset, ListSourcesResponse200DataSitemapsItemPagesItemIndexStatus]): Index status of the
            page Default: ListSourcesResponse200DataSitemapsItemPagesItemIndexStatus.QUEUED. Example: queued.
        is_file (Union[Unset, bool]): Whether the page is a file or not Example: True.
        is_file_kept (Union[Unset, bool]): Whether the file is kept after processing or not.\nNote: This is omitted in
            the response if the page is not a file Default: True. Example: True.
        filename (Union[Unset, None, str]): Filename of the page.\nNote: This is omitted in the response if the page is
            not a file Example: file.pdf.
        filesize (Union[Unset, None, int]): Filesize of the page.\nNote: This is omitted in the response if the page is
            not a file Example: 100.
        created_at (Union[Unset, datetime.datetime]): Date and time when the page was created Example: 2021-01-01
            00:00:00.
        updated_at (Union[Unset, datetime.datetime]): Date and time when the page was updated Example: 2021-01-01
            00:00:00.
        deleted_at (Union[Unset, None, datetime.datetime]): Date and time when the page was deleted Example: 2021-01-01
            00:00:00.
    """

    id: Union[Unset, int] = UNSET
    page_url: Union[Unset, str] = UNSET
    page_url_hash: Union[Unset, str] = UNSET
    project_id: Union[Unset, int] = UNSET
    s3_path: Union[Unset, None, str] = UNSET
    crawl_status: Union[Unset, str] = "queued"
    index_status: Union[Unset, str] = "queued"
    is_file: Union[Unset, bool] = False
    is_file_kept: Union[Unset, bool] = True
    filename: Union[Unset, None, str] = UNSET
    filesize: Union[Unset, None, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        page_url = self.page_url
        page_url_hash = self.page_url_hash
        project_id = self.project_id
        s3_path = self.s3_path
        crawl_status: Union[Unset, str] = UNSET
        if not isinstance(self.crawl_status, Unset):
            crawl_status = self.crawl_status

        index_status: Union[Unset, str] = UNSET
        if not isinstance(self.index_status, Unset):
            index_status = self.index_status

        is_file = self.is_file
        is_file_kept = self.is_file_kept
        filename = self.filename
        filesize = self.filesize
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if page_url is not UNSET:
            field_dict["page_url"] = page_url
        if page_url_hash is not UNSET:
            field_dict["page_url_hash"] = page_url_hash
        if project_id is not UNSET:
            field_dict["project_id"] = project_id
        if s3_path is not UNSET:
            field_dict["s3_path"] = s3_path
        if crawl_status is not UNSET:
            field_dict["crawl_status"] = crawl_status
        if index_status is not UNSET:
            field_dict["index_status"] = index_status
        if is_file is not UNSET:
            field_dict["is_file"] = is_file
        if is_file_kept is not UNSET:
            field_dict["is_file_kept"] = is_file_kept
        if filename is not UNSET:
            field_dict["filename"] = filename
        if filesize is not UNSET:
            field_dict["filesize"] = filesize
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        id = src_dict.get("id")

        page_url = src_dict.get("page_url")

        page_url_hash = src_dict.get("page_url_hash")

        project_id = src_dict.get("project_id")

        s3_path = src_dict.get("s3_path")

        crawl_status = src_dict.get("crawl_status")

        index_status = src_dict.get("index_status")

        is_file = src_dict.get("is_file")

        is_file_kept = src_dict.get("is_file_kept")

        filename = src_dict.get("filename")

        filesize = src_dict.get("filesize")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        list_sources_response_200_data_sitemaps_item_pages_item = cls(
            id=id,
            page_url=page_url,
            page_url_hash=page_url_hash,
            project_id=project_id,
            s3_path=s3_path,
            crawl_status=crawl_status,
            index_status=index_status,
            is_file=is_file,
            is_file_kept=is_file_kept,
            filename=filename,
            filesize=filesize,
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
        )

        list_sources_response_200_data_sitemaps_item_pages_item.additional_properties = src_dict
        return list_sources_response_200_data_sitemaps_item_pages_item

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_data_sitemaps_item_pages_item_crawl_status.py:
```
from enum import Enum


class ListSourcesResponse200DataSitemapsItemPagesItemCrawlStatus(str, Enum):
    FAILED = "failed"
    LIMITED = "limited"
    NA = "n/a"
    OK = "ok"
    QUEUED = "queued"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_data_sitemaps_item_pages_item_index_status.py:
```
from enum import Enum


class ListSourcesResponse200DataSitemapsItemPagesItemIndexStatus(str, Enum):
    FAILED = "failed"
    LIMITED = "limited"
    NA = "n/a"
    OK = "ok"
    QUEUED = "queued"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_data_sitemaps_item_settings.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ListSourcesResponse200DataSitemapsItemSettings")


@attr.s(auto_attribs=True)
class ListSourcesResponse200DataSitemapsItemSettings:
    """The project source settings

    Attributes:
        data_refresh (Union[Unset, bool]): Whether the project source data should be refreshed Example: True.
        executive_js (Union[Unset, bool]): Whether the project source should execute JavaScript Default: True. Example:
            True.
        data_refresh_frequency (Union[Unset, str]): The project source data refresh frequency Default: 'never'. Example:
            never.
        sitemap_path (Union[Unset, str]): The project source sitemap path Example: https://example.com/sitemap.xml.
    """

    data_refresh: Union[Unset, bool] = False
    executive_js: Union[Unset, bool] = True
    data_refresh_frequency: Union[Unset, str] = "never"
    sitemap_path: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        data_refresh = self.data_refresh
        executive_js = self.executive_js
        data_refresh_frequency = self.data_refresh_frequency
        sitemap_path = self.sitemap_path

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if data_refresh is not UNSET:
            field_dict["data_refresh"] = data_refresh
        if executive_js is not UNSET:
            field_dict["executive_js"] = executive_js
        if data_refresh_frequency is not UNSET:
            field_dict["data_refresh_frequency"] = data_refresh_frequency
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        data_refresh = src_dict.get("data_refresh")

        executive_js = src_dict.get("executive_js")

        data_refresh_frequency = src_dict.get("data_refresh_frequency")

        sitemap_path = src_dict.get("sitemap_path")

        list_sources_response_200_data_sitemaps_item_settings = cls(
            data_refresh=data_refresh,
            executive_js=executive_js,
            data_refresh_frequency=data_refresh_frequency,
            sitemap_path=sitemap_path,
        )

        list_sources_response_200_data_sitemaps_item_settings.additional_properties = src_dict
        return list_sources_response_200_data_sitemaps_item_settings

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_data_sitemaps_item_type.py:
```
from enum import Enum


class ListSourcesResponse200DataSitemapsItemType(str, Enum):
    SITEMAP = "sitemap"
    UPLOAD = "upload"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_data_uploads.py:
```
import datetime
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.list_sources_response_200_data_uploads_pages_item import ListSourcesResponse200DataUploadsPagesItem
    from ..models.list_sources_response_200_data_uploads_settings import ListSourcesResponse200DataUploadsSettings


T = TypeVar("T", bound="ListSourcesResponse200DataUploads")


@attr.s(auto_attribs=True)
class ListSourcesResponse200DataUploads:
    """
    Attributes:
        id (Union[Unset, int]): The project source ID Example: 1.
        created_at (Union[Unset, datetime.datetime]): The project source creation date Example: 2021-01-01 00:00:00.
        updated_at (Union[Unset, datetime.datetime]): The project source update date Example: 2021-01-01 00:00:00.
        type (Union[Unset, ListSourcesResponse200DataUploadsType]): The project source type Example: sitemap.
        settings (Union[Unset, ListSourcesResponse200DataUploadsSettings]): The project source settings
        pages (Union[Unset, None, List['ListSourcesResponse200DataUploadsPagesItem']]): The project source pages
    """

    id: Union[Unset, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    type: Union[Unset, str] = "sitemap"
    settings: Union[Unset, "ListSourcesResponse200DataUploadsSettings"] = UNSET
    pages: Union[Unset, None, List["ListSourcesResponse200DataUploadsPagesItem"]] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        type: Union[Unset, str] = UNSET
        if not isinstance(self.type, Unset):
            type = self.type

        settings: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.settings, Unset):
            settings = self.settings.to_dict()

        pages: Union[Unset, None, List[Dict[str, Any]]] = UNSET
        if not isinstance(self.pages, Unset):
            if self.pages is None:
                pages = None
            else:
                pages = []
                for pages_item_data in self.pages:
                    pages_item = pages_item_data.to_dict()

                    pages.append(pages_item)

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if type is not UNSET:
            field_dict["type"] = type
        if settings is not UNSET:
            field_dict["settings"] = settings
        if pages is not UNSET:
            for index, field_value in enumerate(pages):
                field_dict[f"pages[]"] = field_value

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.list_sources_response_200_data_uploads_pages_item import (
            ListSourcesResponse200DataUploadsPagesItem,
        )
        from ..models.list_sources_response_200_data_uploads_settings import ListSourcesResponse200DataUploadsSettings

        id = src_dict.get("id")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        type = src_dict.get("type")

        _settings = src_dict.get("settings")
        settings: Union[Unset, ListSourcesResponse200DataUploadsSettings]
        if isinstance(_settings, Unset):
            settings = UNSET
        else:
            settings = ListSourcesResponse200DataUploadsSettings.from_dict(_settings)

        pages = []
        _pages = src_dict.get("pages")
        for pages_item_data in _pages or []:
            pages_item = ListSourcesResponse200DataUploadsPagesItem.from_dict(pages_item_data)

            pages.append(pages_item)

        list_sources_response_200_data_uploads = cls(
            id=id,
            created_at=created_at,
            updated_at=updated_at,
            type=type,
            settings=settings,
            pages=pages,
        )

        list_sources_response_200_data_uploads.additional_properties = src_dict
        return list_sources_response_200_data_uploads

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_data_uploads_pages_item.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="ListSourcesResponse200DataUploadsPagesItem")


@attr.s(auto_attribs=True)
class ListSourcesResponse200DataUploadsPagesItem:
    r"""
    Attributes:
        id (Union[Unset, int]): Page ID Example: 1.
        page_url (Union[Unset, str]): URL of the page or file Example: https://example.com.
        page_url_hash (Union[Unset, str]): Hash of the URL of the page or file Example:
            d41d8cd98f00b204e9800998ecf8427e.
        project_id (Union[Unset, int]): Project ID Example: 1.
        s3_path (Union[Unset, None, str]): This is the path where the page is stored in S3.\nNote: This is omitted in
            the response if the page is not a file Example: project-1/page-1/file.pdf.
        crawl_status (Union[Unset, ListSourcesResponse200DataUploadsPagesItemCrawlStatus]): Crawl status of the page
            Default: ListSourcesResponse200DataUploadsPagesItemCrawlStatus.QUEUED. Example: queued.
        index_status (Union[Unset, ListSourcesResponse200DataUploadsPagesItemIndexStatus]): Index status of the page
            Default: ListSourcesResponse200DataUploadsPagesItemIndexStatus.QUEUED. Example: queued.
        is_file (Union[Unset, bool]): Whether the page is a file or not Example: True.
        is_file_kept (Union[Unset, bool]): Whether the file is kept after processing or not.\nNote: This is omitted in
            the response if the page is not a file Default: True. Example: True.
        filename (Union[Unset, None, str]): Filename of the page.\nNote: This is omitted in the response if the page is
            not a file Example: file.pdf.
        filesize (Union[Unset, None, int]): Filesize of the page.\nNote: This is omitted in the response if the page is
            not a file Example: 100.
        created_at (Union[Unset, datetime.datetime]): Date and time when the page was created Example: 2021-01-01
            00:00:00.
        updated_at (Union[Unset, datetime.datetime]): Date and time when the page was updated Example: 2021-01-01
            00:00:00.
        deleted_at (Union[Unset, None, datetime.datetime]): Date and time when the page was deleted Example: 2021-01-01
            00:00:00.
    """

    id: Union[Unset, int] = UNSET
    page_url: Union[Unset, str] = UNSET
    page_url_hash: Union[Unset, str] = UNSET
    project_id: Union[Unset, int] = UNSET
    s3_path: Union[Unset, None, str] = UNSET
    crawl_status: Union[Unset, str] = "queued"
    index_status: Union[Unset, str] = "queued"
    is_file: Union[Unset, bool] = False
    is_file_kept: Union[Unset, bool] = True
    filename: Union[Unset, None, str] = UNSET
    filesize: Union[Unset, None, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        page_url = self.page_url
        page_url_hash = self.page_url_hash
        project_id = self.project_id
        s3_path = self.s3_path
        crawl_status: Union[Unset, str] = UNSET
        if not isinstance(self.crawl_status, Unset):
            crawl_status = self.crawl_status

        index_status: Union[Unset, str] = UNSET
        if not isinstance(self.index_status, Unset):
            index_status = self.index_status

        is_file = self.is_file
        is_file_kept = self.is_file_kept
        filename = self.filename
        filesize = self.filesize
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if page_url is not UNSET:
            field_dict["page_url"] = page_url
        if page_url_hash is not UNSET:
            field_dict["page_url_hash"] = page_url_hash
        if project_id is not UNSET:
            field_dict["project_id"] = project_id
        if s3_path is not UNSET:
            field_dict["s3_path"] = s3_path
        if crawl_status is not UNSET:
            field_dict["crawl_status"] = crawl_status
        if index_status is not UNSET:
            field_dict["index_status"] = index_status
        if is_file is not UNSET:
            field_dict["is_file"] = is_file
        if is_file_kept is not UNSET:
            field_dict["is_file_kept"] = is_file_kept
        if filename is not UNSET:
            field_dict["filename"] = filename
        if filesize is not UNSET:
            field_dict["filesize"] = filesize
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        id = src_dict.get("id")

        page_url = src_dict.get("page_url")

        page_url_hash = src_dict.get("page_url_hash")

        project_id = src_dict.get("project_id")

        s3_path = src_dict.get("s3_path")

        crawl_status = src_dict.get("crawl_status")

        index_status = src_dict.get("index_status")

        is_file = src_dict.get("is_file")

        is_file_kept = src_dict.get("is_file_kept")

        filename = src_dict.get("filename")

        filesize = src_dict.get("filesize")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        list_sources_response_200_data_uploads_pages_item = cls(
            id=id,
            page_url=page_url,
            page_url_hash=page_url_hash,
            project_id=project_id,
            s3_path=s3_path,
            crawl_status=crawl_status,
            index_status=index_status,
            is_file=is_file,
            is_file_kept=is_file_kept,
            filename=filename,
            filesize=filesize,
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
        )

        list_sources_response_200_data_uploads_pages_item.additional_properties = src_dict
        return list_sources_response_200_data_uploads_pages_item

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_data_uploads_pages_item_crawl_status.py:
```
from enum import Enum


class ListSourcesResponse200DataUploadsPagesItemCrawlStatus(str, Enum):
    FAILED = "failed"
    LIMITED = "limited"
    NA = "n/a"
    OK = "ok"
    QUEUED = "queued"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_data_uploads_pages_item_index_status.py:
```
from enum import Enum


class ListSourcesResponse200DataUploadsPagesItemIndexStatus(str, Enum):
    FAILED = "failed"
    LIMITED = "limited"
    NA = "n/a"
    OK = "ok"
    QUEUED = "queued"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_data_uploads_settings.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ListSourcesResponse200DataUploadsSettings")


@attr.s(auto_attribs=True)
class ListSourcesResponse200DataUploadsSettings:
    """The project source settings

    Attributes:
        data_refresh (Union[Unset, bool]): Whether the project source data should be refreshed Example: True.
        executive_js (Union[Unset, bool]): Whether the project source should execute JavaScript Default: True. Example:
            True.
        data_refresh_frequency (Union[Unset, str]): The project source data refresh frequency Default: 'never'. Example:
            never.
        sitemap_path (Union[Unset, str]): The project source sitemap path Example: https://example.com/sitemap.xml.
    """

    data_refresh: Union[Unset, bool] = False
    executive_js: Union[Unset, bool] = True
    data_refresh_frequency: Union[Unset, str] = "never"
    sitemap_path: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        data_refresh = self.data_refresh
        executive_js = self.executive_js
        data_refresh_frequency = self.data_refresh_frequency
        sitemap_path = self.sitemap_path

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if data_refresh is not UNSET:
            field_dict["data_refresh"] = data_refresh
        if executive_js is not UNSET:
            field_dict["executive_js"] = executive_js
        if data_refresh_frequency is not UNSET:
            field_dict["data_refresh_frequency"] = data_refresh_frequency
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        data_refresh = src_dict.get("data_refresh")

        executive_js = src_dict.get("executive_js")

        data_refresh_frequency = src_dict.get("data_refresh_frequency")

        sitemap_path = src_dict.get("sitemap_path")

        list_sources_response_200_data_uploads_settings = cls(
            data_refresh=data_refresh,
            executive_js=executive_js,
            data_refresh_frequency=data_refresh_frequency,
            sitemap_path=sitemap_path,
        )

        list_sources_response_200_data_uploads_settings.additional_properties = src_dict
        return list_sources_response_200_data_uploads_settings

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_data_uploads_type.py:
```
from enum import Enum


class ListSourcesResponse200DataUploadsType(str, Enum):
    SITEMAP = "sitemap"
    UPLOAD = "upload"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_200_status.py:
```
from enum import Enum


class ListSourcesResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.list_sources_response_400_data import ListSourcesResponse400Data


T = TypeVar("T", bound="ListSourcesResponse400")


@attr.s(auto_attribs=True)
class ListSourcesResponse400:
    """
    Attributes:
        status (Union[Unset, ListSourcesResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, ListSourcesResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "ListSourcesResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.list_sources_response_400_data import ListSourcesResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, ListSourcesResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = ListSourcesResponse400Data.from_dict(_data)

        list_sources_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        list_sources_response_400.additional_properties = src_dict
        return list_sources_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ListSourcesResponse400Data")


@attr.s(auto_attribs=True)
class ListSourcesResponse400Data:
    """
    Attributes:
        code (Union[Unset, ListSourcesResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        list_sources_response_400_data = cls(
            code=code,
            message=message,
        )

        list_sources_response_400_data.additional_properties = src_dict
        return list_sources_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_400_data_code.py:
```
from enum import IntEnum


class ListSourcesResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_400_status.py:
```
from enum import Enum


class ListSourcesResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.list_sources_response_401_data import ListSourcesResponse401Data


T = TypeVar("T", bound="ListSourcesResponse401")


@attr.s(auto_attribs=True)
class ListSourcesResponse401:
    """
    Attributes:
        status (Union[Unset, ListSourcesResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, ListSourcesResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "ListSourcesResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.list_sources_response_401_data import ListSourcesResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, ListSourcesResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = ListSourcesResponse401Data.from_dict(_data)

        list_sources_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        list_sources_response_401.additional_properties = src_dict
        return list_sources_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ListSourcesResponse401Data")


@attr.s(auto_attribs=True)
class ListSourcesResponse401Data:
    """
    Attributes:
        code (Union[Unset, ListSourcesResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        list_sources_response_401_data = cls(
            code=code,
            message=message,
        )

        list_sources_response_401_data.additional_properties = src_dict
        return list_sources_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_401_data_code.py:
```
from enum import IntEnum


class ListSourcesResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_401_status.py:
```
from enum import Enum


class ListSourcesResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.list_sources_response_404_data import ListSourcesResponse404Data


T = TypeVar("T", bound="ListSourcesResponse404")


@attr.s(auto_attribs=True)
class ListSourcesResponse404:
    """
    Attributes:
        status (Union[Unset, ListSourcesResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, ListSourcesResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "ListSourcesResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.list_sources_response_404_data import ListSourcesResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, ListSourcesResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = ListSourcesResponse404Data.from_dict(_data)

        list_sources_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        list_sources_response_404.additional_properties = src_dict
        return list_sources_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ListSourcesResponse404Data")


@attr.s(auto_attribs=True)
class ListSourcesResponse404Data:
    """
    Attributes:
        code (Union[Unset, ListSourcesResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, ListSourcesResponse404DataMessage]): The error message Example: Project with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        list_sources_response_404_data = cls(
            code=code,
            message=message,
        )

        list_sources_response_404_data.additional_properties = src_dict
        return list_sources_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_404_data_code.py:
```
from enum import IntEnum


class ListSourcesResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_404_data_message.py:
```
from enum import Enum


class ListSourcesResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_404_status.py:
```
from enum import Enum


class ListSourcesResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.list_sources_response_500_data import ListSourcesResponse500Data


T = TypeVar("T", bound="ListSourcesResponse500")


@attr.s(auto_attribs=True)
class ListSourcesResponse500:
    """
    Attributes:
        status (Union[Unset, ListSourcesResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, ListSourcesResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "ListSourcesResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.list_sources_response_500_data import ListSourcesResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, ListSourcesResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = ListSourcesResponse500Data.from_dict(_data)

        list_sources_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        list_sources_response_500.additional_properties = src_dict
        return list_sources_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ListSourcesResponse500Data")


@attr.s(auto_attribs=True)
class ListSourcesResponse500Data:
    """
    Attributes:
        code (Union[Unset, ListSourcesResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        list_sources_response_500_data = cls(
            code=code,
            message=message,
        )

        list_sources_response_500_data.additional_properties = src_dict
        return list_sources_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_500_data_code.py:
```
from enum import IntEnum


class ListSourcesResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/list_sources_response_500_status.py:
```
from enum import Enum


class ListSourcesResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_order.py:
```
from enum import Enum


class MessagesConversationOrder(str, Enum):
    ASC = "asc"
    DESC = "desc"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.messages_conversation_response_200_data import MessagesConversationResponse200Data


T = TypeVar("T", bound="MessagesConversationResponse200")


@attr.s(auto_attribs=True)
class MessagesConversationResponse200:
    """
    Attributes:
        status (Union[Unset, MessagesConversationResponse200Status]): The status of the response Example: success.
        data (Union[Unset, MessagesConversationResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "MessagesConversationResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.messages_conversation_response_200_data import MessagesConversationResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, MessagesConversationResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = MessagesConversationResponse200Data.from_dict(_data)

        messages_conversation_response_200 = cls(
            status=status,
            data=data,
        )

        messages_conversation_response_200.additional_properties = src_dict
        return messages_conversation_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_200_data.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.messages_conversation_response_200_data_conversation import (
        MessagesConversationResponse200DataConversation,
    )
    from ..models.messages_conversation_response_200_data_messages import MessagesConversationResponse200DataMessages


T = TypeVar("T", bound="MessagesConversationResponse200Data")


@attr.s(auto_attribs=True)
class MessagesConversationResponse200Data:
    """
    Attributes:
        conversation (Union[Unset, MessagesConversationResponse200DataConversation]):
        messages (Union[Unset, MessagesConversationResponse200DataMessages]):
    """

    conversation: Union[Unset, "MessagesConversationResponse200DataConversation"] = UNSET
    messages: Union[Unset, "MessagesConversationResponse200DataMessages"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        conversation: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.conversation, Unset):
            conversation = self.conversation.to_dict()

        messages: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.messages, Unset):
            messages = self.messages.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if conversation is not UNSET:
            field_dict["conversation"] = conversation
        if messages is not UNSET:
            field_dict["messages"] = messages

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.messages_conversation_response_200_data_conversation import (
            MessagesConversationResponse200DataConversation,
        )
        from ..models.messages_conversation_response_200_data_messages import (
            MessagesConversationResponse200DataMessages,
        )

        _conversation = src_dict.get("conversation")
        conversation: Union[Unset, MessagesConversationResponse200DataConversation]
        if isinstance(_conversation, Unset):
            conversation = UNSET
        else:
            conversation = MessagesConversationResponse200DataConversation.from_dict(_conversation)

        _messages = src_dict.get("messages")
        messages: Union[Unset, MessagesConversationResponse200DataMessages]
        if isinstance(_messages, Unset):
            messages = UNSET
        else:
            messages = MessagesConversationResponse200DataMessages.from_dict(_messages)

        messages_conversation_response_200_data = cls(
            conversation=conversation,
            messages=messages,
        )

        messages_conversation_response_200_data.additional_properties = src_dict
        return messages_conversation_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_200_data_conversation.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="MessagesConversationResponse200DataConversation")


@attr.s(auto_attribs=True)
class MessagesConversationResponse200DataConversation:
    """
    Attributes:
        created_at (Union[Unset, datetime.datetime]): When was this conversation created? Example: 2023-04-30 16:43:53.
        updated_at (Union[Unset, datetime.datetime]): When was this conversation updated? Example: 2023-04-30 16:43:53.
        deleted_at (Union[Unset, None, datetime.datetime]): When was this conversation deleted? Example: 2023-04-30
            16:43:53.
        id (Union[Unset, int]): Conversation ID Example: 1.
        name (Union[Unset, str]): Conversation name Example: Conversation 1.
        project_id (Union[Unset, str]): Project ID for this conversation Example: 1.
        created_by (Union[Unset, str]): User ID for the user who created this conversation Example: 1.
        session_id (Union[Unset, str]): Session ID for this conversation Example: f1b9aaf0-5e4e-11eb-ae93-0242ac130002.
    """

    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    id: Union[Unset, int] = UNSET
    name: Union[Unset, str] = UNSET
    project_id: Union[Unset, str] = UNSET
    created_by: Union[Unset, str] = UNSET
    session_id: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        id = self.id
        name = self.name
        project_id = self.project_id
        created_by = self.created_by
        session_id = self.session_id

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at
        if id is not UNSET:
            field_dict["id"] = id
        if name is not UNSET:
            field_dict["name"] = name
        if project_id is not UNSET:
            field_dict["project_id"] = project_id
        if created_by is not UNSET:
            field_dict["created_by"] = created_by
        if session_id is not UNSET:
            field_dict["session_id"] = session_id

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        id = src_dict.get("id")

        name = src_dict.get("name")

        project_id = src_dict.get("project_id")

        created_by = src_dict.get("created_by")

        session_id = src_dict.get("session_id")

        messages_conversation_response_200_data_conversation = cls(
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
            id=id,
            name=name,
            project_id=project_id,
            created_by=created_by,
            session_id=session_id,
        )

        messages_conversation_response_200_data_conversation.additional_properties = src_dict
        return messages_conversation_response_200_data_conversation

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_200_data_messages.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.messages_conversation_response_200_data_messages_data_item import (
        MessagesConversationResponse200DataMessagesDataItem,
    )


T = TypeVar("T", bound="MessagesConversationResponse200DataMessages")


@attr.s(auto_attribs=True)
class MessagesConversationResponse200DataMessages:
    """
    Attributes:
        current_page (Union[Unset, int]): The current page number Example: 1.
        data (Union[Unset, List['MessagesConversationResponse200DataMessagesDataItem']]):
        first_page_url (Union[Unset, str]): The first page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        from_ (Union[Unset, int]): The first item number of the current page Example: 1.
        last_page (Union[Unset, int]): The last page number Example: 1.
        last_page_url (Union[Unset, str]): The last page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        next_page_url (Union[Unset, str]): The next page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        path (Union[Unset, str]): The current page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        per_page (Union[Unset, int]): The number of items per page Example: 10.
        prev_page_url (Union[Unset, str]): The previous page url Example: https://app.customgpt.ai/api/v1/users?page=1.
        to (Union[Unset, int]): The last item number of the current page Example: 1.
        total (Union[Unset, int]): The total number of items Example: 1.
    """

    current_page: Union[Unset, int] = UNSET
    data: Union[Unset, List["MessagesConversationResponse200DataMessagesDataItem"]] = UNSET
    first_page_url: Union[Unset, str] = UNSET
    from_: Union[Unset, int] = UNSET
    last_page: Union[Unset, int] = UNSET
    last_page_url: Union[Unset, str] = UNSET
    next_page_url: Union[Unset, str] = UNSET
    path: Union[Unset, str] = UNSET
    per_page: Union[Unset, int] = UNSET
    prev_page_url: Union[Unset, str] = UNSET
    to: Union[Unset, int] = UNSET
    total: Union[Unset, int] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        current_page = self.current_page
        data: Union[Unset, List[Dict[str, Any]]] = UNSET
        if not isinstance(self.data, Unset):
            data = []
            for data_item_data in self.data:
                data_item = data_item_data.to_dict()

                data.append(data_item)

        first_page_url = self.first_page_url
        from_ = self.from_
        last_page = self.last_page
        last_page_url = self.last_page_url
        next_page_url = self.next_page_url
        path = self.path
        per_page = self.per_page
        prev_page_url = self.prev_page_url
        to = self.to
        total = self.total

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if current_page is not UNSET:
            field_dict["current_page"] = current_page
        if data is not UNSET:
            for index, field_value in enumerate(data):
                field_dict[f"data[]"] = field_value
        if first_page_url is not UNSET:
            field_dict["first_page_url"] = first_page_url
        if from_ is not UNSET:
            field_dict["from"] = from_
        if last_page is not UNSET:
            field_dict["last_page"] = last_page
        if last_page_url is not UNSET:
            field_dict["last_page_url"] = last_page_url
        if next_page_url is not UNSET:
            field_dict["next_page_url"] = next_page_url
        if path is not UNSET:
            field_dict["path"] = path
        if per_page is not UNSET:
            field_dict["per_page"] = per_page
        if prev_page_url is not UNSET:
            field_dict["prev_page_url"] = prev_page_url
        if to is not UNSET:
            field_dict["to"] = to
        if total is not UNSET:
            field_dict["total"] = total

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.messages_conversation_response_200_data_messages_data_item import (
            MessagesConversationResponse200DataMessagesDataItem,
        )

        current_page = src_dict.get("current_page")

        data = []
        _data = src_dict.get("data")
        for data_item_data in _data or []:
            data_item = MessagesConversationResponse200DataMessagesDataItem.from_dict(data_item_data)

            data.append(data_item)

        first_page_url = src_dict.get("first_page_url")

        from_ = src_dict.get("from")

        last_page = src_dict.get("last_page")

        last_page_url = src_dict.get("last_page_url")

        next_page_url = src_dict.get("next_page_url")

        path = src_dict.get("path")

        per_page = src_dict.get("per_page")

        prev_page_url = src_dict.get("prev_page_url")

        to = src_dict.get("to")

        total = src_dict.get("total")

        messages_conversation_response_200_data_messages = cls(
            current_page=current_page,
            data=data,
            first_page_url=first_page_url,
            from_=from_,
            last_page=last_page,
            last_page_url=last_page_url,
            next_page_url=next_page_url,
            path=path,
            per_page=per_page,
            prev_page_url=prev_page_url,
            to=to,
            total=total,
        )

        messages_conversation_response_200_data_messages.additional_properties = src_dict
        return messages_conversation_response_200_data_messages

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_200_data_messages_data_item.py:
```
import datetime
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union, cast

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.messages_conversation_response_200_data_messages_data_item_metadata import (
        MessagesConversationResponse200DataMessagesDataItemMetadata,
    )


T = TypeVar("T", bound="MessagesConversationResponse200DataMessagesDataItem")


@attr.s(auto_attribs=True)
class MessagesConversationResponse200DataMessagesDataItem:
    """
    Attributes:
        id (Union[Unset, int]): The unique identifier of the prompt history. Example: 1.
        user_id (Union[Unset, int]): The unique identifier of the user. Example: 1.
        user_query (Union[Unset, str]): The user prompt query. Example: What is the meaning of life?.
        openai_response (Union[Unset, str]): The OpenAI response to the user prompt query. Example: The meaning of life
            is to be happy..
        created_at (Union[Unset, datetime.datetime]): The date and time the prompt history was created. Example:
            2021-01-01 00:00:00.
        updated_at (Union[Unset, datetime.datetime]): The date and time the prompt history was last updated. Example:
            2021-01-01 00:00:00.
        conversation_id (Union[Unset, int]): The unique identifier of the conversation. Example: 1.
        citations (Union[Unset, List[int]]): The citations for the prompt history. Example: [1, 2, 3].
        metadata (Union[Unset, MessagesConversationResponse200DataMessagesDataItemMetadata]):  Example: {'user_ip':
            '127.0.0.1', 'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like
            Gecko)', 'external_id': 'ext_id_1234567890', 'request_source': 'web'}.
    """

    id: Union[Unset, int] = UNSET
    user_id: Union[Unset, int] = UNSET
    user_query: Union[Unset, str] = UNSET
    openai_response: Union[Unset, str] = UNSET
    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    conversation_id: Union[Unset, int] = UNSET
    citations: Union[Unset, List[int]] = UNSET
    metadata: Union[Unset, "MessagesConversationResponse200DataMessagesDataItemMetadata"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        user_id = self.user_id
        user_query = self.user_query
        openai_response = self.openai_response
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        conversation_id = self.conversation_id
        citations: Union[Unset, List[int]] = UNSET
        if not isinstance(self.citations, Unset):
            citations = self.citations

        metadata: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.metadata, Unset):
            metadata = self.metadata.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if user_id is not UNSET:
            field_dict["user_id"] = user_id
        if user_query is not UNSET:
            field_dict["user_query"] = user_query
        if openai_response is not UNSET:
            field_dict["openai_response"] = openai_response
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if conversation_id is not UNSET:
            field_dict["conversation_id"] = conversation_id
        if citations is not UNSET:
            for index, field_value in enumerate(citations):
                field_dict[f"citations[]"] = field_value
        if metadata is not UNSET:
            field_dict["metadata"] = metadata

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.messages_conversation_response_200_data_messages_data_item_metadata import (
            MessagesConversationResponse200DataMessagesDataItemMetadata,
        )

        id = src_dict.get("id")

        user_id = src_dict.get("user_id")

        user_query = src_dict.get("user_query")

        openai_response = src_dict.get("openai_response")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        conversation_id = src_dict.get("conversation_id")

        citations = cast(List[int], src_dict.get("citations"))

        _metadata = src_dict.get("metadata")
        metadata: Union[Unset, MessagesConversationResponse200DataMessagesDataItemMetadata]
        if isinstance(_metadata, Unset):
            metadata = UNSET
        else:
            metadata = MessagesConversationResponse200DataMessagesDataItemMetadata.from_dict(_metadata)

        messages_conversation_response_200_data_messages_data_item = cls(
            id=id,
            user_id=user_id,
            user_query=user_query,
            openai_response=openai_response,
            created_at=created_at,
            updated_at=updated_at,
            conversation_id=conversation_id,
            citations=citations,
            metadata=metadata,
        )

        messages_conversation_response_200_data_messages_data_item.additional_properties = src_dict
        return messages_conversation_response_200_data_messages_data_item

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_200_data_messages_data_item_metadata.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="MessagesConversationResponse200DataMessagesDataItemMetadata")


@attr.s(auto_attribs=True)
class MessagesConversationResponse200DataMessagesDataItemMetadata:
    """
    Example:
        {'user_ip': '127.0.0.1', 'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36
            (KHTML, like Gecko)', 'external_id': 'ext_id_1234567890', 'request_source': 'web'}

    Attributes:
        user_ip (Union[Unset, str]): The IP address of the user. Example: 127.0.0.1.
        user_agent (Union[Unset, str]): The user agent of the user. Example: Mozilla/5.0 (Macintosh; Intel Mac OS X
            10_15_7) AppleWebKit/537.36 (KHTML, like Gecko).
        external_id (Union[Unset, str]): The external ID of the prompt history. Example: ext_id_1234567890.
        request_source (Union[Unset, str]): The source of the request. Example: web.
    """

    user_ip: Union[Unset, str] = UNSET
    user_agent: Union[Unset, str] = UNSET
    external_id: Union[Unset, str] = UNSET
    request_source: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        user_ip = self.user_ip
        user_agent = self.user_agent
        external_id = self.external_id
        request_source = self.request_source

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if user_ip is not UNSET:
            field_dict["user_ip"] = user_ip
        if user_agent is not UNSET:
            field_dict["user_agent"] = user_agent
        if external_id is not UNSET:
            field_dict["external_id"] = external_id
        if request_source is not UNSET:
            field_dict["request_source"] = request_source

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        user_ip = src_dict.get("user_ip")

        user_agent = src_dict.get("user_agent")

        external_id = src_dict.get("external_id")

        request_source = src_dict.get("request_source")

        messages_conversation_response_200_data_messages_data_item_metadata = cls(
            user_ip=user_ip,
            user_agent=user_agent,
            external_id=external_id,
            request_source=request_source,
        )

        messages_conversation_response_200_data_messages_data_item_metadata.additional_properties = src_dict
        return messages_conversation_response_200_data_messages_data_item_metadata

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_200_status.py:
```
from enum import Enum


class MessagesConversationResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.messages_conversation_response_400_data import MessagesConversationResponse400Data


T = TypeVar("T", bound="MessagesConversationResponse400")


@attr.s(auto_attribs=True)
class MessagesConversationResponse400:
    """
    Attributes:
        status (Union[Unset, MessagesConversationResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, MessagesConversationResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "MessagesConversationResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.messages_conversation_response_400_data import MessagesConversationResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, MessagesConversationResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = MessagesConversationResponse400Data.from_dict(_data)

        messages_conversation_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        messages_conversation_response_400.additional_properties = src_dict
        return messages_conversation_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="MessagesConversationResponse400Data")


@attr.s(auto_attribs=True)
class MessagesConversationResponse400Data:
    """
    Attributes:
        code (Union[Unset, MessagesConversationResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        messages_conversation_response_400_data = cls(
            code=code,
            message=message,
        )

        messages_conversation_response_400_data.additional_properties = src_dict
        return messages_conversation_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_400_data_code.py:
```
from enum import IntEnum


class MessagesConversationResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_400_status.py:
```
from enum import Enum


class MessagesConversationResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.messages_conversation_response_401_data import MessagesConversationResponse401Data


T = TypeVar("T", bound="MessagesConversationResponse401")


@attr.s(auto_attribs=True)
class MessagesConversationResponse401:
    """
    Attributes:
        status (Union[Unset, MessagesConversationResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, MessagesConversationResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "MessagesConversationResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.messages_conversation_response_401_data import MessagesConversationResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, MessagesConversationResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = MessagesConversationResponse401Data.from_dict(_data)

        messages_conversation_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        messages_conversation_response_401.additional_properties = src_dict
        return messages_conversation_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="MessagesConversationResponse401Data")


@attr.s(auto_attribs=True)
class MessagesConversationResponse401Data:
    """
    Attributes:
        code (Union[Unset, MessagesConversationResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        messages_conversation_response_401_data = cls(
            code=code,
            message=message,
        )

        messages_conversation_response_401_data.additional_properties = src_dict
        return messages_conversation_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_401_data_code.py:
```
from enum import IntEnum


class MessagesConversationResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_401_status.py:
```
from enum import Enum


class MessagesConversationResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.messages_conversation_response_404_data import MessagesConversationResponse404Data


T = TypeVar("T", bound="MessagesConversationResponse404")


@attr.s(auto_attribs=True)
class MessagesConversationResponse404:
    """
    Attributes:
        status (Union[Unset, MessagesConversationResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, MessagesConversationResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "MessagesConversationResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.messages_conversation_response_404_data import MessagesConversationResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, MessagesConversationResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = MessagesConversationResponse404Data.from_dict(_data)

        messages_conversation_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        messages_conversation_response_404.additional_properties = src_dict
        return messages_conversation_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="MessagesConversationResponse404Data")


@attr.s(auto_attribs=True)
class MessagesConversationResponse404Data:
    """
    Attributes:
        code (Union[Unset, MessagesConversationResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, MessagesConversationResponse404DataMessage]): The error message Example: Project with id 1
            not found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        messages_conversation_response_404_data = cls(
            code=code,
            message=message,
        )

        messages_conversation_response_404_data.additional_properties = src_dict
        return messages_conversation_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_404_data_code.py:
```
from enum import IntEnum


class MessagesConversationResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_404_data_message.py:
```
from enum import Enum


class MessagesConversationResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_404_status.py:
```
from enum import Enum


class MessagesConversationResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.messages_conversation_response_500_data import MessagesConversationResponse500Data


T = TypeVar("T", bound="MessagesConversationResponse500")


@attr.s(auto_attribs=True)
class MessagesConversationResponse500:
    """
    Attributes:
        status (Union[Unset, MessagesConversationResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, MessagesConversationResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "MessagesConversationResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.messages_conversation_response_500_data import MessagesConversationResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, MessagesConversationResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = MessagesConversationResponse500Data.from_dict(_data)

        messages_conversation_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        messages_conversation_response_500.additional_properties = src_dict
        return messages_conversation_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="MessagesConversationResponse500Data")


@attr.s(auto_attribs=True)
class MessagesConversationResponse500Data:
    """
    Attributes:
        code (Union[Unset, MessagesConversationResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        messages_conversation_response_500_data = cls(
            code=code,
            message=message,
        )

        messages_conversation_response_500_data.additional_properties = src_dict
        return messages_conversation_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_500_data_code.py:
```
from enum import IntEnum


class MessagesConversationResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/messages_conversation_response_500_status.py:
```
from enum import Enum


class MessagesConversationResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/open_graph_cache.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="OpenGraphCache")


@attr.s(auto_attribs=True)
class OpenGraphCache:
    """
    Attributes:
        id (Union[Unset, int]): The unique identifier of the citation Example: 1.
        title (Union[Unset, str]): The title of the page Example: Example Domain.
        page_url (Union[Unset, None, str]): The URL of the page Example: https://www.example.com.
        description (Union[Unset, None, str]): The description of the page Example: This domain is for use in
            illustrative examples in documents. You may use this domain in literature without prior coordination or asking
            for permission..
        image (Union[Unset, None, str]): The image of the page Example: https://www.example.com/image.png.
        image_width (Union[Unset, None, int]): The width of the image of the page Example: 1200.
        image_height (Union[Unset, None, int]): The height of the image of the page Example: 630.
        url (Union[Unset, None, str]): The URL of the page Example: https://www.example.com.
        favicon (Union[Unset, None, str]): The favicon of the page Example: https://www.example.com/favicon.ico.
        site_name (Union[Unset, None, str]): The site name of the page Example: Example Domain.
    """

    id: Union[Unset, int] = UNSET
    title: Union[Unset, str] = UNSET
    page_url: Union[Unset, None, str] = UNSET
    description: Union[Unset, None, str] = UNSET
    image: Union[Unset, None, str] = UNSET
    image_width: Union[Unset, None, int] = UNSET
    image_height: Union[Unset, None, int] = UNSET
    url: Union[Unset, None, str] = UNSET
    favicon: Union[Unset, None, str] = UNSET
    site_name: Union[Unset, None, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        title = self.title
        page_url = self.page_url
        description = self.description
        image = self.image
        image_width = self.image_width
        image_height = self.image_height
        url = self.url
        favicon = self.favicon
        site_name = self.site_name

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if title is not UNSET:
            field_dict["title"] = title
        if page_url is not UNSET:
            field_dict["page_url"] = page_url
        if description is not UNSET:
            field_dict["description"] = description
        if image is not UNSET:
            field_dict["image"] = image
        if image_width is not UNSET:
            field_dict["image_width"] = image_width
        if image_height is not UNSET:
            field_dict["image_height"] = image_height
        if url is not UNSET:
            field_dict["url"] = url
        if favicon is not UNSET:
            field_dict["favicon"] = favicon
        if site_name is not UNSET:
            field_dict["site_name"] = site_name

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        id = src_dict.get("id")

        title = src_dict.get("title")

        page_url = src_dict.get("page_url")

        description = src_dict.get("description")

        image = src_dict.get("image")

        image_width = src_dict.get("image_width")

        image_height = src_dict.get("image_height")

        url = src_dict.get("url")

        favicon = src_dict.get("favicon")

        site_name = src_dict.get("site_name")

        open_graph_cache = cls(
            id=id,
            title=title,
            page_url=page_url,
            description=description,
            image=image,
            image_width=image_width,
            image_height=image_height,
            url=url,
            favicon=favicon,
            site_name=site_name,
        )

        open_graph_cache.additional_properties = src_dict
        return open_graph_cache

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/page.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="Page")


@attr.s(auto_attribs=True)
class Page:
    r"""
    Attributes:
        id (Union[Unset, int]): Page ID Example: 1.
        page_url (Union[Unset, str]): URL of the page or file Example: https://example.com.
        page_url_hash (Union[Unset, str]): Hash of the URL of the page or file Example:
            d41d8cd98f00b204e9800998ecf8427e.
        project_id (Union[Unset, int]): Project ID Example: 1.
        s3_path (Union[Unset, None, str]): This is the path where the page is stored in S3.\nNote: This is omitted in
            the response if the page is not a file Example: project-1/page-1/file.pdf.
        crawl_status (Union[Unset, PageCrawlStatus]): Crawl status of the page Default: PageCrawlStatus.QUEUED. Example:
            queued.
        index_status (Union[Unset, PageIndexStatus]): Index status of the page Default: PageIndexStatus.QUEUED. Example:
            queued.
        is_file (Union[Unset, bool]): Whether the page is a file or not Example: True.
        is_file_kept (Union[Unset, bool]): Whether the file is kept after processing or not.\nNote: This is omitted in
            the response if the page is not a file Default: True. Example: True.
        filename (Union[Unset, None, str]): Filename of the page.\nNote: This is omitted in the response if the page is
            not a file Example: file.pdf.
        filesize (Union[Unset, None, int]): Filesize of the page.\nNote: This is omitted in the response if the page is
            not a file Example: 100.
        created_at (Union[Unset, datetime.datetime]): Date and time when the page was created Example: 2021-01-01
            00:00:00.
        updated_at (Union[Unset, datetime.datetime]): Date and time when the page was updated Example: 2021-01-01
            00:00:00.
        deleted_at (Union[Unset, datetime.datetime]): Date and time when the page was deleted Example: 2021-01-01
            00:00:00.
    """

    id: Union[Unset, int] = UNSET
    page_url: Union[Unset, str] = UNSET
    page_url_hash: Union[Unset, str] = UNSET
    project_id: Union[Unset, int] = UNSET
    s3_path: Union[Unset, None, str] = UNSET
    crawl_status: Union[Unset, str] = "queued"
    index_status: Union[Unset, str] = "queued"
    is_file: Union[Unset, bool] = False
    is_file_kept: Union[Unset, bool] = True
    filename: Union[Unset, None, str] = UNSET
    filesize: Union[Unset, None, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    deleted_at: Union[Unset, datetime.datetime] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        page_url = self.page_url
        page_url_hash = self.page_url_hash
        project_id = self.project_id
        s3_path = self.s3_path
        crawl_status: Union[Unset, str] = UNSET
        if not isinstance(self.crawl_status, Unset):
            crawl_status = self.crawl_status

        index_status: Union[Unset, str] = UNSET
        if not isinstance(self.index_status, Unset):
            index_status = self.index_status

        is_file = self.is_file
        is_file_kept = self.is_file_kept
        filename = self.filename
        filesize = self.filesize
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if page_url is not UNSET:
            field_dict["page_url"] = page_url
        if page_url_hash is not UNSET:
            field_dict["page_url_hash"] = page_url_hash
        if project_id is not UNSET:
            field_dict["project_id"] = project_id
        if s3_path is not UNSET:
            field_dict["s3_path"] = s3_path
        if crawl_status is not UNSET:
            field_dict["crawl_status"] = crawl_status
        if index_status is not UNSET:
            field_dict["index_status"] = index_status
        if is_file is not UNSET:
            field_dict["is_file"] = is_file
        if is_file_kept is not UNSET:
            field_dict["is_file_kept"] = is_file_kept
        if filename is not UNSET:
            field_dict["filename"] = filename
        if filesize is not UNSET:
            field_dict["filesize"] = filesize
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        id = src_dict.get("id")

        page_url = src_dict.get("page_url")

        page_url_hash = src_dict.get("page_url_hash")

        project_id = src_dict.get("project_id")

        s3_path = src_dict.get("s3_path")

        crawl_status = src_dict.get("crawl_status")

        index_status = src_dict.get("index_status")

        is_file = src_dict.get("is_file")

        is_file_kept = src_dict.get("is_file_kept")

        filename = src_dict.get("filename")

        filesize = src_dict.get("filesize")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, datetime.datetime]
        if isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        page = cls(
            id=id,
            page_url=page_url,
            page_url_hash=page_url_hash,
            project_id=project_id,
            s3_path=s3_path,
            crawl_status=crawl_status,
            index_status=index_status,
            is_file=is_file,
            is_file_kept=is_file_kept,
            filename=filename,
            filesize=filesize,
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
        )

        page.additional_properties = src_dict
        return page

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/page_crawl_status.py:
```
from enum import Enum


class PageCrawlStatus(str, Enum):
    FAILED = "failed"
    LIMITED = "limited"
    NA = "n/a"
    OK = "ok"
    QUEUED = "queued"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/page_index_status.py:
```
from enum import Enum


class PageIndexStatus(str, Enum):
    FAILED = "failed"
    LIMITED = "limited"
    NA = "n/a"
    OK = "ok"
    QUEUED = "queued"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/page_metadata.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="PageMetadata")


@attr.s(auto_attribs=True)
class PageMetadata:
    """
    Attributes:
        url (Union[Unset, str]): The URL of the page Example: https://www.example.com.
        title (Union[Unset, str]): The title of the page Example: Example Domain.
        description (Union[Unset, str]): The description of the page Example: This domain is for use in illustrative
            examples in documents. You may use this domain in literature without prior coordination or asking for
            permission..
        image (Union[Unset, str]): The image of the page Example: https://www.example.com/image.png.
    """

    url: Union[Unset, str] = UNSET
    title: Union[Unset, str] = UNSET
    description: Union[Unset, str] = UNSET
    image: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        url = self.url
        title = self.title
        description = self.description
        image = self.image

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if url is not UNSET:
            field_dict["url"] = url
        if title is not UNSET:
            field_dict["title"] = title
        if description is not UNSET:
            field_dict["description"] = description
        if image is not UNSET:
            field_dict["image"] = image

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        url = src_dict.get("url")

        title = src_dict.get("title")

        description = src_dict.get("description")

        image = src_dict.get("image")

        page_metadata = cls(
            url=url,
            title=title,
            description=description,
            image=image,
        )

        page_metadata.additional_properties = src_dict
        return page_metadata

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.preview_citation_response_400_data import PreviewCitationResponse400Data


T = TypeVar("T", bound="PreviewCitationResponse400")


@attr.s(auto_attribs=True)
class PreviewCitationResponse400:
    """
    Attributes:
        status (Union[Unset, PreviewCitationResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, PreviewCitationResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "PreviewCitationResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.preview_citation_response_400_data import PreviewCitationResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, PreviewCitationResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = PreviewCitationResponse400Data.from_dict(_data)

        preview_citation_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        preview_citation_response_400.additional_properties = src_dict
        return preview_citation_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="PreviewCitationResponse400Data")


@attr.s(auto_attribs=True)
class PreviewCitationResponse400Data:
    """
    Attributes:
        code (Union[Unset, PreviewCitationResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        preview_citation_response_400_data = cls(
            code=code,
            message=message,
        )

        preview_citation_response_400_data.additional_properties = src_dict
        return preview_citation_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_400_data_code.py:
```
from enum import IntEnum


class PreviewCitationResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_400_status.py:
```
from enum import Enum


class PreviewCitationResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.preview_citation_response_401_data import PreviewCitationResponse401Data


T = TypeVar("T", bound="PreviewCitationResponse401")


@attr.s(auto_attribs=True)
class PreviewCitationResponse401:
    """
    Attributes:
        status (Union[Unset, PreviewCitationResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, PreviewCitationResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "PreviewCitationResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.preview_citation_response_401_data import PreviewCitationResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, PreviewCitationResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = PreviewCitationResponse401Data.from_dict(_data)

        preview_citation_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        preview_citation_response_401.additional_properties = src_dict
        return preview_citation_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="PreviewCitationResponse401Data")


@attr.s(auto_attribs=True)
class PreviewCitationResponse401Data:
    """
    Attributes:
        code (Union[Unset, PreviewCitationResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        preview_citation_response_401_data = cls(
            code=code,
            message=message,
        )

        preview_citation_response_401_data.additional_properties = src_dict
        return preview_citation_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_401_data_code.py:
```
from enum import IntEnum


class PreviewCitationResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_401_status.py:
```
from enum import Enum


class PreviewCitationResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.preview_citation_response_404_data import PreviewCitationResponse404Data


T = TypeVar("T", bound="PreviewCitationResponse404")


@attr.s(auto_attribs=True)
class PreviewCitationResponse404:
    """
    Attributes:
        status (Union[Unset, PreviewCitationResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, PreviewCitationResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "PreviewCitationResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.preview_citation_response_404_data import PreviewCitationResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, PreviewCitationResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = PreviewCitationResponse404Data.from_dict(_data)

        preview_citation_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        preview_citation_response_404.additional_properties = src_dict
        return preview_citation_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="PreviewCitationResponse404Data")


@attr.s(auto_attribs=True)
class PreviewCitationResponse404Data:
    """
    Attributes:
        code (Union[Unset, PreviewCitationResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, PreviewCitationResponse404DataMessage]): The error message Example: Page with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Page with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        preview_citation_response_404_data = cls(
            code=code,
            message=message,
        )

        preview_citation_response_404_data.additional_properties = src_dict
        return preview_citation_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_404_data_code.py:
```
from enum import IntEnum


class PreviewCitationResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_404_data_message.py:
```
from enum import Enum


class PreviewCitationResponse404DataMessage(str, Enum):
    PAGE_ID_IS_REQUIRED = "Page id is required"
    PAGE_WITH_ID_PAGEID_NOT_FOUND = "Page with id {pageId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_404_status.py:
```
from enum import Enum


class PreviewCitationResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.preview_citation_response_500_data import PreviewCitationResponse500Data


T = TypeVar("T", bound="PreviewCitationResponse500")


@attr.s(auto_attribs=True)
class PreviewCitationResponse500:
    """
    Attributes:
        status (Union[Unset, PreviewCitationResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, PreviewCitationResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "PreviewCitationResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.preview_citation_response_500_data import PreviewCitationResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, PreviewCitationResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = PreviewCitationResponse500Data.from_dict(_data)

        preview_citation_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        preview_citation_response_500.additional_properties = src_dict
        return preview_citation_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="PreviewCitationResponse500Data")


@attr.s(auto_attribs=True)
class PreviewCitationResponse500Data:
    """
    Attributes:
        code (Union[Unset, PreviewCitationResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        preview_citation_response_500_data = cls(
            code=code,
            message=message,
        )

        preview_citation_response_500_data.additional_properties = src_dict
        return preview_citation_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_500_data_code.py:
```
from enum import IntEnum


class PreviewCitationResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/preview_citation_response_500_status.py:
```
from enum import Enum


class PreviewCitationResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/project.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="Project")


@attr.s(auto_attribs=True)
class Project:
    """
    Attributes:
        id (Union[Unset, int]): Project ID Example: 1.
        project_name (Union[Unset, str]): Project name Example: My Project.
        sitemap_path (Union[Unset, str]): Project sitemap Example: https://www.example.com/sitemap.xml.
        is_chat_active (Union[Unset, bool]): Whether the chat bot is active or not Example: True.
        user_id (Union[Unset, int]): User ID of the project owner Example: 1.
        created_at (Union[Unset, datetime.datetime]): Date and time when the project was created Default:
            isoparse('2023-05-08 13:06:55'). Example: 2021-01-01 00:00:00.
        updated_at (Union[Unset, datetime.datetime]): Date and time when the project was last updated Default:
            isoparse('2023-05-08 13:06:55'). Example: 2021-01-01 00:00:00.
        deleted_at (Union[Unset, None, datetime.datetime]): Date and time when the project was deleted Example:
            2021-01-01 00:00:00.
        type (Union[Unset, ProjectType]): Project type Default: ProjectType.SITEMAP. Example: SITEMAP.
        is_shared (Union[Unset, bool]): Whether the project is shared or not Example: True.
        shareable_slug (Union[Unset, None, str]): Shareable slug that can be used to share the project Example:
            1234567890abcdef1234567890abcdef.
        shareable_link (Union[Unset, None, str]): Shareable link that can be used to share the project
        embed_code (Union[Unset, None, str]): Embed code that can be used to embed the project
        live_chat_code (Union[Unset, None, str]): Live chat code that can be used to embed the live chat
    """

    id: Union[Unset, int] = UNSET
    project_name: Union[Unset, str] = UNSET
    sitemap_path: Union[Unset, str] = UNSET
    is_chat_active: Union[Unset, bool] = False
    user_id: Union[Unset, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = isoparse("2023-05-08 13:06:55")
    updated_at: Union[Unset, datetime.datetime] = isoparse("2023-05-08 13:06:55")
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    type: Union[Unset, str] = "SITEMAP"
    is_shared: Union[Unset, bool] = False
    shareable_slug: Union[Unset, None, str] = UNSET
    shareable_link: Union[Unset, None, str] = UNSET
    embed_code: Union[Unset, None, str] = UNSET
    live_chat_code: Union[Unset, None, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        project_name = self.project_name
        sitemap_path = self.sitemap_path
        is_chat_active = self.is_chat_active
        user_id = self.user_id
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        type: Union[Unset, str] = UNSET
        if not isinstance(self.type, Unset):
            type = self.type

        is_shared = self.is_shared
        shareable_slug = self.shareable_slug
        shareable_link = self.shareable_link
        embed_code = self.embed_code
        live_chat_code = self.live_chat_code

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if project_name is not UNSET:
            field_dict["project_name"] = project_name
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path
        if is_chat_active is not UNSET:
            field_dict["is_chat_active"] = is_chat_active
        if user_id is not UNSET:
            field_dict["user_id"] = user_id
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at
        if type is not UNSET:
            field_dict["type"] = type
        if is_shared is not UNSET:
            field_dict["is_shared"] = is_shared
        if shareable_slug is not UNSET:
            field_dict["shareable_slug"] = shareable_slug
        if shareable_link is not UNSET:
            field_dict["shareable_link"] = shareable_link
        if embed_code is not UNSET:
            field_dict["embed_code"] = embed_code
        if live_chat_code is not UNSET:
            field_dict["live_chat_code"] = live_chat_code

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        id = src_dict.get("id")

        project_name = src_dict.get("project_name")

        sitemap_path = src_dict.get("sitemap_path")

        is_chat_active = src_dict.get("is_chat_active")

        user_id = src_dict.get("user_id")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        type = src_dict.get("type")

        is_shared = src_dict.get("is_shared")

        shareable_slug = src_dict.get("shareable_slug")

        shareable_link = src_dict.get("shareable_link")

        embed_code = src_dict.get("embed_code")

        live_chat_code = src_dict.get("live_chat_code")

        project = cls(
            id=id,
            project_name=project_name,
            sitemap_path=sitemap_path,
            is_chat_active=is_chat_active,
            user_id=user_id,
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
            type=type,
            is_shared=is_shared,
            shareable_slug=shareable_slug,
            shareable_link=shareable_link,
            embed_code=embed_code,
            live_chat_code=live_chat_code,
        )

        project.additional_properties = src_dict
        return project

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/project_plugin.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ProjectPlugin")


@attr.s(auto_attribs=True)
class ProjectPlugin:
    """
    Attributes:
        model_name (Union[Unset, str]): Model Name Example: IndoorPlants.
        human_name (Union[Unset, str]): Name For Human Example: The Indoor Plants Channel.
        keywords (Union[Unset, str]): Keywords For Model Example: Indoor plants, Gardening, Trusted information..
        description (Union[Unset, str]): Description For Human Example: Trusted information about indoor plants and
            gardening..
        logo (Union[Unset, str]): Project plugin logo Example: https://app.customgpt.ai/logo.svg.
        is_active (Union[Unset, bool]): Whether the project plugin is active or not Example: True.
    """

    model_name: Union[Unset, str] = UNSET
    human_name: Union[Unset, str] = UNSET
    keywords: Union[Unset, str] = UNSET
    description: Union[Unset, str] = UNSET
    logo: Union[Unset, str] = UNSET
    is_active: Union[Unset, bool] = False
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        model_name = self.model_name
        human_name = self.human_name
        keywords = self.keywords
        description = self.description
        logo = self.logo
        is_active = self.is_active

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if model_name is not UNSET:
            field_dict["model_name"] = model_name
        if human_name is not UNSET:
            field_dict["human_name"] = human_name
        if keywords is not UNSET:
            field_dict["keywords"] = keywords
        if description is not UNSET:
            field_dict["description"] = description
        if logo is not UNSET:
            field_dict["logo"] = logo
        if is_active is not UNSET:
            field_dict["is_active"] = is_active

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        model_name = src_dict.get("model_name")

        human_name = src_dict.get("human_name")

        keywords = src_dict.get("keywords")

        description = src_dict.get("description")

        logo = src_dict.get("logo")

        is_active = src_dict.get("is_active")

        project_plugin = cls(
            model_name=model_name,
            human_name=human_name,
            keywords=keywords,
            description=description,
            logo=logo,
            is_active=is_active,
        )

        project_plugin.additional_properties = src_dict
        return project_plugin

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/project_settings.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union, cast

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ProjectSettings")


@attr.s(auto_attribs=True)
class ProjectSettings:
    """
    Attributes:
        chatbot_avatar (Union[Unset, str]): This is the avatar that is shown in the bot response. You can make it a
            profile picture or your company logo. Example: https://example.com/chatbot_avatar.png.
        chatbot_background (Union[Unset, str]): This is the background image shown in the bot conversations widget. You
            can change it to a company logo or background image. Example: https://example.com/chatbot_background.png.
        default_prompt (Union[Unset, str]): This is the default prompt shown to the user. You can customize this for
            your company or client. Example: How can I help you?.
        example_questions (Union[Unset, List[str]]): These are example questions shown to guide the bot users. You can
            create customized questions to suit your company or client needs. Example: ['How do I get started?'].
        response_source (Union[Unset, ProjectSettingsResponseSource]): By default, we ask ChatGPT to use only your
            content in its response (recommended). If you wish ChatGPT to improvise and use its own knowledgebase as well,
            you can select "My Content + ChatGPT" Example: own_content.
        chatbot_msg_lang (Union[Unset, str]): By default, the chatbot messages like 'Ask Me Anything' are in English.
            You can customize this to your preferred language. Please note: This setting does not control what language
            ChatGPT responds in. That is controlled by the user's question. So a user asking in Portuguese, will most likely
            get a response from ChatGPT in Portuguese. Example: en.
        chatbot_color (Union[Unset, str]): Color of the chatbot in hex format Example: #000000.
        persona_instructions (Union[Unset, None, str]): [Advanced Users] Customize your chatbot behavior by adjusting
            the system parameter to control its personality traits  and role. Example: You are a custom chatbot assistant
            called CustomGPT, a friendly lawyer who answers questions based on the given context..
        citations_answer_source_label_msg (Union[Unset, None, str]): This is the message shown to indicate where the
            response came from. You can customize this message based on your business or language. Example: Where did this
            answer come from?.
        citations_sources_label_msg (Union[Unset, None, str]): This is the message shown for the Sources label.  You can
            customize this message based on your business or language. Example: Sources.
        hang_in_there_msg (Union[Unset, None, str]): This is the message shown when the bot is thinking and waiting to
            answer. You can customize this message based on your tone, personality or language. Example: Hang in there! I'm
            thinking...
        chatbot_siesta_msg (Union[Unset, None, str]): This is the message shown when the bot has encountered a problem
            or error. You can customize this message based on your tone, personality or language. Example: Oops! The chat
            bot is taking a siesta. This usually happens when OpenAI is down! Please try again later..
        is_loading_indicator_enabled (Union[Unset, None, bool]): Show animated loading indicator while waiting for a
            response from the chatbot Default: True. Example: True.
        enable_citations (Union[Unset, None, bool]): Each chatbot response shows an option for the user to see the
            sources/citations from your content from which the response was generated. Default: True. Example: True.
        citations_view_type (Union[Unset, None, ProjectSettingsCitationsViewType]): Control how citations are shown. By
            default, the user can initiate to see the citations. You can choose to have it "Auto Shown" or "Auto Hide"
            Default: ProjectSettingsCitationsViewType.USER. Example: user.
        no_answer_message (Union[Unset, None, str]): This is the message shown when the bot cannot answer. You can
            customize it to a message asking the user to contact customer support or leave their email / phone. Example:
            Sorry, I don't have an answer for that..
        ending_message (Union[Unset, None, str]): You can instruct ChatGPT to end every response with some text like
            asking "Please email us for further support" (Not recommended for most use cases) Example: Please email us for
            further support.
        remove_branding (Union[Unset, None, bool]): Controls what branding is shown at the bottom of the chatbot.
    """

    chatbot_avatar: Union[Unset, str] = UNSET
    chatbot_background: Union[Unset, str] = UNSET
    default_prompt: Union[Unset, str] = UNSET
    example_questions: Union[Unset, List[str]] = UNSET
    response_source: Union[Unset, str] = "own_content"
    chatbot_msg_lang: Union[Unset, str] = UNSET
    chatbot_color: Union[Unset, str] = UNSET
    persona_instructions: Union[Unset, None, str] = UNSET
    citations_answer_source_label_msg: Union[Unset, None, str] = UNSET
    citations_sources_label_msg: Union[Unset, None, str] = UNSET
    hang_in_there_msg: Union[Unset, None, str] = UNSET
    chatbot_siesta_msg: Union[Unset, None, str] = UNSET
    is_loading_indicator_enabled: Union[Unset, None, bool] = True
    enable_citations: Union[Unset, None, bool] = True
    citations_view_type: Union[Unset, str] = "user"
    no_answer_message: Union[Unset, None, str] = UNSET
    ending_message: Union[Unset, None, str] = UNSET
    remove_branding: Union[Unset, None, bool] = False
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        chatbot_avatar = self.chatbot_avatar
        chatbot_background = self.chatbot_background
        default_prompt = self.default_prompt
        example_questions: Union[Unset, List[str]] = UNSET
        if not isinstance(self.example_questions, Unset):
            example_questions = self.example_questions

        response_source: Union[Unset, str] = UNSET
        if not isinstance(self.response_source, Unset):
            response_source = self.response_source

        chatbot_msg_lang = self.chatbot_msg_lang
        chatbot_color = self.chatbot_color
        persona_instructions = self.persona_instructions
        citations_answer_source_label_msg = self.citations_answer_source_label_msg
        citations_sources_label_msg = self.citations_sources_label_msg
        hang_in_there_msg = self.hang_in_there_msg
        chatbot_siesta_msg = self.chatbot_siesta_msg
        is_loading_indicator_enabled = self.is_loading_indicator_enabled
        enable_citations = self.enable_citations
        citations_view_type: Union[Unset, None, str] = UNSET
        if not isinstance(self.citations_view_type, Unset):
            citations_view_type = self.citations_view_type if self.citations_view_type else None

        no_answer_message = self.no_answer_message
        ending_message = self.ending_message
        remove_branding = self.remove_branding

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if chatbot_avatar is not UNSET:
            field_dict["chatbot_avatar"] = chatbot_avatar
        if chatbot_background is not UNSET:
            field_dict["chatbot_background"] = chatbot_background
        if default_prompt is not UNSET:
            field_dict["default_prompt"] = default_prompt
        if example_questions is not UNSET:
            for index, field_value in enumerate(example_questions):
                field_dict[f"example_questions[]"] = field_value
        if response_source is not UNSET:
            field_dict["response_source"] = response_source
        if chatbot_msg_lang is not UNSET:
            field_dict["chatbot_msg_lang"] = chatbot_msg_lang
        if chatbot_color is not UNSET:
            field_dict["chatbot_color"] = chatbot_color
        if persona_instructions is not UNSET:
            field_dict["persona_instructions"] = persona_instructions
        if citations_answer_source_label_msg is not UNSET:
            field_dict["citations_answer_source_label_msg"] = citations_answer_source_label_msg
        if citations_sources_label_msg is not UNSET:
            field_dict["citations_sources_label_msg"] = citations_sources_label_msg
        if hang_in_there_msg is not UNSET:
            field_dict["hang_in_there_msg"] = hang_in_there_msg
        if chatbot_siesta_msg is not UNSET:
            field_dict["chatbot_siesta_msg"] = chatbot_siesta_msg
        if is_loading_indicator_enabled is not UNSET:
            field_dict["is_loading_indicator_enabled"] = is_loading_indicator_enabled
        if enable_citations is not UNSET:
            field_dict["enable_citations"] = enable_citations
        if citations_view_type is not UNSET:
            field_dict["citations_view_type"] = citations_view_type
        if no_answer_message is not UNSET:
            field_dict["no_answer_message"] = no_answer_message
        if ending_message is not UNSET:
            field_dict["ending_message"] = ending_message
        if remove_branding is not UNSET:
            field_dict["remove_branding"] = remove_branding

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        chatbot_avatar = src_dict.get("chatbot_avatar")

        chatbot_background = src_dict.get("chatbot_background")

        default_prompt = src_dict.get("default_prompt")

        example_questions = cast(List[str], src_dict.get("example_questions"))

        response_source = src_dict.get("response_source")

        chatbot_msg_lang = src_dict.get("chatbot_msg_lang")

        chatbot_color = src_dict.get("chatbot_color")

        persona_instructions = src_dict.get("persona_instructions")

        citations_answer_source_label_msg = src_dict.get("citations_answer_source_label_msg")

        citations_sources_label_msg = src_dict.get("citations_sources_label_msg")

        hang_in_there_msg = src_dict.get("hang_in_there_msg")

        chatbot_siesta_msg = src_dict.get("chatbot_siesta_msg")

        is_loading_indicator_enabled = src_dict.get("is_loading_indicator_enabled")

        enable_citations = src_dict.get("enable_citations")

        citations_view_type = src_dict.get("citations_view_type")

        no_answer_message = src_dict.get("no_answer_message")

        ending_message = src_dict.get("ending_message")

        remove_branding = src_dict.get("remove_branding")

        project_settings = cls(
            chatbot_avatar=chatbot_avatar,
            chatbot_background=chatbot_background,
            default_prompt=default_prompt,
            example_questions=example_questions,
            response_source=response_source,
            chatbot_msg_lang=chatbot_msg_lang,
            chatbot_color=chatbot_color,
            persona_instructions=persona_instructions,
            citations_answer_source_label_msg=citations_answer_source_label_msg,
            citations_sources_label_msg=citations_sources_label_msg,
            hang_in_there_msg=hang_in_there_msg,
            chatbot_siesta_msg=chatbot_siesta_msg,
            is_loading_indicator_enabled=is_loading_indicator_enabled,
            enable_citations=enable_citations,
            citations_view_type=citations_view_type,
            no_answer_message=no_answer_message,
            ending_message=ending_message,
            remove_branding=remove_branding,
        )

        project_settings.additional_properties = src_dict
        return project_settings

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/project_settings_citations_view_type.py:
```
from enum import Enum


class ProjectSettingsCitationsViewType(str, Enum):
    HIDE = "hide"
    SHOW = "show"
    USER = "user"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/project_settings_response_source.py:
```
from enum import Enum


class ProjectSettingsResponseSource(str, Enum):
    DEFAULT = "default"
    OPENAI_CONTENT = "openai_content"
    OWN_CONTENT = "own_content"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/project_source.py:
```
import datetime
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.page import Page
    from ..models.project_source_settings import ProjectSourceSettings


T = TypeVar("T", bound="ProjectSource")


@attr.s(auto_attribs=True)
class ProjectSource:
    """
    Attributes:
        id (Union[Unset, int]): The project source ID Example: 1.
        created_at (Union[Unset, datetime.datetime]): The project source creation date Example: 2021-01-01 00:00:00.
        updated_at (Union[Unset, datetime.datetime]): The project source update date Example: 2021-01-01 00:00:00.
        type (Union[Unset, ProjectSourceType]): The project source type Example: sitemap.
        settings (Union[Unset, ProjectSourceSettings]): The project source settings
        pages (Union[Unset, None, List['Page']]): The project source pages
    """

    id: Union[Unset, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    type: Union[Unset, str] = "sitemap"
    settings: Union[Unset, "ProjectSourceSettings"] = UNSET
    pages: Union[Unset, None, List["Page"]] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        type: Union[Unset, str] = UNSET
        if not isinstance(self.type, Unset):
            type = self.type

        settings: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.settings, Unset):
            settings = self.settings.to_dict()

        pages: Union[Unset, None, List[Dict[str, Any]]] = UNSET
        if not isinstance(self.pages, Unset):
            if self.pages is None:
                pages = None
            else:
                pages = []
                for pages_item_data in self.pages:
                    pages_item = pages_item_data.to_dict()

                    pages.append(pages_item)

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if type is not UNSET:
            field_dict["type"] = type
        if settings is not UNSET:
            field_dict["settings"] = settings
        if pages is not UNSET:
            for index, field_value in enumerate(pages):
                field_dict[f"pages[]"] = field_value

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.page import Page
        from ..models.project_source_settings import ProjectSourceSettings

        id = src_dict.get("id")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        type = src_dict.get("type")

        _settings = src_dict.get("settings")
        settings: Union[Unset, ProjectSourceSettings]
        if isinstance(_settings, Unset):
            settings = UNSET
        else:
            settings = ProjectSourceSettings.from_dict(_settings)

        pages = []
        _pages = src_dict.get("pages")
        for pages_item_data in _pages or []:
            pages_item = Page.from_dict(pages_item_data)

            pages.append(pages_item)

        project_source = cls(
            id=id,
            created_at=created_at,
            updated_at=updated_at,
            type=type,
            settings=settings,
            pages=pages,
        )

        project_source.additional_properties = src_dict
        return project_source

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/project_source_settings.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ProjectSourceSettings")


@attr.s(auto_attribs=True)
class ProjectSourceSettings:
    """The project source settings

    Attributes:
        data_refresh (Union[Unset, bool]): Whether the project source data should be refreshed Example: True.
        executive_js (Union[Unset, bool]): Whether the project source should execute JavaScript Default: True. Example:
            True.
        data_refresh_frequency (Union[Unset, str]): The project source data refresh frequency Default: 'never'. Example:
            never.
        sitemap_path (Union[Unset, str]): The project source sitemap path Example: https://example.com/sitemap.xml.
    """

    data_refresh: Union[Unset, bool] = False
    executive_js: Union[Unset, bool] = True
    data_refresh_frequency: Union[Unset, str] = "never"
    sitemap_path: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        data_refresh = self.data_refresh
        executive_js = self.executive_js
        data_refresh_frequency = self.data_refresh_frequency
        sitemap_path = self.sitemap_path

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if data_refresh is not UNSET:
            field_dict["data_refresh"] = data_refresh
        if executive_js is not UNSET:
            field_dict["executive_js"] = executive_js
        if data_refresh_frequency is not UNSET:
            field_dict["data_refresh_frequency"] = data_refresh_frequency
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        data_refresh = src_dict.get("data_refresh")

        executive_js = src_dict.get("executive_js")

        data_refresh_frequency = src_dict.get("data_refresh_frequency")

        sitemap_path = src_dict.get("sitemap_path")

        project_source_settings = cls(
            data_refresh=data_refresh,
            executive_js=executive_js,
            data_refresh_frequency=data_refresh_frequency,
            sitemap_path=sitemap_path,
        )

        project_source_settings.additional_properties = src_dict
        return project_source_settings

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/project_source_type.py:
```
from enum import Enum


class ProjectSourceType(str, Enum):
    SITEMAP = "sitemap"
    UPLOAD = "upload"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/project_type.py:
```
from enum import Enum


class ProjectType(str, Enum):
    SITEMAP = "SITEMAP"
    URL = "URL"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/prompt_history.py:
```
import datetime
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union, cast

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.prompt_history_metadata import PromptHistoryMetadata


T = TypeVar("T", bound="PromptHistory")


@attr.s(auto_attribs=True)
class PromptHistory:
    """
    Attributes:
        id (Union[Unset, int]): The unique identifier of the prompt history. Example: 1.
        user_id (Union[Unset, int]): The unique identifier of the user. Example: 1.
        user_query (Union[Unset, str]): The user prompt query. Example: What is the meaning of life?.
        openai_response (Union[Unset, str]): The OpenAI response to the user prompt query. Example: The meaning of life
            is to be happy..
        created_at (Union[Unset, datetime.datetime]): The date and time the prompt history was created. Example:
            2021-01-01 00:00:00.
        updated_at (Union[Unset, datetime.datetime]): The date and time the prompt history was last updated. Example:
            2021-01-01 00:00:00.
        conversation_id (Union[Unset, int]): The unique identifier of the conversation. Example: 1.
        citations (Union[Unset, List[int]]): The citations for the prompt history. Example: [1, 2, 3].
        metadata (Union[Unset, PromptHistoryMetadata]):  Example: {'user_ip': '127.0.0.1', 'user_agent': 'Mozilla/5.0
            (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko)', 'external_id': 'ext_id_1234567890',
            'request_source': 'web'}.
    """

    id: Union[Unset, int] = UNSET
    user_id: Union[Unset, int] = UNSET
    user_query: Union[Unset, str] = UNSET
    openai_response: Union[Unset, str] = UNSET
    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    conversation_id: Union[Unset, int] = UNSET
    citations: Union[Unset, List[int]] = UNSET
    metadata: Union[Unset, "PromptHistoryMetadata"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        user_id = self.user_id
        user_query = self.user_query
        openai_response = self.openai_response
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        conversation_id = self.conversation_id
        citations: Union[Unset, List[int]] = UNSET
        if not isinstance(self.citations, Unset):
            citations = self.citations

        metadata: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.metadata, Unset):
            metadata = self.metadata.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if user_id is not UNSET:
            field_dict["user_id"] = user_id
        if user_query is not UNSET:
            field_dict["user_query"] = user_query
        if openai_response is not UNSET:
            field_dict["openai_response"] = openai_response
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if conversation_id is not UNSET:
            field_dict["conversation_id"] = conversation_id
        if citations is not UNSET:
            for index, field_value in enumerate(citations):
                field_dict[f"citations[]"] = field_value
        if metadata is not UNSET:
            field_dict["metadata"] = metadata

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.prompt_history_metadata import PromptHistoryMetadata

        id = src_dict.get("id")

        user_id = src_dict.get("user_id")

        user_query = src_dict.get("user_query")

        openai_response = src_dict.get("openai_response")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        conversation_id = src_dict.get("conversation_id")

        citations = cast(List[int], src_dict.get("citations"))

        _metadata = src_dict.get("metadata")
        metadata: Union[Unset, PromptHistoryMetadata]
        if isinstance(_metadata, Unset):
            metadata = UNSET
        else:
            metadata = PromptHistoryMetadata.from_dict(_metadata)

        prompt_history = cls(
            id=id,
            user_id=user_id,
            user_query=user_query,
            openai_response=openai_response,
            created_at=created_at,
            updated_at=updated_at,
            conversation_id=conversation_id,
            citations=citations,
            metadata=metadata,
        )

        prompt_history.additional_properties = src_dict
        return prompt_history

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/prompt_history_metadata.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="PromptHistoryMetadata")


@attr.s(auto_attribs=True)
class PromptHistoryMetadata:
    """
    Example:
        {'user_ip': '127.0.0.1', 'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36
            (KHTML, like Gecko)', 'external_id': 'ext_id_1234567890', 'request_source': 'web'}

    Attributes:
        user_ip (Union[Unset, str]): The IP address of the user. Example: 127.0.0.1.
        user_agent (Union[Unset, str]): The user agent of the user. Example: Mozilla/5.0 (Macintosh; Intel Mac OS X
            10_15_7) AppleWebKit/537.36 (KHTML, like Gecko).
        external_id (Union[Unset, str]): The external ID of the prompt history. Example: ext_id_1234567890.
        request_source (Union[Unset, str]): The source of the request. Example: web.
    """

    user_ip: Union[Unset, str] = UNSET
    user_agent: Union[Unset, str] = UNSET
    external_id: Union[Unset, str] = UNSET
    request_source: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        user_ip = self.user_ip
        user_agent = self.user_agent
        external_id = self.external_id
        request_source = self.request_source

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if user_ip is not UNSET:
            field_dict["user_ip"] = user_ip
        if user_agent is not UNSET:
            field_dict["user_agent"] = user_agent
        if external_id is not UNSET:
            field_dict["external_id"] = external_id
        if request_source is not UNSET:
            field_dict["request_source"] = request_source

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        user_ip = src_dict.get("user_ip")

        user_agent = src_dict.get("user_agent")

        external_id = src_dict.get("external_id")

        request_source = src_dict.get("request_source")

        prompt_history_metadata = cls(
            user_ip=user_ip,
            user_agent=user_agent,
            external_id=external_id,
            request_source=request_source,
        )

        prompt_history_metadata.additional_properties = src_dict
        return prompt_history_metadata

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.reindex_page_response_200_data import ReindexPageResponse200Data


T = TypeVar("T", bound="ReindexPageResponse200")


@attr.s(auto_attribs=True)
class ReindexPageResponse200:
    """
    Attributes:
        status (Union[Unset, ReindexPageResponse200Status]): The status of the response Example: success.
        data (Union[Unset, ReindexPageResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "ReindexPageResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.reindex_page_response_200_data import ReindexPageResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, ReindexPageResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = ReindexPageResponse200Data.from_dict(_data)

        reindex_page_response_200 = cls(
            status=status,
            data=data,
        )

        reindex_page_response_200.additional_properties = src_dict
        return reindex_page_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_200_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ReindexPageResponse200Data")


@attr.s(auto_attribs=True)
class ReindexPageResponse200Data:
    """
    Attributes:
        updated (Union[Unset, bool]): Whether the page start reindex process successfully or not Example: True.
    """

    updated: Union[Unset, bool] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        updated = self.updated

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if updated is not UNSET:
            field_dict["updated"] = updated

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        updated = src_dict.get("updated")

        reindex_page_response_200_data = cls(
            updated=updated,
        )

        reindex_page_response_200_data.additional_properties = src_dict
        return reindex_page_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_200_status.py:
```
from enum import Enum


class ReindexPageResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.reindex_page_response_400_data import ReindexPageResponse400Data


T = TypeVar("T", bound="ReindexPageResponse400")


@attr.s(auto_attribs=True)
class ReindexPageResponse400:
    """
    Attributes:
        status (Union[Unset, ReindexPageResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, ReindexPageResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "ReindexPageResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.reindex_page_response_400_data import ReindexPageResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, ReindexPageResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = ReindexPageResponse400Data.from_dict(_data)

        reindex_page_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        reindex_page_response_400.additional_properties = src_dict
        return reindex_page_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ReindexPageResponse400Data")


@attr.s(auto_attribs=True)
class ReindexPageResponse400Data:
    """
    Attributes:
        code (Union[Unset, ReindexPageResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        reindex_page_response_400_data = cls(
            code=code,
            message=message,
        )

        reindex_page_response_400_data.additional_properties = src_dict
        return reindex_page_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_400_data_code.py:
```
from enum import IntEnum


class ReindexPageResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_400_status.py:
```
from enum import Enum


class ReindexPageResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.reindex_page_response_401_data import ReindexPageResponse401Data


T = TypeVar("T", bound="ReindexPageResponse401")


@attr.s(auto_attribs=True)
class ReindexPageResponse401:
    """
    Attributes:
        status (Union[Unset, ReindexPageResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, ReindexPageResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "ReindexPageResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.reindex_page_response_401_data import ReindexPageResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, ReindexPageResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = ReindexPageResponse401Data.from_dict(_data)

        reindex_page_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        reindex_page_response_401.additional_properties = src_dict
        return reindex_page_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ReindexPageResponse401Data")


@attr.s(auto_attribs=True)
class ReindexPageResponse401Data:
    """
    Attributes:
        code (Union[Unset, ReindexPageResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        reindex_page_response_401_data = cls(
            code=code,
            message=message,
        )

        reindex_page_response_401_data.additional_properties = src_dict
        return reindex_page_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_401_data_code.py:
```
from enum import IntEnum


class ReindexPageResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_401_status.py:
```
from enum import Enum


class ReindexPageResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_403.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.reindex_page_response_403_data import ReindexPageResponse403Data


T = TypeVar("T", bound="ReindexPageResponse403")


@attr.s(auto_attribs=True)
class ReindexPageResponse403:
    """
    Attributes:
        status (Union[Unset, ReindexPageResponse403Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, ReindexPageResponse403Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "ReindexPageResponse403Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.reindex_page_response_403_data import ReindexPageResponse403Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, ReindexPageResponse403Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = ReindexPageResponse403Data.from_dict(_data)

        reindex_page_response_403 = cls(
            status=status,
            url=url,
            data=data,
        )

        reindex_page_response_403.additional_properties = src_dict
        return reindex_page_response_403

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_403_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ReindexPageResponse403Data")


@attr.s(auto_attribs=True)
class ReindexPageResponse403Data:
    """
    Attributes:
        code (Union[Unset, ReindexPageResponse403DataCode]): The error status code Example: 400.
        message (Union[Unset, ReindexPageResponse403DataMessage]): The error message Example: Page with id 1 cannot be
            reindexed.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = "Page with id 1 cannot be reindexed"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        reindex_page_response_403_data = cls(
            code=code,
            message=message,
        )

        reindex_page_response_403_data.additional_properties = src_dict
        return reindex_page_response_403_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_403_data_code.py:
```
from enum import IntEnum


class ReindexPageResponse403DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_403_data_message.py:
```
from enum import Enum


class ReindexPageResponse403DataMessage(str, Enum):
    PAGE_WITH_ID_PAGEID_CANNOT_BE_REINDEXED = "Page with id {pageId} cannot be reindexed"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_403_status.py:
```
from enum import Enum


class ReindexPageResponse403Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.reindex_page_response_500_data import ReindexPageResponse500Data


T = TypeVar("T", bound="ReindexPageResponse500")


@attr.s(auto_attribs=True)
class ReindexPageResponse500:
    """
    Attributes:
        status (Union[Unset, ReindexPageResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, ReindexPageResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "ReindexPageResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.reindex_page_response_500_data import ReindexPageResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, ReindexPageResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = ReindexPageResponse500Data.from_dict(_data)

        reindex_page_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        reindex_page_response_500.additional_properties = src_dict
        return reindex_page_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="ReindexPageResponse500Data")


@attr.s(auto_attribs=True)
class ReindexPageResponse500Data:
    """
    Attributes:
        code (Union[Unset, ReindexPageResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        reindex_page_response_500_data = cls(
            code=code,
            message=message,
        )

        reindex_page_response_500_data.additional_properties = src_dict
        return reindex_page_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_500_data_code.py:
```
from enum import IntEnum


class ReindexPageResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/reindex_page_response_500_status.py:
```
from enum import Enum


class ReindexPageResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/send_message_json_body.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="SendMessageJsonBody")


@attr.s(auto_attribs=True)
class SendMessageJsonBody:
    """
    Attributes:
        prompt (Union[Unset, str]): Prompt to send to OpenAI Example: Write me hello world program in C.
        custom_persona (Union[Unset, None, str]): Custom persona to use for the conversation Example: You are a custom
            chatbot assistant called *bot name*, a friendly *bot role* who works for *organization* and answers questions
            based on the given context. Be as helpful as possible. Always prioritize the customer. Escalate complex issues.
            Stay on topic. Use appropriate language, Acknowledge limitations..
    """

    prompt: Union[Unset, str] = UNSET
    custom_persona: Union[Unset, None, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        prompt = self.prompt
        custom_persona = self.custom_persona

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if prompt is not UNSET:
            field_dict["prompt"] = prompt
        if custom_persona is not UNSET:
            field_dict["custom_persona"] = custom_persona

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        prompt = src_dict.get("prompt")

        custom_persona = src_dict.get("custom_persona")

        send_message_json_body = cls(
            prompt=prompt,
            custom_persona=custom_persona,
        )

        send_message_json_body.additional_properties = src_dict
        return send_message_json_body

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/send_message_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.send_message_response_200_data import SendMessageResponse200Data


T = TypeVar("T", bound="SendMessageResponse200")


@attr.s(auto_attribs=True)
class SendMessageResponse200:
    """
    Attributes:
        status (Union[Unset, SendMessageResponse200Status]): The status of the response Example: success.
        data (Union[Unset, SendMessageResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "SendMessageResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.send_message_response_200_data import SendMessageResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, SendMessageResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = SendMessageResponse200Data.from_dict(_data)

        send_message_response_200 = cls(
            status=status,
            data=data,
        )

        send_message_response_200.additional_properties = src_dict
        return send_message_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/send_message_response_200_data.py:
```
import datetime
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union, cast

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.send_message_response_200_data_metadata import SendMessageResponse200DataMetadata


T = TypeVar("T", bound="SendMessageResponse200Data")


@attr.s(auto_attribs=True)
class SendMessageResponse200Data:
    """
    Attributes:
        id (Union[Unset, int]): The unique identifier of the prompt history. Example: 1.
        user_id (Union[Unset, int]): The unique identifier of the user. Example: 1.
        user_query (Union[Unset, str]): The user prompt query. Example: What is the meaning of life?.
        openai_response (Union[Unset, str]): The OpenAI response to the user prompt query. Example: The meaning of life
            is to be happy..
        created_at (Union[Unset, datetime.datetime]): The date and time the prompt history was created. Example:
            2021-01-01 00:00:00.
        updated_at (Union[Unset, datetime.datetime]): The date and time the prompt history was last updated. Example:
            2021-01-01 00:00:00.
        conversation_id (Union[Unset, int]): The unique identifier of the conversation. Example: 1.
        citations (Union[Unset, List[int]]): The citations for the prompt history. Example: [1, 2, 3].
        metadata (Union[Unset, SendMessageResponse200DataMetadata]):  Example: {'user_ip': '127.0.0.1', 'user_agent':
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko)', 'external_id':
            'ext_id_1234567890', 'request_source': 'web'}.
    """

    id: Union[Unset, int] = UNSET
    user_id: Union[Unset, int] = UNSET
    user_query: Union[Unset, str] = UNSET
    openai_response: Union[Unset, str] = UNSET
    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    conversation_id: Union[Unset, int] = UNSET
    citations: Union[Unset, List[int]] = UNSET
    metadata: Union[Unset, "SendMessageResponse200DataMetadata"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        user_id = self.user_id
        user_query = self.user_query
        openai_response = self.openai_response
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        conversation_id = self.conversation_id
        citations: Union[Unset, List[int]] = UNSET
        if not isinstance(self.citations, Unset):
            citations = self.citations

        metadata: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.metadata, Unset):
            metadata = self.metadata.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if user_id is not UNSET:
            field_dict["user_id"] = user_id
        if user_query is not UNSET:
            field_dict["user_query"] = user_query
        if openai_response is not UNSET:
            field_dict["openai_response"] = openai_response
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if conversation_id is not UNSET:
            field_dict["conversation_id"] = conversation_id
        if citations is not UNSET:
            for index, field_value in enumerate(citations):
                field_dict[f"citations[]"] = field_value
        if metadata is not UNSET:
            field_dict["metadata"] = metadata

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.send_message_response_200_data_metadata import SendMessageResponse200DataMetadata

        id = src_dict.get("id")

        user_id = src_dict.get("user_id")

        user_query = src_dict.get("user_query")

        openai_response = src_dict.get("openai_response")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        conversation_id = src_dict.get("conversation_id")

        citations = cast(List[int], src_dict.get("citations"))

        _metadata = src_dict.get("metadata")
        metadata: Union[Unset, SendMessageResponse200DataMetadata]
        if isinstance(_metadata, Unset):
            metadata = UNSET
        else:
            metadata = SendMessageResponse200DataMetadata.from_dict(_metadata)

        send_message_response_200_data = cls(
            id=id,
            user_id=user_id,
            user_query=user_query,
            openai_response=openai_response,
            created_at=created_at,
            updated_at=updated_at,
            conversation_id=conversation_id,
            citations=citations,
            metadata=metadata,
        )

        send_message_response_200_data.additional_properties = src_dict
        return send_message_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/send_message_response_200_data_metadata.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="SendMessageResponse200DataMetadata")


@attr.s(auto_attribs=True)
class SendMessageResponse200DataMetadata:
    """
    Example:
        {'user_ip': '127.0.0.1', 'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36
            (KHTML, like Gecko)', 'external_id': 'ext_id_1234567890', 'request_source': 'web'}

    Attributes:
        user_ip (Union[Unset, str]): The IP address of the user. Example: 127.0.0.1.
        user_agent (Union[Unset, str]): The user agent of the user. Example: Mozilla/5.0 (Macintosh; Intel Mac OS X
            10_15_7) AppleWebKit/537.36 (KHTML, like Gecko).
        external_id (Union[Unset, str]): The external ID of the prompt history. Example: ext_id_1234567890.
        request_source (Union[Unset, str]): The source of the request. Example: web.
    """

    user_ip: Union[Unset, str] = UNSET
    user_agent: Union[Unset, str] = UNSET
    external_id: Union[Unset, str] = UNSET
    request_source: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        user_ip = self.user_ip
        user_agent = self.user_agent
        external_id = self.external_id
        request_source = self.request_source

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if user_ip is not UNSET:
            field_dict["user_ip"] = user_ip
        if user_agent is not UNSET:
            field_dict["user_agent"] = user_agent
        if external_id is not UNSET:
            field_dict["external_id"] = external_id
        if request_source is not UNSET:
            field_dict["request_source"] = request_source

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        user_ip = src_dict.get("user_ip")

        user_agent = src_dict.get("user_agent")

        external_id = src_dict.get("external_id")

        request_source = src_dict.get("request_source")

        send_message_response_200_data_metadata = cls(
            user_ip=user_ip,
            user_agent=user_agent,
            external_id=external_id,
            request_source=request_source,
        )

        send_message_response_200_data_metadata.additional_properties = src_dict
        return send_message_response_200_data_metadata

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/send_message_response_200_status.py:
```
from enum import Enum


class SendMessageResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/send_message_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.send_message_response_400_data import SendMessageResponse400Data


T = TypeVar("T", bound="SendMessageResponse400")


@attr.s(auto_attribs=True)
class SendMessageResponse400:
    """
    Attributes:
        status (Union[Unset, SendMessageResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, SendMessageResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "SendMessageResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.send_message_response_400_data import SendMessageResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, SendMessageResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = SendMessageResponse400Data.from_dict(_data)

        send_message_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        send_message_response_400.additional_properties = src_dict
        return send_message_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/send_message_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="SendMessageResponse400Data")


@attr.s(auto_attribs=True)
class SendMessageResponse400Data:
    """
    Attributes:
        code (Union[Unset, SendMessageResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        send_message_response_400_data = cls(
            code=code,
            message=message,
        )

        send_message_response_400_data.additional_properties = src_dict
        return send_message_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/send_message_response_400_data_code.py:
```
from enum import IntEnum


class SendMessageResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/send_message_response_400_status.py:
```
from enum import Enum


class SendMessageResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/send_message_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.send_message_response_401_data import SendMessageResponse401Data


T = TypeVar("T", bound="SendMessageResponse401")


@attr.s(auto_attribs=True)
class SendMessageResponse401:
    """
    Attributes:
        status (Union[Unset, SendMessageResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, SendMessageResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "SendMessageResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.send_message_response_401_data import SendMessageResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, SendMessageResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = SendMessageResponse401Data.from_dict(_data)

        send_message_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        send_message_response_401.additional_properties = src_dict
        return send_message_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/send_message_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="SendMessageResponse401Data")


@attr.s(auto_attribs=True)
class SendMessageResponse401Data:
    """
    Attributes:
        code (Union[Unset, SendMessageResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        send_message_response_401_data = cls(
            code=code,
            message=message,
        )

        send_message_response_401_data.additional_properties = src_dict
        return send_message_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/send_message_response_401_data_code.py:
```
from enum import IntEnum


class SendMessageResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/send_message_response_401_status.py:
```
from enum import Enum


class SendMessageResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/send_message_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.send_message_response_404_data import SendMessageResponse404Data


T = TypeVar("T", bound="SendMessageResponse404")


@attr.s(auto_attribs=True)
class SendMessageResponse404:
    """
    Attributes:
        status (Union[Unset, SendMessageResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, SendMessageResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "SendMessageResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.send_message_response_404_data import SendMessageResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, SendMessageResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = SendMessageResponse404Data.from_dict(_data)

        send_message_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        send_message_response_404.additional_properties = src_dict
        return send_message_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/send_message_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="SendMessageResponse404Data")


@attr.s(auto_attribs=True)
class SendMessageResponse404Data:
    """
    Attributes:
        code (Union[Unset, SendMessageResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, SendMessageResponse404DataMessage]): The error message Example: Project with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        send_message_response_404_data = cls(
            code=code,
            message=message,
        )

        send_message_response_404_data.additional_properties = src_dict
        return send_message_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/send_message_response_404_data_code.py:
```
from enum import IntEnum


class SendMessageResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/send_message_response_404_data_message.py:
```
from enum import Enum


class SendMessageResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/send_message_response_404_status.py:
```
from enum import Enum


class SendMessageResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/send_message_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.send_message_response_500_data import SendMessageResponse500Data


T = TypeVar("T", bound="SendMessageResponse500")


@attr.s(auto_attribs=True)
class SendMessageResponse500:
    """
    Attributes:
        status (Union[Unset, SendMessageResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, SendMessageResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "SendMessageResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.send_message_response_500_data import SendMessageResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, SendMessageResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = SendMessageResponse500Data.from_dict(_data)

        send_message_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        send_message_response_500.additional_properties = src_dict
        return send_message_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/send_message_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="SendMessageResponse500Data")


@attr.s(auto_attribs=True)
class SendMessageResponse500Data:
    """
    Attributes:
        code (Union[Unset, SendMessageResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        send_message_response_500_data = cls(
            code=code,
            message=message,
        )

        send_message_response_500_data.additional_properties = src_dict
        return send_message_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/send_message_response_500_data_code.py:
```
from enum import IntEnum


class SendMessageResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/send_message_response_500_status.py:
```
from enum import Enum


class SendMessageResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.stats_project_response_200_data import StatsProjectResponse200Data


T = TypeVar("T", bound="StatsProjectResponse200")


@attr.s(auto_attribs=True)
class StatsProjectResponse200:
    """
    Attributes:
        status (Union[Unset, StatsProjectResponse200Status]): The status of the response Example: success.
        data (Union[Unset, StatsProjectResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "StatsProjectResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.stats_project_response_200_data import StatsProjectResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, StatsProjectResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = StatsProjectResponse200Data.from_dict(_data)

        stats_project_response_200 = cls(
            status=status,
            data=data,
        )

        stats_project_response_200.additional_properties = src_dict
        return stats_project_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_200_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="StatsProjectResponse200Data")


@attr.s(auto_attribs=True)
class StatsProjectResponse200Data:
    """
    Attributes:
        pages_found (Union[Unset, int]): Number of pages found for the project Example: 100.
        pages_crawled (Union[Unset, int]): Number of pages crawled for the project Example: 100.
        pages_indexed (Union[Unset, int]): Number of pages indexed for the project Example: 100.
        crawl_credits_used (Union[Unset, int]): Number of crawl credits used for the project Example: 100.
        query_credits_used (Union[Unset, int]): Number of query credits used for the project Example: 100.
        index_credits_used (Union[Unset, int]): Number of index credits used for the project Example: 100.
    """

    pages_found: Union[Unset, int] = UNSET
    pages_crawled: Union[Unset, int] = UNSET
    pages_indexed: Union[Unset, int] = UNSET
    crawl_credits_used: Union[Unset, int] = UNSET
    query_credits_used: Union[Unset, int] = UNSET
    index_credits_used: Union[Unset, int] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        pages_found = self.pages_found
        pages_crawled = self.pages_crawled
        pages_indexed = self.pages_indexed
        crawl_credits_used = self.crawl_credits_used
        query_credits_used = self.query_credits_used
        index_credits_used = self.index_credits_used

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if pages_found is not UNSET:
            field_dict["pages_found"] = pages_found
        if pages_crawled is not UNSET:
            field_dict["pages_crawled"] = pages_crawled
        if pages_indexed is not UNSET:
            field_dict["pages_indexed"] = pages_indexed
        if crawl_credits_used is not UNSET:
            field_dict["crawl_credits_used"] = crawl_credits_used
        if query_credits_used is not UNSET:
            field_dict["query_credits_used"] = query_credits_used
        if index_credits_used is not UNSET:
            field_dict["index_credits_used"] = index_credits_used

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        pages_found = src_dict.get("pages_found")

        pages_crawled = src_dict.get("pages_crawled")

        pages_indexed = src_dict.get("pages_indexed")

        crawl_credits_used = src_dict.get("crawl_credits_used")

        query_credits_used = src_dict.get("query_credits_used")

        index_credits_used = src_dict.get("index_credits_used")

        stats_project_response_200_data = cls(
            pages_found=pages_found,
            pages_crawled=pages_crawled,
            pages_indexed=pages_indexed,
            crawl_credits_used=crawl_credits_used,
            query_credits_used=query_credits_used,
            index_credits_used=index_credits_used,
        )

        stats_project_response_200_data.additional_properties = src_dict
        return stats_project_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_200_status.py:
```
from enum import Enum


class StatsProjectResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.stats_project_response_400_data import StatsProjectResponse400Data


T = TypeVar("T", bound="StatsProjectResponse400")


@attr.s(auto_attribs=True)
class StatsProjectResponse400:
    """
    Attributes:
        status (Union[Unset, StatsProjectResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, StatsProjectResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "StatsProjectResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.stats_project_response_400_data import StatsProjectResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, StatsProjectResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = StatsProjectResponse400Data.from_dict(_data)

        stats_project_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        stats_project_response_400.additional_properties = src_dict
        return stats_project_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="StatsProjectResponse400Data")


@attr.s(auto_attribs=True)
class StatsProjectResponse400Data:
    """
    Attributes:
        code (Union[Unset, StatsProjectResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        stats_project_response_400_data = cls(
            code=code,
            message=message,
        )

        stats_project_response_400_data.additional_properties = src_dict
        return stats_project_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_400_data_code.py:
```
from enum import IntEnum


class StatsProjectResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_400_status.py:
```
from enum import Enum


class StatsProjectResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.stats_project_response_401_data import StatsProjectResponse401Data


T = TypeVar("T", bound="StatsProjectResponse401")


@attr.s(auto_attribs=True)
class StatsProjectResponse401:
    """
    Attributes:
        status (Union[Unset, StatsProjectResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, StatsProjectResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "StatsProjectResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.stats_project_response_401_data import StatsProjectResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, StatsProjectResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = StatsProjectResponse401Data.from_dict(_data)

        stats_project_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        stats_project_response_401.additional_properties = src_dict
        return stats_project_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="StatsProjectResponse401Data")


@attr.s(auto_attribs=True)
class StatsProjectResponse401Data:
    """
    Attributes:
        code (Union[Unset, StatsProjectResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        stats_project_response_401_data = cls(
            code=code,
            message=message,
        )

        stats_project_response_401_data.additional_properties = src_dict
        return stats_project_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_401_data_code.py:
```
from enum import IntEnum


class StatsProjectResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_401_status.py:
```
from enum import Enum


class StatsProjectResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.stats_project_response_404_data import StatsProjectResponse404Data


T = TypeVar("T", bound="StatsProjectResponse404")


@attr.s(auto_attribs=True)
class StatsProjectResponse404:
    """
    Attributes:
        status (Union[Unset, StatsProjectResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, StatsProjectResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "StatsProjectResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.stats_project_response_404_data import StatsProjectResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, StatsProjectResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = StatsProjectResponse404Data.from_dict(_data)

        stats_project_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        stats_project_response_404.additional_properties = src_dict
        return stats_project_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="StatsProjectResponse404Data")


@attr.s(auto_attribs=True)
class StatsProjectResponse404Data:
    """
    Attributes:
        code (Union[Unset, StatsProjectResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, StatsProjectResponse404DataMessage]): The error message Example: Project with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        stats_project_response_404_data = cls(
            code=code,
            message=message,
        )

        stats_project_response_404_data.additional_properties = src_dict
        return stats_project_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_404_data_code.py:
```
from enum import IntEnum


class StatsProjectResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_404_data_message.py:
```
from enum import Enum


class StatsProjectResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_404_status.py:
```
from enum import Enum


class StatsProjectResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.stats_project_response_500_data import StatsProjectResponse500Data


T = TypeVar("T", bound="StatsProjectResponse500")


@attr.s(auto_attribs=True)
class StatsProjectResponse500:
    """
    Attributes:
        status (Union[Unset, StatsProjectResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, StatsProjectResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "StatsProjectResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.stats_project_response_500_data import StatsProjectResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, StatsProjectResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = StatsProjectResponse500Data.from_dict(_data)

        stats_project_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        stats_project_response_500.additional_properties = src_dict
        return stats_project_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="StatsProjectResponse500Data")


@attr.s(auto_attribs=True)
class StatsProjectResponse500Data:
    """
    Attributes:
        code (Union[Unset, StatsProjectResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        stats_project_response_500_data = cls(
            code=code,
            message=message,
        )

        stats_project_response_500_data.additional_properties = src_dict
        return stats_project_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_500_data_code.py:
```
from enum import IntEnum


class StatsProjectResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/stats_project_response_500_status.py:
```
from enum import Enum


class StatsProjectResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_conversation_json_body.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateConversationJsonBody")


@attr.s(auto_attribs=True)
class UpdateConversationJsonBody:
    """
    Attributes:
        name (Union[Unset, str]): The new name of the conversation Example: My new conversation name.
    """

    name: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        name = self.name

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if name is not UNSET:
            field_dict["name"] = name

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        name = src_dict.get("name")

        update_conversation_json_body = cls(
            name=name,
        )

        update_conversation_json_body.additional_properties = src_dict
        return update_conversation_json_body

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_conversation_response_200_data import UpdateConversationResponse200Data


T = TypeVar("T", bound="UpdateConversationResponse200")


@attr.s(auto_attribs=True)
class UpdateConversationResponse200:
    """
    Attributes:
        status (Union[Unset, UpdateConversationResponse200Status]): The status of the response Example: success.
        data (Union[Unset, UpdateConversationResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "UpdateConversationResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_conversation_response_200_data import UpdateConversationResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateConversationResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateConversationResponse200Data.from_dict(_data)

        update_conversation_response_200 = cls(
            status=status,
            data=data,
        )

        update_conversation_response_200.additional_properties = src_dict
        return update_conversation_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_200_data.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateConversationResponse200Data")


@attr.s(auto_attribs=True)
class UpdateConversationResponse200Data:
    """
    Attributes:
        created_at (Union[Unset, datetime.datetime]): When was this conversation created? Example: 2023-04-30 16:43:53.
        updated_at (Union[Unset, datetime.datetime]): When was this conversation updated? Example: 2023-04-30 16:43:53.
        deleted_at (Union[Unset, None, datetime.datetime]): When was this conversation deleted? Example: 2023-04-30
            16:43:53.
        id (Union[Unset, int]): Conversation ID Example: 1.
        name (Union[Unset, str]): Conversation name Example: Conversation 1.
        project_id (Union[Unset, str]): Project ID for this conversation Example: 1.
        created_by (Union[Unset, str]): User ID for the user who created this conversation Example: 1.
        session_id (Union[Unset, str]): Session ID for this conversation Example: f1b9aaf0-5e4e-11eb-ae93-0242ac130002.
    """

    created_at: Union[Unset, datetime.datetime] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    id: Union[Unset, int] = UNSET
    name: Union[Unset, str] = UNSET
    project_id: Union[Unset, str] = UNSET
    created_by: Union[Unset, str] = UNSET
    session_id: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        id = self.id
        name = self.name
        project_id = self.project_id
        created_by = self.created_by
        session_id = self.session_id

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at
        if id is not UNSET:
            field_dict["id"] = id
        if name is not UNSET:
            field_dict["name"] = name
        if project_id is not UNSET:
            field_dict["project_id"] = project_id
        if created_by is not UNSET:
            field_dict["created_by"] = created_by
        if session_id is not UNSET:
            field_dict["session_id"] = session_id

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        id = src_dict.get("id")

        name = src_dict.get("name")

        project_id = src_dict.get("project_id")

        created_by = src_dict.get("created_by")

        session_id = src_dict.get("session_id")

        update_conversation_response_200_data = cls(
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
            id=id,
            name=name,
            project_id=project_id,
            created_by=created_by,
            session_id=session_id,
        )

        update_conversation_response_200_data.additional_properties = src_dict
        return update_conversation_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_200_status.py:
```
from enum import Enum


class UpdateConversationResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_conversation_response_400_data import UpdateConversationResponse400Data


T = TypeVar("T", bound="UpdateConversationResponse400")


@attr.s(auto_attribs=True)
class UpdateConversationResponse400:
    """
    Attributes:
        status (Union[Unset, UpdateConversationResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdateConversationResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdateConversationResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_conversation_response_400_data import UpdateConversationResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateConversationResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateConversationResponse400Data.from_dict(_data)

        update_conversation_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_conversation_response_400.additional_properties = src_dict
        return update_conversation_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateConversationResponse400Data")


@attr.s(auto_attribs=True)
class UpdateConversationResponse400Data:
    """
    Attributes:
        code (Union[Unset, UpdateConversationResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_conversation_response_400_data = cls(
            code=code,
            message=message,
        )

        update_conversation_response_400_data.additional_properties = src_dict
        return update_conversation_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_400_data_code.py:
```
from enum import IntEnum


class UpdateConversationResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_400_status.py:
```
from enum import Enum


class UpdateConversationResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_conversation_response_401_data import UpdateConversationResponse401Data


T = TypeVar("T", bound="UpdateConversationResponse401")


@attr.s(auto_attribs=True)
class UpdateConversationResponse401:
    """
    Attributes:
        status (Union[Unset, UpdateConversationResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdateConversationResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdateConversationResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_conversation_response_401_data import UpdateConversationResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateConversationResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateConversationResponse401Data.from_dict(_data)

        update_conversation_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_conversation_response_401.additional_properties = src_dict
        return update_conversation_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateConversationResponse401Data")


@attr.s(auto_attribs=True)
class UpdateConversationResponse401Data:
    """
    Attributes:
        code (Union[Unset, UpdateConversationResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_conversation_response_401_data = cls(
            code=code,
            message=message,
        )

        update_conversation_response_401_data.additional_properties = src_dict
        return update_conversation_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_401_data_code.py:
```
from enum import IntEnum


class UpdateConversationResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_401_status.py:
```
from enum import Enum


class UpdateConversationResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_conversation_response_404_data import UpdateConversationResponse404Data


T = TypeVar("T", bound="UpdateConversationResponse404")


@attr.s(auto_attribs=True)
class UpdateConversationResponse404:
    """
    Attributes:
        status (Union[Unset, UpdateConversationResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdateConversationResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdateConversationResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_conversation_response_404_data import UpdateConversationResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateConversationResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateConversationResponse404Data.from_dict(_data)

        update_conversation_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_conversation_response_404.additional_properties = src_dict
        return update_conversation_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateConversationResponse404Data")


@attr.s(auto_attribs=True)
class UpdateConversationResponse404Data:
    """
    Attributes:
        code (Union[Unset, UpdateConversationResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, UpdateConversationResponse404DataMessage]): The error message Example: Project with id 1
            not found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_conversation_response_404_data = cls(
            code=code,
            message=message,
        )

        update_conversation_response_404_data.additional_properties = src_dict
        return update_conversation_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_404_data_code.py:
```
from enum import IntEnum


class UpdateConversationResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_404_data_message.py:
```
from enum import Enum


class UpdateConversationResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_404_status.py:
```
from enum import Enum


class UpdateConversationResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_conversation_response_500_data import UpdateConversationResponse500Data


T = TypeVar("T", bound="UpdateConversationResponse500")


@attr.s(auto_attribs=True)
class UpdateConversationResponse500:
    """
    Attributes:
        status (Union[Unset, UpdateConversationResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdateConversationResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdateConversationResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_conversation_response_500_data import UpdateConversationResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateConversationResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateConversationResponse500Data.from_dict(_data)

        update_conversation_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_conversation_response_500.additional_properties = src_dict
        return update_conversation_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateConversationResponse500Data")


@attr.s(auto_attribs=True)
class UpdateConversationResponse500Data:
    """
    Attributes:
        code (Union[Unset, UpdateConversationResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_conversation_response_500_data = cls(
            code=code,
            message=message,
        )

        update_conversation_response_500_data.additional_properties = src_dict
        return update_conversation_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_500_data_code.py:
```
from enum import IntEnum


class UpdateConversationResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_conversation_response_500_status.py:
```
from enum import Enum


class UpdateConversationResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_json_body.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdatePageMetadataJsonBody")


@attr.s(auto_attribs=True)
class UpdatePageMetadataJsonBody:
    """
    Attributes:
        title (Union[Unset, None, str]): The title of the page used in citations Example: Title.
        url (Union[Unset, None, str]): The url of the page used in citations Example: https://example.com/.
        description (Union[Unset, None, str]): The description of the page used in citations Example: One to two
            sentences..
        image (Union[Unset, None, str]): The url of the image used in citations Example: https://example.com/image.png.
    """

    title: Union[Unset, None, str] = UNSET
    url: Union[Unset, None, str] = UNSET
    description: Union[Unset, None, str] = UNSET
    image: Union[Unset, None, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        title = self.title
        url = self.url
        description = self.description
        image = self.image

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if title is not UNSET:
            field_dict["title"] = title
        if url is not UNSET:
            field_dict["url"] = url
        if description is not UNSET:
            field_dict["description"] = description
        if image is not UNSET:
            field_dict["image"] = image

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        title = src_dict.get("title")

        url = src_dict.get("url")

        description = src_dict.get("description")

        image = src_dict.get("image")

        update_page_metadata_json_body = cls(
            title=title,
            url=url,
            description=description,
            image=image,
        )

        update_page_metadata_json_body.additional_properties = src_dict
        return update_page_metadata_json_body

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_page_metadata_response_200_data import UpdatePageMetadataResponse200Data


T = TypeVar("T", bound="UpdatePageMetadataResponse200")


@attr.s(auto_attribs=True)
class UpdatePageMetadataResponse200:
    """
    Attributes:
        status (Union[Unset, UpdatePageMetadataResponse200Status]): The status of the response Example: success.
        data (Union[Unset, UpdatePageMetadataResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "UpdatePageMetadataResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_page_metadata_response_200_data import UpdatePageMetadataResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, UpdatePageMetadataResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdatePageMetadataResponse200Data.from_dict(_data)

        update_page_metadata_response_200 = cls(
            status=status,
            data=data,
        )

        update_page_metadata_response_200.additional_properties = src_dict
        return update_page_metadata_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_200_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdatePageMetadataResponse200Data")


@attr.s(auto_attribs=True)
class UpdatePageMetadataResponse200Data:
    """
    Attributes:
        url (Union[Unset, str]): The URL of the page Example: https://www.example.com.
        title (Union[Unset, str]): The title of the page Example: Example Domain.
        description (Union[Unset, str]): The description of the page Example: This domain is for use in illustrative
            examples in documents. You may use this domain in literature without prior coordination or asking for
            permission..
        image (Union[Unset, str]): The image of the page Example: https://www.example.com/image.png.
    """

    url: Union[Unset, str] = UNSET
    title: Union[Unset, str] = UNSET
    description: Union[Unset, str] = UNSET
    image: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        url = self.url
        title = self.title
        description = self.description
        image = self.image

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if url is not UNSET:
            field_dict["url"] = url
        if title is not UNSET:
            field_dict["title"] = title
        if description is not UNSET:
            field_dict["description"] = description
        if image is not UNSET:
            field_dict["image"] = image

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        url = src_dict.get("url")

        title = src_dict.get("title")

        description = src_dict.get("description")

        image = src_dict.get("image")

        update_page_metadata_response_200_data = cls(
            url=url,
            title=title,
            description=description,
            image=image,
        )

        update_page_metadata_response_200_data.additional_properties = src_dict
        return update_page_metadata_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_200_status.py:
```
from enum import Enum


class UpdatePageMetadataResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_page_metadata_response_400_data import UpdatePageMetadataResponse400Data


T = TypeVar("T", bound="UpdatePageMetadataResponse400")


@attr.s(auto_attribs=True)
class UpdatePageMetadataResponse400:
    """
    Attributes:
        status (Union[Unset, UpdatePageMetadataResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdatePageMetadataResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdatePageMetadataResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_page_metadata_response_400_data import UpdatePageMetadataResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdatePageMetadataResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdatePageMetadataResponse400Data.from_dict(_data)

        update_page_metadata_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_page_metadata_response_400.additional_properties = src_dict
        return update_page_metadata_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdatePageMetadataResponse400Data")


@attr.s(auto_attribs=True)
class UpdatePageMetadataResponse400Data:
    """
    Attributes:
        code (Union[Unset, UpdatePageMetadataResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_page_metadata_response_400_data = cls(
            code=code,
            message=message,
        )

        update_page_metadata_response_400_data.additional_properties = src_dict
        return update_page_metadata_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_400_data_code.py:
```
from enum import IntEnum


class UpdatePageMetadataResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_400_status.py:
```
from enum import Enum


class UpdatePageMetadataResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_page_metadata_response_401_data import UpdatePageMetadataResponse401Data


T = TypeVar("T", bound="UpdatePageMetadataResponse401")


@attr.s(auto_attribs=True)
class UpdatePageMetadataResponse401:
    """
    Attributes:
        status (Union[Unset, UpdatePageMetadataResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdatePageMetadataResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdatePageMetadataResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_page_metadata_response_401_data import UpdatePageMetadataResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdatePageMetadataResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdatePageMetadataResponse401Data.from_dict(_data)

        update_page_metadata_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_page_metadata_response_401.additional_properties = src_dict
        return update_page_metadata_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdatePageMetadataResponse401Data")


@attr.s(auto_attribs=True)
class UpdatePageMetadataResponse401Data:
    """
    Attributes:
        code (Union[Unset, UpdatePageMetadataResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_page_metadata_response_401_data = cls(
            code=code,
            message=message,
        )

        update_page_metadata_response_401_data.additional_properties = src_dict
        return update_page_metadata_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_401_data_code.py:
```
from enum import IntEnum


class UpdatePageMetadataResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_401_status.py:
```
from enum import Enum


class UpdatePageMetadataResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_page_metadata_response_404_data import UpdatePageMetadataResponse404Data


T = TypeVar("T", bound="UpdatePageMetadataResponse404")


@attr.s(auto_attribs=True)
class UpdatePageMetadataResponse404:
    """
    Attributes:
        status (Union[Unset, UpdatePageMetadataResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdatePageMetadataResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdatePageMetadataResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_page_metadata_response_404_data import UpdatePageMetadataResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdatePageMetadataResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdatePageMetadataResponse404Data.from_dict(_data)

        update_page_metadata_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_page_metadata_response_404.additional_properties = src_dict
        return update_page_metadata_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdatePageMetadataResponse404Data")


@attr.s(auto_attribs=True)
class UpdatePageMetadataResponse404Data:
    """
    Attributes:
        code (Union[Unset, UpdatePageMetadataResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, UpdatePageMetadataResponse404DataMessage]): The error message Example: Page with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Page with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_page_metadata_response_404_data = cls(
            code=code,
            message=message,
        )

        update_page_metadata_response_404_data.additional_properties = src_dict
        return update_page_metadata_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_404_data_code.py:
```
from enum import IntEnum


class UpdatePageMetadataResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_404_data_message.py:
```
from enum import Enum


class UpdatePageMetadataResponse404DataMessage(str, Enum):
    PAGE_ID_IS_REQUIRED = "Page id is required"
    PAGE_WITH_ID_PAGEID_NOT_FOUND = "Page with id {pageId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_404_status.py:
```
from enum import Enum


class UpdatePageMetadataResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_page_metadata_response_500_data import UpdatePageMetadataResponse500Data


T = TypeVar("T", bound="UpdatePageMetadataResponse500")


@attr.s(auto_attribs=True)
class UpdatePageMetadataResponse500:
    """
    Attributes:
        status (Union[Unset, UpdatePageMetadataResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdatePageMetadataResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdatePageMetadataResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_page_metadata_response_500_data import UpdatePageMetadataResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdatePageMetadataResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdatePageMetadataResponse500Data.from_dict(_data)

        update_page_metadata_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_page_metadata_response_500.additional_properties = src_dict
        return update_page_metadata_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdatePageMetadataResponse500Data")


@attr.s(auto_attribs=True)
class UpdatePageMetadataResponse500Data:
    """
    Attributes:
        code (Union[Unset, UpdatePageMetadataResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_page_metadata_response_500_data = cls(
            code=code,
            message=message,
        )

        update_page_metadata_response_500_data.additional_properties = src_dict
        return update_page_metadata_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_500_data_code.py:
```
from enum import IntEnum


class UpdatePageMetadataResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_page_metadata_response_500_status.py:
```
from enum import Enum


class UpdatePageMetadataResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_plugin_json_body.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdatePluginJsonBody")


@attr.s(auto_attribs=True)
class UpdatePluginJsonBody:
    """
    Attributes:
        model_name (Union[Unset, str]): Model Name Example: IndoorPlants.
        human_name (Union[Unset, str]): Name For Human Example: The Indoor Plants Channel.
        keywords (Union[Unset, str]): Keywords For Model Example: Indoor plants, Gardening, Trusted information..
        description (Union[Unset, str]): Description For Human Example: Trusted information about indoor plants and
            gardening..
        is_active (Union[Unset, bool]): Whether the project plugin is active or not Example: True.
    """

    model_name: Union[Unset, str] = UNSET
    human_name: Union[Unset, str] = UNSET
    keywords: Union[Unset, str] = UNSET
    description: Union[Unset, str] = UNSET
    is_active: Union[Unset, bool] = False
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        model_name = self.model_name
        human_name = self.human_name
        keywords = self.keywords
        description = self.description
        is_active = self.is_active

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if model_name is not UNSET:
            field_dict["model_name"] = model_name
        if human_name is not UNSET:
            field_dict["human_name"] = human_name
        if keywords is not UNSET:
            field_dict["keywords"] = keywords
        if description is not UNSET:
            field_dict["description"] = description
        if is_active is not UNSET:
            field_dict["is_active"] = is_active

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        model_name = src_dict.get("model_name")

        human_name = src_dict.get("human_name")

        keywords = src_dict.get("keywords")

        description = src_dict.get("description")

        is_active = src_dict.get("is_active")

        update_plugin_json_body = cls(
            model_name=model_name,
            human_name=human_name,
            keywords=keywords,
            description=description,
            is_active=is_active,
        )

        update_plugin_json_body.additional_properties = src_dict
        return update_plugin_json_body

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_plugin_response_200_data import UpdatePluginResponse200Data


T = TypeVar("T", bound="UpdatePluginResponse200")


@attr.s(auto_attribs=True)
class UpdatePluginResponse200:
    """
    Attributes:
        status (Union[Unset, UpdatePluginResponse200Status]): The status of the response Example: success.
        data (Union[Unset, UpdatePluginResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "UpdatePluginResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_plugin_response_200_data import UpdatePluginResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, UpdatePluginResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdatePluginResponse200Data.from_dict(_data)

        update_plugin_response_200 = cls(
            status=status,
            data=data,
        )

        update_plugin_response_200.additional_properties = src_dict
        return update_plugin_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_200_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdatePluginResponse200Data")


@attr.s(auto_attribs=True)
class UpdatePluginResponse200Data:
    """
    Attributes:
        model_name (Union[Unset, str]): Model Name Example: IndoorPlants.
        human_name (Union[Unset, str]): Name For Human Example: The Indoor Plants Channel.
        keywords (Union[Unset, str]): Keywords For Model Example: Indoor plants, Gardening, Trusted information..
        description (Union[Unset, str]): Description For Human Example: Trusted information about indoor plants and
            gardening..
        logo (Union[Unset, str]): Project plugin logo Example: https://app.customgpt.ai/logo.svg.
        is_active (Union[Unset, bool]): Whether the project plugin is active or not Example: True.
    """

    model_name: Union[Unset, str] = UNSET
    human_name: Union[Unset, str] = UNSET
    keywords: Union[Unset, str] = UNSET
    description: Union[Unset, str] = UNSET
    logo: Union[Unset, str] = UNSET
    is_active: Union[Unset, bool] = False
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        model_name = self.model_name
        human_name = self.human_name
        keywords = self.keywords
        description = self.description
        logo = self.logo
        is_active = self.is_active

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if model_name is not UNSET:
            field_dict["model_name"] = model_name
        if human_name is not UNSET:
            field_dict["human_name"] = human_name
        if keywords is not UNSET:
            field_dict["keywords"] = keywords
        if description is not UNSET:
            field_dict["description"] = description
        if logo is not UNSET:
            field_dict["logo"] = logo
        if is_active is not UNSET:
            field_dict["is_active"] = is_active

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        model_name = src_dict.get("model_name")

        human_name = src_dict.get("human_name")

        keywords = src_dict.get("keywords")

        description = src_dict.get("description")

        logo = src_dict.get("logo")

        is_active = src_dict.get("is_active")

        update_plugin_response_200_data = cls(
            model_name=model_name,
            human_name=human_name,
            keywords=keywords,
            description=description,
            logo=logo,
            is_active=is_active,
        )

        update_plugin_response_200_data.additional_properties = src_dict
        return update_plugin_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_200_status.py:
```
from enum import Enum


class UpdatePluginResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_plugin_response_400_data import UpdatePluginResponse400Data


T = TypeVar("T", bound="UpdatePluginResponse400")


@attr.s(auto_attribs=True)
class UpdatePluginResponse400:
    """
    Attributes:
        status (Union[Unset, UpdatePluginResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdatePluginResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdatePluginResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_plugin_response_400_data import UpdatePluginResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdatePluginResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdatePluginResponse400Data.from_dict(_data)

        update_plugin_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_plugin_response_400.additional_properties = src_dict
        return update_plugin_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdatePluginResponse400Data")


@attr.s(auto_attribs=True)
class UpdatePluginResponse400Data:
    """
    Attributes:
        code (Union[Unset, UpdatePluginResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_plugin_response_400_data = cls(
            code=code,
            message=message,
        )

        update_plugin_response_400_data.additional_properties = src_dict
        return update_plugin_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_400_data_code.py:
```
from enum import IntEnum


class UpdatePluginResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_400_status.py:
```
from enum import Enum


class UpdatePluginResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_plugin_response_401_data import UpdatePluginResponse401Data


T = TypeVar("T", bound="UpdatePluginResponse401")


@attr.s(auto_attribs=True)
class UpdatePluginResponse401:
    """
    Attributes:
        status (Union[Unset, UpdatePluginResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdatePluginResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdatePluginResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_plugin_response_401_data import UpdatePluginResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdatePluginResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdatePluginResponse401Data.from_dict(_data)

        update_plugin_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_plugin_response_401.additional_properties = src_dict
        return update_plugin_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdatePluginResponse401Data")


@attr.s(auto_attribs=True)
class UpdatePluginResponse401Data:
    """
    Attributes:
        code (Union[Unset, UpdatePluginResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_plugin_response_401_data = cls(
            code=code,
            message=message,
        )

        update_plugin_response_401_data.additional_properties = src_dict
        return update_plugin_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_401_data_code.py:
```
from enum import IntEnum


class UpdatePluginResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_401_status.py:
```
from enum import Enum


class UpdatePluginResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_plugin_response_404_data import UpdatePluginResponse404Data


T = TypeVar("T", bound="UpdatePluginResponse404")


@attr.s(auto_attribs=True)
class UpdatePluginResponse404:
    """
    Attributes:
        status (Union[Unset, UpdatePluginResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdatePluginResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdatePluginResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_plugin_response_404_data import UpdatePluginResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdatePluginResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdatePluginResponse404Data.from_dict(_data)

        update_plugin_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_plugin_response_404.additional_properties = src_dict
        return update_plugin_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdatePluginResponse404Data")


@attr.s(auto_attribs=True)
class UpdatePluginResponse404Data:
    """
    Attributes:
        code (Union[Unset, UpdatePluginResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, UpdatePluginResponse404DataMessage]): The error message Example: Project plugin with id 1
            not found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project plugin with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_plugin_response_404_data = cls(
            code=code,
            message=message,
        )

        update_plugin_response_404_data.additional_properties = src_dict
        return update_plugin_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_404_data_code.py:
```
from enum import IntEnum


class UpdatePluginResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_404_data_message.py:
```
from enum import Enum


class UpdatePluginResponse404DataMessage(str, Enum):
    PLUGIN_FOR_PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Plugin for project with id {projectId} not found"
    PROJECT_PLUGIN_ID_IS_REQUIRED = "Project plugin id is required"
    PROJECT_PLUGIN_WITH_ID_PLUGINID_NOT_FOUND = "Project plugin with id {pluginId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_404_status.py:
```
from enum import Enum


class UpdatePluginResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_plugin_response_500_data import UpdatePluginResponse500Data


T = TypeVar("T", bound="UpdatePluginResponse500")


@attr.s(auto_attribs=True)
class UpdatePluginResponse500:
    """
    Attributes:
        status (Union[Unset, UpdatePluginResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdatePluginResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdatePluginResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_plugin_response_500_data import UpdatePluginResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdatePluginResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdatePluginResponse500Data.from_dict(_data)

        update_plugin_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_plugin_response_500.additional_properties = src_dict
        return update_plugin_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdatePluginResponse500Data")


@attr.s(auto_attribs=True)
class UpdatePluginResponse500Data:
    """
    Attributes:
        code (Union[Unset, UpdatePluginResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_plugin_response_500_data = cls(
            code=code,
            message=message,
        )

        update_plugin_response_500_data.additional_properties = src_dict
        return update_plugin_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_500_data_code.py:
```
from enum import IntEnum


class UpdatePluginResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_plugin_response_500_status.py:
```
from enum import Enum


class UpdatePluginResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_project_multipart_data.py:
```
from io import BytesIO
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, File, FileJsonType, Unset

T = TypeVar("T", bound="UpdateProjectMultipartData")


@attr.s(auto_attribs=True)
class UpdateProjectMultipartData:
    """
    Attributes:
        project_name (Union[Unset, str]): Project name Example: My project.
        is_shared (Union[Unset, bool]): Whether the project is shared or not Example: True.
        sitemap_path (Union[Unset, str]): Sitemap path Example: https://example.com/sitemap.xml.
        file_data_retension (Union[Unset, bool]): File data retension Example: True.
        file (Union[Unset, File]): File Example: file.pdf.
    """

    project_name: Union[Unset, str] = UNSET
    is_shared: Union[Unset, bool] = UNSET
    sitemap_path: Union[Unset, str] = UNSET
    file_data_retension: Union[Unset, bool] = UNSET
    file: Union[Unset, File] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        project_name = self.project_name
        is_shared = self.is_shared
        sitemap_path = self.sitemap_path
        file_data_retension = self.file_data_retension
        file: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.file, Unset):
            file = self.file.to_tuple()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if project_name is not UNSET:
            field_dict["project_name"] = project_name
        if is_shared is not UNSET:
            field_dict["is_shared"] = is_shared
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path
        if file_data_retension is not UNSET:
            field_dict["file_data_retension"] = file_data_retension
        if file is not UNSET:
            field_dict["file"] = file

        return field_dict

    def to_multipart(self) -> Dict[str, Any]:
        project_name = (
            self.project_name
            if isinstance(self.project_name, Unset)
            else (None, str(self.project_name).encode(), "text/plain")
        )
        is_shared = (
            self.is_shared
            if isinstance(self.is_shared, Unset)
            else (None, str(self.is_shared).lower().encode(), "text/plain")
        )
        sitemap_path = (
            self.sitemap_path
            if isinstance(self.sitemap_path, Unset)
            else (None, str(self.sitemap_path).encode(), "text/plain")
        )
        file_data_retension = (
            self.file_data_retension
            if isinstance(self.file_data_retension, Unset)
            else (None, str(self.file_data_retension).lower().encode(), "text/plain")
        )
        file: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.file, Unset):
            file = self.file.to_tuple()

        field_dict: Dict[str, Any] = {}
        field_dict.update(
            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
        )
        field_dict.update({})
        if project_name is not UNSET:
            field_dict["project_name"] = project_name
        if is_shared is not UNSET:
            field_dict["is_shared"] = is_shared
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path
        if file_data_retension is not UNSET:
            field_dict["file_data_retension"] = file_data_retension
        if file is not UNSET:
            field_dict["file"] = file

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        project_name = src_dict.get("project_name")

        is_shared = src_dict.get("is_shared")

        sitemap_path = src_dict.get("sitemap_path")

        file_data_retension = src_dict.get("file_data_retension")

        _file = src_dict.get("file")
        file: Union[Unset, File]
        if isinstance(_file, Unset):
            file = UNSET
        else:
            file = File(payload=BytesIO(_file))

        update_project_multipart_data = cls(
            project_name=project_name,
            is_shared=is_shared,
            sitemap_path=sitemap_path,
            file_data_retension=file_data_retension,
            file=file,
        )

        update_project_multipart_data.additional_properties = src_dict
        return update_project_multipart_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_project_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_project_response_200_data import UpdateProjectResponse200Data


T = TypeVar("T", bound="UpdateProjectResponse200")


@attr.s(auto_attribs=True)
class UpdateProjectResponse200:
    """
    Attributes:
        status (Union[Unset, UpdateProjectResponse200Status]): The status of the response Example: success.
        data (Union[Unset, UpdateProjectResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "UpdateProjectResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_project_response_200_data import UpdateProjectResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateProjectResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateProjectResponse200Data.from_dict(_data)

        update_project_response_200 = cls(
            status=status,
            data=data,
        )

        update_project_response_200.additional_properties = src_dict
        return update_project_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_project_response_200_data.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateProjectResponse200Data")


@attr.s(auto_attribs=True)
class UpdateProjectResponse200Data:
    """
    Attributes:
        id (Union[Unset, int]): Project ID Example: 1.
        project_name (Union[Unset, str]): Project name Example: My Project.
        sitemap_path (Union[Unset, str]): Project sitemap Example: https://www.example.com/sitemap.xml.
        is_chat_active (Union[Unset, bool]): Whether the chat bot is active or not Example: True.
        user_id (Union[Unset, int]): User ID of the project owner Example: 1.
        created_at (Union[Unset, datetime.datetime]): Date and time when the project was created Default:
            isoparse('2023-05-08 13:06:55'). Example: 2021-01-01 00:00:00.
        updated_at (Union[Unset, datetime.datetime]): Date and time when the project was last updated Default:
            isoparse('2023-05-08 13:06:55'). Example: 2021-01-01 00:00:00.
        deleted_at (Union[Unset, None, datetime.datetime]): Date and time when the project was deleted Example:
            2021-01-01 00:00:00.
        type (Union[Unset, UpdateProjectResponse200DataType]): Project type Default:
            UpdateProjectResponse200DataType.SITEMAP. Example: SITEMAP.
        is_shared (Union[Unset, bool]): Whether the project is shared or not Example: True.
        shareable_slug (Union[Unset, None, str]): Shareable slug that can be used to share the project Example:
            1234567890abcdef1234567890abcdef.
        shareable_link (Union[Unset, None, str]): Shareable link that can be used to share the project
        embed_code (Union[Unset, None, str]): Embed code that can be used to embed the project
        live_chat_code (Union[Unset, None, str]): Live chat code that can be used to embed the live chat
    """

    id: Union[Unset, int] = UNSET
    project_name: Union[Unset, str] = UNSET
    sitemap_path: Union[Unset, str] = UNSET
    is_chat_active: Union[Unset, bool] = False
    user_id: Union[Unset, int] = UNSET
    created_at: Union[Unset, datetime.datetime] = isoparse("2023-05-08 13:06:55")
    updated_at: Union[Unset, datetime.datetime] = isoparse("2023-05-08 13:06:55")
    deleted_at: Union[Unset, None, datetime.datetime] = UNSET
    type: Union[Unset, str] = "SITEMAP"
    is_shared: Union[Unset, bool] = False
    shareable_slug: Union[Unset, None, str] = UNSET
    shareable_link: Union[Unset, None, str] = UNSET
    embed_code: Union[Unset, None, str] = UNSET
    live_chat_code: Union[Unset, None, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        id = self.id
        project_name = self.project_name
        sitemap_path = self.sitemap_path
        is_chat_active = self.is_chat_active
        user_id = self.user_id
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        deleted_at: Union[Unset, None, str] = UNSET
        if not isinstance(self.deleted_at, Unset):
            deleted_at = self.deleted_at.isoformat() if self.deleted_at else None

        type: Union[Unset, str] = UNSET
        if not isinstance(self.type, Unset):
            type = self.type

        is_shared = self.is_shared
        shareable_slug = self.shareable_slug
        shareable_link = self.shareable_link
        embed_code = self.embed_code
        live_chat_code = self.live_chat_code

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if id is not UNSET:
            field_dict["id"] = id
        if project_name is not UNSET:
            field_dict["project_name"] = project_name
        if sitemap_path is not UNSET:
            field_dict["sitemap_path"] = sitemap_path
        if is_chat_active is not UNSET:
            field_dict["is_chat_active"] = is_chat_active
        if user_id is not UNSET:
            field_dict["user_id"] = user_id
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at
        if deleted_at is not UNSET:
            field_dict["deleted_at"] = deleted_at
        if type is not UNSET:
            field_dict["type"] = type
        if is_shared is not UNSET:
            field_dict["is_shared"] = is_shared
        if shareable_slug is not UNSET:
            field_dict["shareable_slug"] = shareable_slug
        if shareable_link is not UNSET:
            field_dict["shareable_link"] = shareable_link
        if embed_code is not UNSET:
            field_dict["embed_code"] = embed_code
        if live_chat_code is not UNSET:
            field_dict["live_chat_code"] = live_chat_code

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        id = src_dict.get("id")

        project_name = src_dict.get("project_name")

        sitemap_path = src_dict.get("sitemap_path")

        is_chat_active = src_dict.get("is_chat_active")

        user_id = src_dict.get("user_id")

        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        _deleted_at = src_dict.get("deleted_at")
        deleted_at: Union[Unset, None, datetime.datetime]
        if _deleted_at is None:
            deleted_at = None
        elif isinstance(_deleted_at, Unset):
            deleted_at = UNSET
        else:
            deleted_at = isoparse(_deleted_at)

        type = src_dict.get("type")

        is_shared = src_dict.get("is_shared")

        shareable_slug = src_dict.get("shareable_slug")

        shareable_link = src_dict.get("shareable_link")

        embed_code = src_dict.get("embed_code")

        live_chat_code = src_dict.get("live_chat_code")

        update_project_response_200_data = cls(
            id=id,
            project_name=project_name,
            sitemap_path=sitemap_path,
            is_chat_active=is_chat_active,
            user_id=user_id,
            created_at=created_at,
            updated_at=updated_at,
            deleted_at=deleted_at,
            type=type,
            is_shared=is_shared,
            shareable_slug=shareable_slug,
            shareable_link=shareable_link,
            embed_code=embed_code,
            live_chat_code=live_chat_code,
        )

        update_project_response_200_data.additional_properties = src_dict
        return update_project_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_project_response_200_data_type.py:
```
from enum import Enum


class UpdateProjectResponse200DataType(str, Enum):
    SITEMAP = "SITEMAP"
    URL = "URL"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_project_response_200_status.py:
```
from enum import Enum


class UpdateProjectResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_project_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_project_response_400_data import UpdateProjectResponse400Data


T = TypeVar("T", bound="UpdateProjectResponse400")


@attr.s(auto_attribs=True)
class UpdateProjectResponse400:
    """
    Attributes:
        status (Union[Unset, UpdateProjectResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdateProjectResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdateProjectResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_project_response_400_data import UpdateProjectResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateProjectResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateProjectResponse400Data.from_dict(_data)

        update_project_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_project_response_400.additional_properties = src_dict
        return update_project_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_project_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateProjectResponse400Data")


@attr.s(auto_attribs=True)
class UpdateProjectResponse400Data:
    """
    Attributes:
        code (Union[Unset, UpdateProjectResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, str]): The error message Example: Project id must be integer.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_project_response_400_data = cls(
            code=code,
            message=message,
        )

        update_project_response_400_data.additional_properties = src_dict
        return update_project_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_project_response_400_data_code.py:
```
from enum import IntEnum


class UpdateProjectResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_project_response_400_status.py:
```
from enum import Enum


class UpdateProjectResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_project_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_project_response_401_data import UpdateProjectResponse401Data


T = TypeVar("T", bound="UpdateProjectResponse401")


@attr.s(auto_attribs=True)
class UpdateProjectResponse401:
    """
    Attributes:
        status (Union[Unset, UpdateProjectResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdateProjectResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdateProjectResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_project_response_401_data import UpdateProjectResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateProjectResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateProjectResponse401Data.from_dict(_data)

        update_project_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_project_response_401.additional_properties = src_dict
        return update_project_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_project_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateProjectResponse401Data")


@attr.s(auto_attribs=True)
class UpdateProjectResponse401Data:
    """
    Attributes:
        code (Union[Unset, UpdateProjectResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_project_response_401_data = cls(
            code=code,
            message=message,
        )

        update_project_response_401_data.additional_properties = src_dict
        return update_project_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_project_response_401_data_code.py:
```
from enum import IntEnum


class UpdateProjectResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_project_response_401_status.py:
```
from enum import Enum


class UpdateProjectResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_project_response_404.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_project_response_404_data import UpdateProjectResponse404Data


T = TypeVar("T", bound="UpdateProjectResponse404")


@attr.s(auto_attribs=True)
class UpdateProjectResponse404:
    """
    Attributes:
        status (Union[Unset, UpdateProjectResponse404Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdateProjectResponse404Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdateProjectResponse404Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_project_response_404_data import UpdateProjectResponse404Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateProjectResponse404Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateProjectResponse404Data.from_dict(_data)

        update_project_response_404 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_project_response_404.additional_properties = src_dict
        return update_project_response_404

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_project_response_404_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateProjectResponse404Data")


@attr.s(auto_attribs=True)
class UpdateProjectResponse404Data:
    """
    Attributes:
        code (Union[Unset, UpdateProjectResponse404DataCode]): The error status code Example: 404.
        message (Union[Unset, UpdateProjectResponse404DataMessage]): The error message Example: Project with id 1 not
            found.
    """

    code: Union[Unset, str] = "404"
    message: Union[Unset, str] = "Project with id 1 not found"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_project_response_404_data = cls(
            code=code,
            message=message,
        )

        update_project_response_404_data.additional_properties = src_dict
        return update_project_response_404_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_project_response_404_data_code.py:
```
from enum import IntEnum


class UpdateProjectResponse404DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_project_response_404_data_message.py:
```
from enum import Enum


class UpdateProjectResponse404DataMessage(str, Enum):
    PROJECT_ID_IS_REQUIRED = "Project id is required"
    PROJECT_WITH_ID_PROJECTID_NOT_FOUND = "Project with id {projectId} not found"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_project_response_404_status.py:
```
from enum import Enum


class UpdateProjectResponse404Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_project_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_project_response_500_data import UpdateProjectResponse500Data


T = TypeVar("T", bound="UpdateProjectResponse500")


@attr.s(auto_attribs=True)
class UpdateProjectResponse500:
    """
    Attributes:
        status (Union[Unset, UpdateProjectResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdateProjectResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdateProjectResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_project_response_500_data import UpdateProjectResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateProjectResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateProjectResponse500Data.from_dict(_data)

        update_project_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_project_response_500.additional_properties = src_dict
        return update_project_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_project_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateProjectResponse500Data")


@attr.s(auto_attribs=True)
class UpdateProjectResponse500Data:
    """
    Attributes:
        code (Union[Unset, UpdateProjectResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_project_response_500_data = cls(
            code=code,
            message=message,
        )

        update_project_response_500_data.additional_properties = src_dict
        return update_project_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_project_response_500_data_code.py:
```
from enum import IntEnum


class UpdateProjectResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_project_response_500_status.py:
```
from enum import Enum


class UpdateProjectResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_settings_multipart_data.py:
```
from io import BytesIO
from typing import Any, Dict, List, Tuple, Type, TypeVar, Union, cast

import attr

from ..types import UNSET, File, FileJsonType, Unset

T = TypeVar("T", bound="UpdateSettingsMultipartData")


@attr.s(auto_attribs=True)
class UpdateSettingsMultipartData:
    """
    Attributes:
        chat_bot_avatar (Union[Unset, File]): This is the avatar that is shown in the bot response. You can make it a
            profile picture or your company logo. Example: avatar.png.
        chat_bot_bg (Union[Unset, File]): This is the background image shown in the bot conversations widget. You can
            change it to a company logo or background image. Example: bg.png.
        default_prompt (Union[Unset, str]): This is the default prompt shown to the user. You can customize this for
            your company or client. Example: How can I help you?.
        example_questions (Union[Unset, List[str]]): These are example questions shown to guide the bot users. You can
            create customized questions to suit your company or client needs.
        response_source (Union[Unset, str]): By default, we ask ChatGPT to use only your content in its response
            (recommended). If you wish ChatGPT to improvise and use its own knowledgebase as well, you can select "My
            Content + ChatGPT" Example: own_content.
        chatbot_msg_lang (Union[Unset, str]): By default, the chatbot messages like 'Ask Me Anything' are in English.
            You can customize this to your preferred language. Please note: This setting does not control what language
            ChatGPT responds in. That is controlled by the user's question. So a user asking in Portuguese, will most likely
            get a response from ChatGPT in Portuguese. Example: en.
        chatbot_color (Union[Unset, str]): Color of the chatbot in hex format Example: #000000.
        persona_instructions (Union[Unset, None, str]): [Advanced Users] Customize your chatbot behavior by adjusting
            the system parameter to control its personality traits  and role. Example: You are a custom chatbot assistant
            called CustomGPT, a friendly lawyer who answers questions based on the given context..
        citations_answer_source_label_msg (Union[Unset, None, str]): This is the message shown to indicate where the
            response came from. You can customize this message based on your business or language. Example: Where did this
            answer come from?.
        citations_sources_label_msg (Union[Unset, None, str]): This is the message shown for the Sources label.  You can
            customize this message based on your business or language. Example: Sources.
        hang_in_there_msg (Union[Unset, None, str]): This is the message shown when the bot is thinking and waiting to
            answer. You can customize this message based on your tone, personality or language. Example: Hang in there! I'm
            thinking...
        chatbot_siesta_msg (Union[Unset, None, str]): This is the message shown when the bot has encountered a problem
            or error. You can customize this message based on your tone, personality or language. Example: Oops! The chat
            bot is taking a siesta. This usually happens when OpenAI is down! Please try again later..
        is_loading_indicator_enabled (Union[Unset, None, bool]): Show animated loading indicator while waiting for a
            response from the chatbot Default: True. Example: True.
        enable_citations (Union[Unset, None, bool]): Each chatbot response shows an option for the user to see the
            sources/citations from your content from which the response was generated. Default: True. Example: True.
        citations_view_type (Union[Unset, None, UpdateSettingsMultipartDataCitationsViewType]): Control how citations
            are shown. By default, the user can initiate to see the citations. You can choose to have it "Auto Shown" or
            "Auto Hide" Default: UpdateSettingsMultipartDataCitationsViewType.USER. Example: user.
        no_answer_message (Union[Unset, None, str]): This is the message shown when the bot cannot answer. You can
            customize it to a message asking the user to contact customer support or leave their email / phone. Example:
            Sorry, I don't have an answer for that..
        ending_message (Union[Unset, None, str]): You can instruct ChatGPT to end every response with some text like
            asking "Please email us for further support" (Not recommended for most use cases) Example: Please email us for
            further support.
        remove_branding (Union[Unset, None, bool]): Controls what branding is shown at the bottom of the chatbot.
    """

    chat_bot_avatar: Union[Unset, File] = UNSET
    chat_bot_bg: Union[Unset, File] = UNSET
    default_prompt: Union[Unset, str] = UNSET
    example_questions: Union[Unset, List[str]] = UNSET
    response_source: Union[Unset, str] = UNSET
    chatbot_msg_lang: Union[Unset, str] = UNSET
    chatbot_color: Union[Unset, str] = UNSET
    persona_instructions: Union[Unset, None, str] = UNSET
    citations_answer_source_label_msg: Union[Unset, None, str] = UNSET
    citations_sources_label_msg: Union[Unset, None, str] = UNSET
    hang_in_there_msg: Union[Unset, None, str] = UNSET
    chatbot_siesta_msg: Union[Unset, None, str] = UNSET
    is_loading_indicator_enabled: Union[Unset, None, bool] = True
    enable_citations: Union[Unset, None, bool] = True
    citations_view_type: Union[Unset, str] = "user"
    no_answer_message: Union[Unset, None, str] = UNSET
    ending_message: Union[Unset, None, str] = UNSET
    remove_branding: Union[Unset, None, bool] = False
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        chat_bot_avatar: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.chat_bot_avatar, Unset):
            chat_bot_avatar = self.chat_bot_avatar.to_tuple()

        chat_bot_bg: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.chat_bot_bg, Unset):
            chat_bot_bg = self.chat_bot_bg.to_tuple()

        default_prompt = self.default_prompt
        example_questions: Union[Unset, List[str]] = UNSET
        if not isinstance(self.example_questions, Unset):
            example_questions = self.example_questions

        response_source = self.response_source
        chatbot_msg_lang = self.chatbot_msg_lang
        chatbot_color = self.chatbot_color
        persona_instructions = self.persona_instructions
        citations_answer_source_label_msg = self.citations_answer_source_label_msg
        citations_sources_label_msg = self.citations_sources_label_msg
        hang_in_there_msg = self.hang_in_there_msg
        chatbot_siesta_msg = self.chatbot_siesta_msg
        is_loading_indicator_enabled = self.is_loading_indicator_enabled
        enable_citations = self.enable_citations
        citations_view_type: Union[Unset, None, str] = UNSET
        if not isinstance(self.citations_view_type, Unset):
            citations_view_type = self.citations_view_type if self.citations_view_type else None

        no_answer_message = self.no_answer_message
        ending_message = self.ending_message
        remove_branding = self.remove_branding

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if chat_bot_avatar is not UNSET:
            field_dict["chat_bot_avatar"] = chat_bot_avatar
        if chat_bot_bg is not UNSET:
            field_dict["chat_bot_bg"] = chat_bot_bg
        if default_prompt is not UNSET:
            field_dict["default_prompt"] = default_prompt
        if example_questions is not UNSET:
            for index, field_value in enumerate(example_questions):
                field_dict[f"example_questions[]"] = field_value
        if response_source is not UNSET:
            field_dict["response_source"] = response_source
        if chatbot_msg_lang is not UNSET:
            field_dict["chatbot_msg_lang"] = chatbot_msg_lang
        if chatbot_color is not UNSET:
            field_dict["chatbot_color"] = chatbot_color
        if persona_instructions is not UNSET:
            field_dict["persona_instructions"] = persona_instructions
        if citations_answer_source_label_msg is not UNSET:
            field_dict["citations_answer_source_label_msg"] = citations_answer_source_label_msg
        if citations_sources_label_msg is not UNSET:
            field_dict["citations_sources_label_msg"] = citations_sources_label_msg
        if hang_in_there_msg is not UNSET:
            field_dict["hang_in_there_msg"] = hang_in_there_msg
        if chatbot_siesta_msg is not UNSET:
            field_dict["chatbot_siesta_msg"] = chatbot_siesta_msg
        if is_loading_indicator_enabled is not UNSET:
            field_dict["is_loading_indicator_enabled"] = is_loading_indicator_enabled
        if enable_citations is not UNSET:
            field_dict["enable_citations"] = enable_citations
        if citations_view_type is not UNSET:
            field_dict["citations_view_type"] = citations_view_type
        if no_answer_message is not UNSET:
            field_dict["no_answer_message"] = no_answer_message
        if ending_message is not UNSET:
            field_dict["ending_message"] = ending_message
        if remove_branding is not UNSET:
            field_dict["remove_branding"] = remove_branding

        return field_dict

    def to_multipart(self) -> Dict[str, Any]:
        chat_bot_avatar: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.chat_bot_avatar, Unset):
            chat_bot_avatar = self.chat_bot_avatar.to_tuple()

        chat_bot_bg: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.chat_bot_bg, Unset):
            chat_bot_bg = self.chat_bot_bg.to_tuple()

        default_prompt = (
            self.default_prompt
            if isinstance(self.default_prompt, Unset)
            else (None, str(self.default_prompt).encode(), "text/plain")
        )
        example_questions: Union[Unset, Tuple[None, bytes, str]] = UNSET
        if not isinstance(self.example_questions, Unset):
            self.example_questions
            example_questions = []
            for index, value in enumerate(self.example_questions):
                field_value = (None, str(value).encode(), "text/plain")
                example_questions.append(field_value)

        response_source = (
            self.response_source
            if isinstance(self.response_source, Unset)
            else (None, str(self.response_source).encode(), "text/plain")
        )
        chatbot_msg_lang = (
            self.chatbot_msg_lang
            if isinstance(self.chatbot_msg_lang, Unset)
            else (None, str(self.chatbot_msg_lang).encode(), "text/plain")
        )
        chatbot_color = (
            self.chatbot_color
            if isinstance(self.chatbot_color, Unset)
            else (None, str(self.chatbot_color).encode(), "text/plain")
        )
        persona_instructions = (
            self.persona_instructions
            if isinstance(self.persona_instructions, Unset)
            else (None, str(self.persona_instructions).encode(), "text/plain")
        )
        citations_answer_source_label_msg = (
            self.citations_answer_source_label_msg
            if isinstance(self.citations_answer_source_label_msg, Unset)
            else (None, str(self.citations_answer_source_label_msg).encode(), "text/plain")
        )
        citations_sources_label_msg = (
            self.citations_sources_label_msg
            if isinstance(self.citations_sources_label_msg, Unset)
            else (None, str(self.citations_sources_label_msg).encode(), "text/plain")
        )
        hang_in_there_msg = (
            self.hang_in_there_msg
            if isinstance(self.hang_in_there_msg, Unset)
            else (None, str(self.hang_in_there_msg).encode(), "text/plain")
        )
        chatbot_siesta_msg = (
            self.chatbot_siesta_msg
            if isinstance(self.chatbot_siesta_msg, Unset)
            else (None, str(self.chatbot_siesta_msg).encode(), "text/plain")
        )
        is_loading_indicator_enabled = (
            self.is_loading_indicator_enabled
            if isinstance(self.is_loading_indicator_enabled, Unset)
            else (None, str(self.is_loading_indicator_enabled).lower().encode(), "text/plain")
        )
        enable_citations = (
            self.enable_citations
            if isinstance(self.enable_citations, Unset)
            else (None, str(self.enable_citations).lower().encode(), "text/plain")
        )
        citations_view_type: Union[Unset, Tuple[None, bytes, str]] = UNSET
        if not isinstance(self.citations_view_type, Unset):
            citations_view_type = (
                (None, str(self.citations_view_type).encode(), "text/plain") if self.citations_view_type else None
            )

        no_answer_message = (
            self.no_answer_message
            if isinstance(self.no_answer_message, Unset)
            else (None, str(self.no_answer_message).encode(), "text/plain")
        )
        ending_message = (
            self.ending_message
            if isinstance(self.ending_message, Unset)
            else (None, str(self.ending_message).encode(), "text/plain")
        )
        remove_branding = (
            self.remove_branding
            if isinstance(self.remove_branding, Unset)
            else (None, str(self.remove_branding).lower().encode(), "text/plain")
        )

        field_dict: Dict[str, Any] = {}
        field_dict.update(
            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
        )
        field_dict.update({})
        if chat_bot_avatar is not UNSET:
            field_dict["chat_bot_avatar"] = chat_bot_avatar
        if chat_bot_bg is not UNSET:
            field_dict["chat_bot_bg"] = chat_bot_bg
        if default_prompt is not UNSET:
            field_dict["default_prompt"] = default_prompt
        if example_questions is not UNSET:
            for index, field_value in enumerate(example_questions):
                field_dict[f"example_questions[]"] = field_value
        if response_source is not UNSET:
            field_dict["response_source"] = response_source
        if chatbot_msg_lang is not UNSET:
            field_dict["chatbot_msg_lang"] = chatbot_msg_lang
        if chatbot_color is not UNSET:
            field_dict["chatbot_color"] = chatbot_color
        if persona_instructions is not UNSET:
            field_dict["persona_instructions"] = persona_instructions
        if citations_answer_source_label_msg is not UNSET:
            field_dict["citations_answer_source_label_msg"] = citations_answer_source_label_msg
        if citations_sources_label_msg is not UNSET:
            field_dict["citations_sources_label_msg"] = citations_sources_label_msg
        if hang_in_there_msg is not UNSET:
            field_dict["hang_in_there_msg"] = hang_in_there_msg
        if chatbot_siesta_msg is not UNSET:
            field_dict["chatbot_siesta_msg"] = chatbot_siesta_msg
        if is_loading_indicator_enabled is not UNSET:
            field_dict["is_loading_indicator_enabled"] = is_loading_indicator_enabled
        if enable_citations is not UNSET:
            field_dict["enable_citations"] = enable_citations
        if citations_view_type is not UNSET:
            field_dict["citations_view_type"] = citations_view_type
        if no_answer_message is not UNSET:
            field_dict["no_answer_message"] = no_answer_message
        if ending_message is not UNSET:
            field_dict["ending_message"] = ending_message
        if remove_branding is not UNSET:
            field_dict["remove_branding"] = remove_branding

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        _chat_bot_avatar = src_dict.get("chat_bot_avatar")
        chat_bot_avatar: Union[Unset, File]
        if isinstance(_chat_bot_avatar, Unset):
            chat_bot_avatar = UNSET
        else:
            chat_bot_avatar = File(payload=BytesIO(_chat_bot_avatar))

        _chat_bot_bg = src_dict.get("chat_bot_bg")
        chat_bot_bg: Union[Unset, File]
        if isinstance(_chat_bot_bg, Unset):
            chat_bot_bg = UNSET
        else:
            chat_bot_bg = File(payload=BytesIO(_chat_bot_bg))

        default_prompt = src_dict.get("default_prompt")

        example_questions = cast(List[str], src_dict.get("example_questions"))

        response_source = src_dict.get("response_source")

        chatbot_msg_lang = src_dict.get("chatbot_msg_lang")

        chatbot_color = src_dict.get("chatbot_color")

        persona_instructions = src_dict.get("persona_instructions")

        citations_answer_source_label_msg = src_dict.get("citations_answer_source_label_msg")

        citations_sources_label_msg = src_dict.get("citations_sources_label_msg")

        hang_in_there_msg = src_dict.get("hang_in_there_msg")

        chatbot_siesta_msg = src_dict.get("chatbot_siesta_msg")

        is_loading_indicator_enabled = src_dict.get("is_loading_indicator_enabled")

        enable_citations = src_dict.get("enable_citations")

        citations_view_type = src_dict.get("citations_view_type")

        no_answer_message = src_dict.get("no_answer_message")

        ending_message = src_dict.get("ending_message")

        remove_branding = src_dict.get("remove_branding")

        update_settings_multipart_data = cls(
            chat_bot_avatar=chat_bot_avatar,
            chat_bot_bg=chat_bot_bg,
            default_prompt=default_prompt,
            example_questions=example_questions,
            response_source=response_source,
            chatbot_msg_lang=chatbot_msg_lang,
            chatbot_color=chatbot_color,
            persona_instructions=persona_instructions,
            citations_answer_source_label_msg=citations_answer_source_label_msg,
            citations_sources_label_msg=citations_sources_label_msg,
            hang_in_there_msg=hang_in_there_msg,
            chatbot_siesta_msg=chatbot_siesta_msg,
            is_loading_indicator_enabled=is_loading_indicator_enabled,
            enable_citations=enable_citations,
            citations_view_type=citations_view_type,
            no_answer_message=no_answer_message,
            ending_message=ending_message,
            remove_branding=remove_branding,
        )

        update_settings_multipart_data.additional_properties = src_dict
        return update_settings_multipart_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_settings_multipart_data_citations_view_type.py:
```
from enum import Enum


class UpdateSettingsMultipartDataCitationsViewType(str, Enum):
    HIDE = "hide"
    SHOW = "show"
    USER = "user"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_settings_response_200_data import UpdateSettingsResponse200Data


T = TypeVar("T", bound="UpdateSettingsResponse200")


@attr.s(auto_attribs=True)
class UpdateSettingsResponse200:
    """
    Attributes:
        status (Union[Unset, UpdateSettingsResponse200Status]): The status of the response Example: success.
        data (Union[Unset, UpdateSettingsResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "UpdateSettingsResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_settings_response_200_data import UpdateSettingsResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateSettingsResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateSettingsResponse200Data.from_dict(_data)

        update_settings_response_200 = cls(
            status=status,
            data=data,
        )

        update_settings_response_200.additional_properties = src_dict
        return update_settings_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_200_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateSettingsResponse200Data")


@attr.s(auto_attribs=True)
class UpdateSettingsResponse200Data:
    """
    Attributes:
        updated (Union[Unset, bool]): Whether the project was updated successfully or not Example: True.
    """

    updated: Union[Unset, bool] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        updated = self.updated

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if updated is not UNSET:
            field_dict["updated"] = updated

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        updated = src_dict.get("updated")

        update_settings_response_200_data = cls(
            updated=updated,
        )

        update_settings_response_200_data.additional_properties = src_dict
        return update_settings_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_200_status.py:
```
from enum import Enum


class UpdateSettingsResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_400.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_settings_response_400_data import UpdateSettingsResponse400Data


T = TypeVar("T", bound="UpdateSettingsResponse400")


@attr.s(auto_attribs=True)
class UpdateSettingsResponse400:
    """
    Attributes:
        status (Union[Unset, UpdateSettingsResponse400Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdateSettingsResponse400Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdateSettingsResponse400Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_settings_response_400_data import UpdateSettingsResponse400Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateSettingsResponse400Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateSettingsResponse400Data.from_dict(_data)

        update_settings_response_400 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_settings_response_400.additional_properties = src_dict
        return update_settings_response_400

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_400_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateSettingsResponse400Data")


@attr.s(auto_attribs=True)
class UpdateSettingsResponse400Data:
    """
    Attributes:
        code (Union[Unset, UpdateSettingsResponse400DataCode]): The error status code Example: 400.
        message (Union[Unset, UpdateSettingsResponse400DataMessage]): The error message Example: Please upload a valid
            image file for avatar.
    """

    code: Union[Unset, str] = "400"
    message: Union[Unset, str] = "Please upload a valid image file for avatar"
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message: Union[Unset, str] = UNSET
        if not isinstance(self.message, Unset):
            message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_settings_response_400_data = cls(
            code=code,
            message=message,
        )

        update_settings_response_400_data.additional_properties = src_dict
        return update_settings_response_400_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_400_data_code.py:
```
from enum import IntEnum


class UpdateSettingsResponse400DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_400_data_message.py:
```
from enum import Enum


class UpdateSettingsResponse400DataMessage(str, Enum):
    LANGUAGE_PROFICIENCY_IS_REQUIRED = "Language Proficiency is required."
    PLEASE_UPLOAD_A_VALID_IMAGE_FILE_FOR_AVATAR = "Please upload a valid image file for avatar"
    PLEASE_UPLOAD_A_VALID_IMAGE_FILE_FOR_BACKGROUND = "Please upload a valid image file for background"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_400_status.py:
```
from enum import Enum


class UpdateSettingsResponse400Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_settings_response_401_data import UpdateSettingsResponse401Data


T = TypeVar("T", bound="UpdateSettingsResponse401")


@attr.s(auto_attribs=True)
class UpdateSettingsResponse401:
    """
    Attributes:
        status (Union[Unset, UpdateSettingsResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdateSettingsResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdateSettingsResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_settings_response_401_data import UpdateSettingsResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateSettingsResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateSettingsResponse401Data.from_dict(_data)

        update_settings_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_settings_response_401.additional_properties = src_dict
        return update_settings_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateSettingsResponse401Data")


@attr.s(auto_attribs=True)
class UpdateSettingsResponse401Data:
    """
    Attributes:
        code (Union[Unset, UpdateSettingsResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_settings_response_401_data = cls(
            code=code,
            message=message,
        )

        update_settings_response_401_data.additional_properties = src_dict
        return update_settings_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_401_data_code.py:
```
from enum import IntEnum


class UpdateSettingsResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_401_status.py:
```
from enum import Enum


class UpdateSettingsResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_settings_response_500_data import UpdateSettingsResponse500Data


T = TypeVar("T", bound="UpdateSettingsResponse500")


@attr.s(auto_attribs=True)
class UpdateSettingsResponse500:
    """
    Attributes:
        status (Union[Unset, UpdateSettingsResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdateSettingsResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdateSettingsResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_settings_response_500_data import UpdateSettingsResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateSettingsResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateSettingsResponse500Data.from_dict(_data)

        update_settings_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_settings_response_500.additional_properties = src_dict
        return update_settings_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateSettingsResponse500Data")


@attr.s(auto_attribs=True)
class UpdateSettingsResponse500Data:
    """
    Attributes:
        code (Union[Unset, UpdateSettingsResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_settings_response_500_data = cls(
            code=code,
            message=message,
        )

        update_settings_response_500_data.additional_properties = src_dict
        return update_settings_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_500_data_code.py:
```
from enum import IntEnum


class UpdateSettingsResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_settings_response_500_status.py:
```
from enum import Enum


class UpdateSettingsResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_user_multipart_data.py:
```
from io import BytesIO
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, File, FileJsonType, Unset

T = TypeVar("T", bound="UpdateUserMultipartData")


@attr.s(auto_attribs=True)
class UpdateUserMultipartData:
    """
    Attributes:
        profile_photo (Union[Unset, File]): User profile photo Example: avatar.png.
        name (Union[Unset, str]): User name Example: John Doe.
    """

    profile_photo: Union[Unset, File] = UNSET
    name: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        profile_photo: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.profile_photo, Unset):
            profile_photo = self.profile_photo.to_tuple()

        name = self.name

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if profile_photo is not UNSET:
            field_dict["profile_photo"] = profile_photo
        if name is not UNSET:
            field_dict["name"] = name

        return field_dict

    def to_multipart(self) -> Dict[str, Any]:
        profile_photo: Union[Unset, FileJsonType] = UNSET
        if not isinstance(self.profile_photo, Unset):
            profile_photo = self.profile_photo.to_tuple()

        name = self.name if isinstance(self.name, Unset) else (None, str(self.name).encode(), "text/plain")

        field_dict: Dict[str, Any] = {}
        field_dict.update(
            {key: (None, str(value).encode(), "text/plain") for key, value in self.additional_properties.items()}
        )
        field_dict.update({})
        if profile_photo is not UNSET:
            field_dict["profile_photo"] = profile_photo
        if name is not UNSET:
            field_dict["name"] = name

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        _profile_photo = src_dict.get("profile_photo")
        profile_photo: Union[Unset, File]
        if isinstance(_profile_photo, Unset):
            profile_photo = UNSET
        else:
            profile_photo = File(payload=BytesIO(_profile_photo))

        name = src_dict.get("name")

        update_user_multipart_data = cls(
            profile_photo=profile_photo,
            name=name,
        )

        update_user_multipart_data.additional_properties = src_dict
        return update_user_multipart_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_user_response_200.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_user_response_200_data import UpdateUserResponse200Data


T = TypeVar("T", bound="UpdateUserResponse200")


@attr.s(auto_attribs=True)
class UpdateUserResponse200:
    """
    Attributes:
        status (Union[Unset, UpdateUserResponse200Status]): The status of the response Example: success.
        data (Union[Unset, UpdateUserResponse200Data]):
    """

    status: Union[Unset, str] = "success"
    data: Union[Unset, "UpdateUserResponse200Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_user_response_200_data import UpdateUserResponse200Data

        status = src_dict.get("status")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateUserResponse200Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateUserResponse200Data.from_dict(_data)

        update_user_response_200 = cls(
            status=status,
            data=data,
        )

        update_user_response_200.additional_properties = src_dict
        return update_user_response_200

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_user_response_200_data.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateUserResponse200Data")


@attr.s(auto_attribs=True)
class UpdateUserResponse200Data:
    """
    Attributes:
        created_at (Union[Unset, datetime.datetime]): When was this user created? Example: 2023-04-30 16:43:53.
        email (Union[Unset, str]): User email Example: user@domain.com.
        id (Union[Unset, int]): User ID Example: 1.
        name (Union[Unset, str]): User name Example: John Doe.
        profile_photo_url (Union[Unset, str]): User profile photo URL Example:
            https://app.customgpt.ai/user/1/profile_photo_url.
        updated_at (Union[Unset, datetime.datetime]): When was this user updated? Example: 2023-04-30 16:43:53.
    """

    created_at: Union[Unset, datetime.datetime] = UNSET
    email: Union[Unset, str] = UNSET
    id: Union[Unset, int] = UNSET
    name: Union[Unset, str] = UNSET
    profile_photo_url: Union[Unset, str] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        email = self.email
        id = self.id
        name = self.name
        profile_photo_url = self.profile_photo_url
        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if email is not UNSET:
            field_dict["email"] = email
        if id is not UNSET:
            field_dict["id"] = id
        if name is not UNSET:
            field_dict["name"] = name
        if profile_photo_url is not UNSET:
            field_dict["profile_photo_url"] = profile_photo_url
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        email = src_dict.get("email")

        id = src_dict.get("id")

        name = src_dict.get("name")

        profile_photo_url = src_dict.get("profile_photo_url")

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        update_user_response_200_data = cls(
            created_at=created_at,
            email=email,
            id=id,
            name=name,
            profile_photo_url=profile_photo_url,
            updated_at=updated_at,
        )

        update_user_response_200_data.additional_properties = src_dict
        return update_user_response_200_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_user_response_200_status.py:
```
from enum import Enum


class UpdateUserResponse200Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_user_response_401.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_user_response_401_data import UpdateUserResponse401Data


T = TypeVar("T", bound="UpdateUserResponse401")


@attr.s(auto_attribs=True)
class UpdateUserResponse401:
    """
    Attributes:
        status (Union[Unset, UpdateUserResponse401Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdateUserResponse401Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdateUserResponse401Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_user_response_401_data import UpdateUserResponse401Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateUserResponse401Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateUserResponse401Data.from_dict(_data)

        update_user_response_401 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_user_response_401.additional_properties = src_dict
        return update_user_response_401

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_user_response_401_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateUserResponse401Data")


@attr.s(auto_attribs=True)
class UpdateUserResponse401Data:
    """
    Attributes:
        code (Union[Unset, UpdateUserResponse401DataCode]): The error status code Example: 401.
        message (Union[Unset, str]):  Example: API Token is either missing or invalid.
    """

    code: Union[Unset, str] = "401"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_user_response_401_data = cls(
            code=code,
            message=message,
        )

        update_user_response_401_data.additional_properties = src_dict
        return update_user_response_401_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_user_response_401_data_code.py:
```
from enum import IntEnum


class UpdateUserResponse401DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_user_response_401_status.py:
```
from enum import Enum


class UpdateUserResponse401Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_user_response_500.py:
```
from typing import TYPE_CHECKING, Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.update_user_response_500_data import UpdateUserResponse500Data


T = TypeVar("T", bound="UpdateUserResponse500")


@attr.s(auto_attribs=True)
class UpdateUserResponse500:
    """
    Attributes:
        status (Union[Unset, UpdateUserResponse500Status]): The status of the response Example: error.
        url (Union[Unset, str]): The URL of the request Example: https://app.customgpt.ai/api/v1/projects/1.
        data (Union[Unset, UpdateUserResponse500Data]):
    """

    status: Union[Unset, str] = "error"
    url: Union[Unset, str] = UNSET
    data: Union[Unset, "UpdateUserResponse500Data"] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        status: Union[Unset, str] = UNSET
        if not isinstance(self.status, Unset):
            status = self.status

        url = self.url
        data: Union[Unset, Dict[str, Any]] = UNSET
        if not isinstance(self.data, Unset):
            data = self.data.to_dict()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if status is not UNSET:
            field_dict["status"] = status
        if url is not UNSET:
            field_dict["url"] = url
        if data is not UNSET:
            field_dict["data"] = data

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        from ..models.update_user_response_500_data import UpdateUserResponse500Data

        status = src_dict.get("status")

        url = src_dict.get("url")

        _data = src_dict.get("data")
        data: Union[Unset, UpdateUserResponse500Data]
        if isinstance(_data, Unset):
            data = UNSET
        else:
            data = UpdateUserResponse500Data.from_dict(_data)

        update_user_response_500 = cls(
            status=status,
            url=url,
            data=data,
        )

        update_user_response_500.additional_properties = src_dict
        return update_user_response_500

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_user_response_500_data.py:
```
from typing import Any, Dict, List, Type, TypeVar, Union

import attr

from ..types import UNSET, Unset

T = TypeVar("T", bound="UpdateUserResponse500Data")


@attr.s(auto_attribs=True)
class UpdateUserResponse500Data:
    """
    Attributes:
        code (Union[Unset, UpdateUserResponse500DataCode]): The error status code Example: 500.
        message (Union[Unset, str]):  Example: Internal Server Error.
    """

    code: Union[Unset, str] = "500"
    message: Union[Unset, str] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        code: Union[Unset, int] = UNSET
        if not isinstance(self.code, Unset):
            code = self.code

        message = self.message

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if code is not UNSET:
            field_dict["code"] = code
        if message is not UNSET:
            field_dict["message"] = message

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        code = src_dict.get("code")

        message = src_dict.get("message")

        update_user_response_500_data = cls(
            code=code,
            message=message,
        )

        update_user_response_500_data.additional_properties = src_dict
        return update_user_response_500_data

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/customgpt_client/models/update_user_response_500_data_code.py:
```
from enum import IntEnum


class UpdateUserResponse500DataCode(IntEnum):
    VALUE_400 = 400
    VALUE_401 = 401
    VALUE_403 = 403
    VALUE_404 = 404
    VALUE_500 = 500
    VALUE_503 = 503

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/update_user_response_500_status.py:
```
from enum import Enum


class UpdateUserResponse500Status(str, Enum):
    ERROR = "error"
    SUCCESS = "success"

    def __str__(self) -> str:
        return str(self.value)

```

Contents of customgpt-client/customgpt_client/models/user.py:
```
import datetime
from typing import Any, Dict, List, Type, TypeVar, Union

import attr
from dateutil.parser import isoparse

from ..types import UNSET, Unset

T = TypeVar("T", bound="User")


@attr.s(auto_attribs=True)
class User:
    """
    Attributes:
        created_at (Union[Unset, datetime.datetime]): When was this user created? Example: 2023-04-30 16:43:53.
        email (Union[Unset, str]): User email Example: user@domain.com.
        id (Union[Unset, int]): User ID Example: 1.
        name (Union[Unset, str]): User name Example: John Doe.
        profile_photo_url (Union[Unset, str]): User profile photo URL Example:
            https://app.customgpt.ai/user/1/profile_photo_url.
        updated_at (Union[Unset, datetime.datetime]): When was this user updated? Example: 2023-04-30 16:43:53.
    """

    created_at: Union[Unset, datetime.datetime] = UNSET
    email: Union[Unset, str] = UNSET
    id: Union[Unset, int] = UNSET
    name: Union[Unset, str] = UNSET
    profile_photo_url: Union[Unset, str] = UNSET
    updated_at: Union[Unset, datetime.datetime] = UNSET
    additional_properties: Dict[str, Any] = attr.ib(init=False, factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        created_at: Union[Unset, str] = UNSET
        if not isinstance(self.created_at, Unset):
            created_at = self.created_at.isoformat()

        email = self.email
        id = self.id
        name = self.name
        profile_photo_url = self.profile_photo_url
        updated_at: Union[Unset, str] = UNSET
        if not isinstance(self.updated_at, Unset):
            updated_at = self.updated_at.isoformat()

        field_dict: Dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update({})
        if created_at is not UNSET:
            field_dict["created_at"] = created_at
        if email is not UNSET:
            field_dict["email"] = email
        if id is not UNSET:
            field_dict["id"] = id
        if name is not UNSET:
            field_dict["name"] = name
        if profile_photo_url is not UNSET:
            field_dict["profile_photo_url"] = profile_photo_url
        if updated_at is not UNSET:
            field_dict["updated_at"] = updated_at

        return field_dict

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
        _created_at = src_dict.get("created_at")
        created_at: Union[Unset, datetime.datetime]
        if isinstance(_created_at, Unset):
            created_at = UNSET
        else:
            created_at = isoparse(_created_at)

        email = src_dict.get("email")

        id = src_dict.get("id")

        name = src_dict.get("name")

        profile_photo_url = src_dict.get("profile_photo_url")

        _updated_at = src_dict.get("updated_at")
        updated_at: Union[Unset, datetime.datetime]
        if isinstance(_updated_at, Unset):
            updated_at = UNSET
        else:
            updated_at = isoparse(_updated_at)

        user = cls(
            created_at=created_at,
            email=email,
            id=id,
            name=name,
            profile_photo_url=profile_photo_url,
            updated_at=updated_at,
        )

        user.additional_properties = src_dict
        return user

    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties

```

Contents of customgpt-client/tests/__init__.py:
```

```

Contents of customgpt-client/tests/credentials.py:
```
# Credentials File for easy handling across the test suite


def credentials():
    # (base_url, api_key)
    return ("https://app.customgpt.ai", "")

```

Contents of customgpt-client/tests/test_citations.py:
```
import time

import pytest

from customgpt_client import CustomGPT
from tests.credentials import credentials


def test_sync_citations():
    CustomGPT.base_url, CustomGPT.api_key = credentials()

    CustomGPT.timeout = 10000
    response = CustomGPT.Project.create(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    project_id = response_create.data["id"]
    response = CustomGPT.Conversation.create(
        project_id=project_id, name="test_converation"
    )
    response_create = response.parsed
    session_id = response_create.data["session_id"]
    assert response_create.data["name"] == "test_converation"
    assert response.status_code == 201

    # wait for chat active
    is_chat_active = 0
    json_project = {}
    while not is_chat_active:
        response_project = CustomGPT.Project.get(project_id=project_id)
        json_project = response_project.parsed
        is_chat_active = json_project.data.is_chat_active
        time.sleep(5)

    assert json_project.data.is_chat_active == 1
    response = CustomGPT.Conversation.send(
        project_id=project_id,
        session_id=session_id,
        prompt="Who is Tom? I need a short answer in 10 words.",
    )
    citation_id = response.parsed.data.citations[0]

    response = CustomGPT.Citation.get(project_id=project_id, citation_id=citation_id)
    assert response.status_code == 200


@pytest.mark.asyncio
async def test_async_citations():
    CustomGPT.base_url, CustomGPT.api_key = credentials()

    CustomGPT.timeout = 10000
    response = await CustomGPT.Project.acreate(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    project_id = response_create.data.id
    response = await CustomGPT.Conversation.acreate(
        project_id=project_id, name="test_converation"
    )
    response_create = response.parsed
    session_id = response_create.data.session_id
    assert response_create.data.name == "test_converation"
    assert response.status_code == 201

    # wait for chat active
    is_chat_active = 0
    json_project = {}
    while not is_chat_active:
        response_project = await CustomGPT.Project.aget(project_id=project_id)
        json_project = response_project.parsed
        is_chat_active = json_project.data.is_chat_active
        time.sleep(5)

    assert json_project.data.is_chat_active == 1
    response = CustomGPT.Conversation.send(
        project_id=project_id,
        session_id=session_id,
        prompt="Who is Tom? I need a short answer in 10 words.",
    )
    citation_id = response.parsed.data.citations[0]

    response = await CustomGPT.Citation.aget(
        project_id=project_id, citation_id=citation_id
    )
    assert response.status_code == 200

```

Contents of customgpt-client/tests/test_conversations.py:
```
import time

import pytest

from customgpt_client import CustomGPT
from tests.credentials import credentials


def test_sync_conversations():
    CustomGPT.base_url, CustomGPT.api_key = credentials()

    CustomGPT.timeout = 10000
    response = CustomGPT.Project.create(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    project_id = response_create.data.id
    response = CustomGPT.Conversation.create(
        project_id=project_id, name="test_converation"
    )
    response_create = response.parsed
    session_id = response_create.data.session_id
    assert response_create.data.name == "test_converation"
    assert response.status_code == 201

    # # wait for chat active
    is_chat_active = 0
    json_project = {}
    while not is_chat_active:
        response_project = CustomGPT.Project.get(project_id=project_id)
        json_project = response_project.parsed
        is_chat_active = json_project.data.is_chat_active
        time.sleep(5)

    assert json_project.data.is_chat_active == 1

    # Get Project By created project Id and assert updated name
    response = CustomGPT.Conversation.get(project_id=project_id)
    response_conversation = response.parsed
    assert len(response_conversation.data.data) > 0

    # assert response_project['data']['name'] == 'test_conversation2'
    assert response.status_code == 200

    # send message to conversation stream false
    response = CustomGPT.Conversation.send(
        project_id=project_id,
        session_id=session_id,
        prompt="Who is Tom? I need a short answer in 10 words.",
    )
    assert response.status_code == 200

    # Fetch Created project messages
    response = CustomGPT.Conversation.messages(
        project_id=project_id, session_id=session_id
    )
    response_messages = response.parsed
    assert response.status_code == 200
    assert len(response_messages.data.messages.data) > 0
    # send message to conversation stream true
    response = CustomGPT.Conversation.send(
        project_id=project_id,
        session_id=session_id,
        prompt="Who is Tom? I need a short answer in 10 words.",
        stream=True,
    )
    array = []
    for chunk in response.events():
        array.append(chunk)
    assert len(array) > 1

    # send message to conversation false
    response = CustomGPT.Conversation.send(
        project_id=project_id,
        session_id=session_id,
        prompt="Who is Tom? I need a short answer in 10 words.",
    )
    assert response.status_code == 200

    # Delete the project
    response = CustomGPT.Conversation.delete(
        project_id=project_id, session_id=session_id
    )
    assert response.status_code == 200


@pytest.mark.asyncio
async def test_async_conversations():
    CustomGPT.base_url, CustomGPT.api_key = credentials()

    CustomGPT.timeout = 10000
    response = await CustomGPT.Project.acreate(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    project_id = response_create.data.id
    response = await CustomGPT.Conversation.acreate(
        project_id=project_id, name="test_converation"
    )
    response_create = response.parsed
    session_id = response_create.data.session_id
    assert response_create.data.name == "test_converation"
    assert response.status_code == 201

    # # wait for chat active
    is_chat_active = 0
    json_project = {}
    while not is_chat_active:
        response_project = await CustomGPT.Project.aget(project_id=project_id)
        json_project = response_project.parsed
        is_chat_active = json_project.data.is_chat_active
        time.sleep(5)

    assert json_project.data.is_chat_active == 1

    # Get Conversations of project
    response = await CustomGPT.Conversation.aget(project_id=project_id)
    response_project = response.parsed
    assert len(response_project.data.data) > 0
    assert response.status_code == 200

    response = await CustomGPT.Conversation.aupdate(
        project_id=project_id, session_id=session_id, name="test_conversation2"
    )
    response_project = response.parsed
    assert response_project.data.name == "test_conversation2"
    assert response.status_code == 200

    # send message to conversation stream false
    response = await CustomGPT.Conversation.asend(
        project_id=project_id,
        session_id=session_id,
        prompt="Who is Tom? I need a short answer in 10 words.",
    )
    assert response.status_code == 200

    # Fetch Created project messages
    response = await CustomGPT.Conversation.amessages(
        project_id=project_id, session_id=session_id
    )
    assert response.status_code == 200

    # Delete the project
    response = await CustomGPT.Conversation.adelete(
        project_id=project_id, session_id=session_id
    )
    assert response.status_code == 200

```

Contents of customgpt-client/tests/test_page_metadata.py:
```
import pytest

from customgpt_client import CustomGPT
from tests.credentials import credentials


def test_sync_page_metadata():
    CustomGPT.base_url, CustomGPT.api_key = credentials()
    CustomGPT.timeout = 10000
    response = CustomGPT.Project.create(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    project_id = response_create.data["id"]
    response = CustomGPT.Page.get(project_id=project_id)
    assert response.status_code == 200
    response_page = response.parsed
    if len(response_page.data.pages.data) > 0:
        page_id = response_page.data.pages.data[0].id
        metadata = CustomGPT.PageMetadata.get(project_id=project_id, page_id=page_id)
        assert metadata.status_code == 200
        title = metadata.parsed.data.title
        update_metadata = CustomGPT.PageMetadata.update(
            project_id=project_id, page_id=page_id, title="test"
        )
        assert update_metadata.status_code == 200
        assert update_metadata.parsed.data.title != title
        response = CustomGPT.Page.delete(project_id=project_id, page_id=page_id)
        assert response.status_code == 200


@pytest.mark.asyncio
async def test_async_page_metadata():
    CustomGPT.base_url, CustomGPT.api_key = credentials()
    CustomGPT.timeout = 10000
    response = await CustomGPT.Project.acreate(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    project_id = response_create.data["id"]
    response = await CustomGPT.Page.aget(project_id=project_id)
    assert response.status_code == 200
    response_page = response.parsed
    if len(response_page.data.pages.data) > 0:
        page_id = response_page.data.pages.data[0].id
        metadata = await CustomGPT.PageMetadata.aget(
            project_id=project_id, page_id=page_id
        )
        assert metadata.status_code == 200
        title = metadata.parsed.data.title
        update_metadata = await CustomGPT.PageMetadata.aupdate(
            project_id=project_id, page_id=page_id, title="test"
        )
        assert update_metadata.status_code == 200
        assert update_metadata.parsed.data.title != title
        response = await CustomGPT.Page.adelete(project_id=project_id, page_id=page_id)
        assert response.status_code == 200

```

Contents of customgpt-client/tests/test_pages.py:
```
import pytest

from customgpt_client import CustomGPT
from tests.credentials import credentials


def test_sync_pages():
    CustomGPT.base_url, CustomGPT.api_key = credentials()
    CustomGPT.timeout = 10000
    response = CustomGPT.Project.create(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    project_id = response_create.data["id"]
    response = CustomGPT.Page.get(project_id=project_id)
    assert response.status_code == 200
    response_page = response.parsed
    if len(response_page.data.pages.data) > 0:
        page_id = response_page.data.pages.data[0].id
        response = CustomGPT.Page.reindex(project_id=project_id, page_id=page_id)
        assert response.parsed.data.updated
        assert response.status_code == 200
        response = CustomGPT.Page.delete(project_id=project_id, page_id=page_id)
        assert response.status_code == 200


@pytest.mark.asyncio
async def test_async_pages():
    CustomGPT.base_url, CustomGPT.api_key = credentials()

    CustomGPT.timeout = 10000
    response = await CustomGPT.Project.acreate(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    project_id = response_create.data.id
    response = await CustomGPT.Page.aget(project_id=project_id)
    response_page = response.parsed
    if len(response_page.data.pages.data) > 0:
        page_id = response_page.data.pages.data[0].id
        response = await CustomGPT.Page.areindex(project_id=project_id, page_id=page_id)
        assert response.parsed.data.updated
        assert response.status_code == 200
        response = await CustomGPT.Page.adelete(project_id=project_id, page_id=page_id)
        assert response.status_code == 200

```

Contents of customgpt-client/tests/test_plugins.py:
```
import json
import random
import string
import time

import pytest

from customgpt_client import CustomGPT
from tests.credentials import credentials


def test_sync_plugins():
    CustomGPT.base_url, CustomGPT.api_key = credentials()
    response = CustomGPT.Project.create(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_project = response.parsed
    assert response.status_code == 201
    project_id = response_project.data.id
    json_project = {}
    is_chat_active = 0
    while not is_chat_active:
        response_project = CustomGPT.Project.get(project_id=project_id)
        json_project = response_project.parsed
        is_chat_active = json_project.data.is_chat_active
        time.sleep(5)

    plugin_name = "".join(random.choice(string.ascii_lowercase) for _ in range(10))

    # Add new sitemap to project using source api.
    create_plugin = CustomGPT.ProjectPlugins.create(
        project_id=project_id,
        model_name=plugin_name,
        human_name="The Indoor Plants",
        keywords="Indoor plants, Gardening, Trusted information.",
        description="Trusted information about indoor plants and gardening.",
        is_active=True,
    )
    model_name = create_plugin.parsed.data.model_name
    assert model_name == plugin_name
    assert create_plugin.status_code == 201

    # Update a plugin
    plugin_name2 = "".join(random.choice(string.ascii_lowercase) for _ in range(10))
    create_plugin = CustomGPT.ProjectPlugins.update(
        project_id=project_id,
        model_name=plugin_name2,
        human_name="The Indoor Plants",
        keywords="Indoor plants, Gardening, Trusted information.",
        description="Trusted information about indoor plants and gardening.",
        is_active=True,
    )
    model_name = create_plugin.parsed.data.model_name
    assert model_name == plugin_name2
    assert create_plugin.status_code == 200

    get_plugin = CustomGPT.ProjectPlugins.get(project_id=project_id)
    data = json.loads(get_plugin.content)["data"]
    assert get_plugin.status_code == 200
    assert data["model_name"] == plugin_name2


@pytest.mark.asyncio
async def test_async_plugins():
    CustomGPT.base_url, CustomGPT.api_key = credentials()
    response = await CustomGPT.Project.acreate(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_project = response.parsed
    assert response.status_code == 201
    project_id = response_project.data.id
    json_project = {}
    is_chat_active = 0
    while not is_chat_active:
        response_project = await CustomGPT.Project.aget(project_id=project_id)
        json_project = response_project.parsed
        is_chat_active = json_project.data.is_chat_active
        time.sleep(5)

    plugin_name = "".join(random.choice(string.ascii_lowercase) for _ in range(10))

    # Add new sitemap to project using source api.
    create_plugin = await CustomGPT.ProjectPlugins.acreate(
        project_id=project_id,
        model_name=plugin_name,
        human_name="The Indoor Plants",
        keywords="Indoor plants, Gardening, Trusted information.",
        description="Trusted information about indoor plants and gardening.",
        is_active=True,
    )
    model_name = create_plugin.parsed.data.model_name
    assert model_name == plugin_name
    assert create_plugin.status_code == 201

    # Update a plugin
    plugin_name2 = "".join(random.choice(string.ascii_lowercase) for _ in range(10))
    create_plugin = await CustomGPT.ProjectPlugins.aupdate(
        project_id=project_id,
        model_name=plugin_name2,
        human_name="The Indoor Plants",
        keywords="Indoor plants, Gardening, Trusted information.",
        description="Trusted information about indoor plants and gardening.",
        is_active=True,
    )
    model_name = create_plugin.parsed.data.model_name
    assert model_name == plugin_name2
    assert create_plugin.status_code == 200

    get_plugin = await CustomGPT.ProjectPlugins.aget(project_id=project_id)
    data = json.loads(get_plugin.content)["data"]
    assert get_plugin.status_code == 200
    assert data["model_name"] == plugin_name2

```

Contents of customgpt-client/tests/test_project_settings.py:
```
import pytest

from customgpt_client import CustomGPT
from tests.credentials import credentials


def test_sync_project_settings():
    CustomGPT.base_url, CustomGPT.api_key = credentials()

    CustomGPT.timeout = 10000
    response = CustomGPT.Project.create(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    project_id = response_create.data.id
    response = CustomGPT.ProjectSettings.get(project_id=project_id)
    default_prompt = response.parsed.data.default_prompt
    assert response.status_code == 200
    response_update = CustomGPT.ProjectSettings.update(
        project_id=project_id,
        default_prompt="Hello World",
        example_questions=["Who are you?"],
        response_source="default",
        chatbot_msg_lang="ur",
        persona_instructions="You Are test chatbot created from a pytest",
        is_loading_indicator_enabled=False,
        enable_citations=False,
    )
    assert response_update.status_code == 200
    response = CustomGPT.ProjectSettings.get(project_id=project_id)
    assert response.status_code == 200
    assert default_prompt != response.parsed.data.default_prompt


@pytest.mark.asyncio
async def test_async_project_settings():
    CustomGPT.base_url, CustomGPT.api_key = credentials()

    CustomGPT.timeout = 10000
    response = await CustomGPT.Project.acreate(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    project_id = response_create.data.id
    response = await CustomGPT.ProjectSettings.aget(project_id=project_id)
    default_prompt = response.parsed.data.default_prompt
    assert response.status_code == 200
    response_update = await CustomGPT.ProjectSettings.aupdate(
        project_id=project_id,
        default_prompt="Hello World",
        example_questions=["Who are you?"],
        response_source="default",
        chatbot_msg_lang="ur",
        persona_instructions="You Are test chatbot created from a pytest",
        is_loading_indicator_enabled=False,
        enable_citations=False,
    )
    assert response_update.status_code == 200
    response = await CustomGPT.ProjectSettings.aget(project_id=project_id)
    assert response.status_code == 200
    assert default_prompt != response.parsed.data.default_prompt

```

Contents of customgpt-client/tests/test_projects.py:
```
import pytest

from customgpt_client import CustomGPT
from tests.credentials import credentials


def test_sync_projects():
    CustomGPT.base_url, CustomGPT.api_key = credentials()

    response = CustomGPT.Project.create(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    assert response_create.data.project_name == "test"
    assert response.status_code == 201

    response = CustomGPT.Project.update(
        project_id=response.parsed.data.id,
        project_name="test2",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_update = response.parsed
    assert response_update.data.project_name == "test2"
    assert response.status_code == 200

    # Get Project By created project Id and assert updated name
    response = CustomGPT.Project.get(project_id=response_create.data.id)
    response_project = response.parsed
    assert response_project.data.project_name == response_update.data.project_name
    assert response.status_code == 200

    # Fetch Created project Stat
    response = CustomGPT.Project.stats(project_id=response_create.data.id)
    response_stats = response.parsed
    assert response.status_code == 200
    assert set(list(response_stats.data.to_dict().keys())) == set(
        [
            "pages_found",
            "pages_crawled",
            "pages_indexed",
            "crawl_credits_used",
            "query_credits_used",
            "total_queries",
            "total_words_indexed",
            "index_credits_used",
        ]
    )
    response = CustomGPT.Project.list()
    assert response.status_code == 200

    # Delete the project
    response = CustomGPT.Project.delete(project_id=response_create.data.id)
    assert response.status_code == 200


def test_error_projects():
    CustomGPT.base_url, CustomGPT.api_key = credentials()

    response = CustomGPT.Project.update(
        project_id=12334,
        project_name="test2",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    assert response.status_code == 403


@pytest.mark.asyncio
async def test_async_projects():
    CustomGPT.base_url, CustomGPT.api_key = credentials()

    response = await CustomGPT.Project.acreate(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    assert response_create.data.project_name == "test"
    assert response.status_code == 201

    response = await CustomGPT.Project.aupdate(
        project_id=response_create.data.id,
        project_name="test2",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_update = response.parsed
    assert response_update.data.project_name == "test2"
    assert response.status_code == 200

    # Get Project By created project Id and assert updated name
    response = await CustomGPT.Project.aget(project_id=response_create.data.id)
    response_project = response.parsed
    assert response_project.data.project_name == response_update.data.project_name
    assert response.status_code == 200

    # Fetch Created project Stat
    response = await CustomGPT.Project.astats(project_id=response_create.data.id)
    response_stats = response.parsed
    assert response.status_code == 200

    assert set(list(response_stats.data.to_dict().keys())) == set(
        [
            "pages_found",
            "pages_crawled",
            "pages_indexed",
            "crawl_credits_used",
            "query_credits_used",
            "total_queries",
            "total_words_indexed",
            "index_credits_used",
        ]
    )
    response = await CustomGPT.Project.alist()
    assert response.status_code == 200

    # Delete the project
    response = await CustomGPT.Project.adelete(project_id=response_create.data.id)
    assert response.status_code == 200

```

Contents of customgpt-client/tests/test_sources.py:
```
import os
import time

import pytest

from customgpt_client import CustomGPT
from customgpt_client.types import File
from tests.credentials import credentials

current_script_path = os.path.abspath(__file__)
file_name = "file/vanka.pdf"
file_path = os.path.join(os.path.dirname(current_script_path), file_name)


def test_sync_sources():
    CustomGPT.base_url, CustomGPT.api_key = credentials()
    response = CustomGPT.Project.create(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    assert response_create.data.project_name == "test"
    assert response.status_code == 201
    json_project = {}
    is_chat_active = 0
    while not is_chat_active:
        response_project = CustomGPT.Project.get(project_id=project_id)
        json_project = response_project.parsed
        is_chat_active = json_project.data.is_chat_active
        time.sleep(5)

    # Add new sitemap to project using source api.
    new_sitemap_path = "https://adorosario.github.io/small-sitemap.xml"
    create_source = CustomGPT.Source.create(
        project_id=project_id, sitemap_path=new_sitemap_path
    )
    data = create_source.parsed.data
    assert data.type == "sitemap"
    assert create_source.status_code == 201

    # Add File To Project
    with open(file_path, "rb") as file:
        file_content = file.read()

    create_source = CustomGPT.Source.create(
        project_id=project_id, file=File(payload=file_content, file_name="vanka.pdf")
    )
    data = create_source.parsed.data
    assert create_source.status_code == 201
    assert data.type == "upload"

    # List Sources
    list_sources = CustomGPT.Source.list(project_id=project_id)
    data = list_sources.parsed.data
    assert list_sources.status_code == 200
    assert len(data.sitemaps) > 0

    # # Delete Source
    source_id = data.sitemaps[0].id
    delete_source = CustomGPT.Source.delete(project_id=project_id, source_id=source_id)
    assert delete_source.status_code == 200


@pytest.mark.asyncio
async def test_async_sources():
    CustomGPT.base_url, CustomGPT.api_key = credentials()
    response = await CustomGPT.Project.acreate(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    assert response_create.data.project_name == "test"
    assert response.status_code == 201
    json_project = {}
    is_chat_active = 0
    while not is_chat_active:
        response_project = CustomGPT.Project.get(project_id=project_id)
        json_project = response_project.parsed
        is_chat_active = json_project.data.is_chat_active
        time.sleep(5)

    # Add new sitemap to project using source api.
    new_sitemap_path = "https://adorosario.github.io/small-sitemap.xml"
    create_source = await CustomGPT.Source.acreate(
        project_id=project_id, sitemap_path=new_sitemap_path
    )
    data = create_source.parsed.data
    assert data.type == "sitemap"
    assert create_source.status_code == 201

    # Add File To Project
    with open(file_path, "rb") as file:
        file_content = file.read()

    create_source = await CustomGPT.Source.acreate(
        project_id=project_id, file=File(payload=file_content, file_name="vanka.pdf")
    )
    data = create_source.parsed.data
    assert create_source.status_code == 201
    assert data.type == "upload"

    # List Sources
    list_sources = await CustomGPT.Source.alist(project_id=project_id)
    data = list_sources.parsed.data
    assert list_sources.status_code == 200
    assert len(data.sitemaps) > 0

    # # Delete Source
    source_id = data.sitemaps[0].id
    delete_source = await CustomGPT.Source.adelete(
        project_id=project_id, source_id=source_id
    )
    assert delete_source.status_code == 200

```

Contents of customgpt-client/tests/test_users.py:
```
import pytest

from customgpt_client import CustomGPT
from tests.credentials import credentials


def test_sync_users():
    CustomGPT.base_url, CustomGPT.api_key = credentials()
    CustomGPT.timeout = 10000
    response = CustomGPT.Project.create(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    response_create.data.id
    response = CustomGPT.User.get()
    assert response.status_code == 200
    response = CustomGPT.User.update(name="Hamza 2")
    response_json = response.parsed
    assert response.status_code == 200
    assert response_json.data.name == "Hamza 2"


def test_error_users():
    CustomGPT.base_url, CustomGPT.api_key = credentials()
    CustomGPT.api_key = ""
    response = CustomGPT.Project.create(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    assert response.status_code == 401


@pytest.mark.asyncio
async def test_async_users():
    CustomGPT.base_url, CustomGPT.api_key = credentials()
    CustomGPT.timeout = 10000
    response = await CustomGPT.Project.acreate(
        project_name="test",
        sitemap_path="https://adorosario.github.io/small-sitemap.xml",
    )
    response_create = response.parsed
    response_create.data.id
    response = await CustomGPT.User.aget()
    assert response.status_code == 200
    response = await CustomGPT.User.aupdate(name="Hamza 3")
    response_json = response.parsed
    assert response.status_code == 200
    assert response_json.data.name == "Hamza 3"

```

Contents of customgpt-client/tests/file/vanka.pdf:
```
[Could not decode file contents]

```

Contents of templates/README.md.jinja:
```
# CustomGPT SDK

## Usage
First, create a client:

```python
from {{ package_name }} import CustomGPT

CustomGPT.api_key="SuperSecretToken"
```

Now you can access to all of our Models:
Example Request will be like this:

Creating a Project synchronously:

```python
response = CustomGPT.Project.create(project_name='Test', sitemap_path='https://example.com/test.xml', file_data_retension=False, file=file)
project_id = response.data.id
```

Or do the same thing with an async version:

```python
response = await CustomGPT.Project.acreate(project_name='Test', sitemap_path='https://example.com/test.xml', file_data_retension=False, file=file)
project_id = response.data.id
```

```

Contents of templates/api_init.py.jinja:
```
""" Contains methods for accessing the API """

```

Contents of templates/client.py.jinja:
```
import ssl
from typing import Any, Dict, Union
import attr
{% from "endpoint_macros.py.jinja" import header_params, cookie_params, query_params, json_body, multipart_body,
    arguments, client, kwargs, parse_response, docstring %}

{% for collection in endpoint_collections_by_tag.values() %}
{% for endpoint in collection.endpoints %}
from customgpt_client.api.{{endpoint.tag}} import {{endpoint.name}}
{% if endpoint.json_body %}
from customgpt_client.models import {{endpoint.json_body.class_info.name}}
{% endif %}
{% if endpoint.multipart_body %}
from customgpt_client.models import {{endpoint.multipart_body.class_info.name}}
{% endif %}
{% endfor %}
{% endfor %}

def set_client():
    api_key = CustomGPT.api_key if hasattr(CustomGPT, 'api_key') else ""
    base_url = CustomGPT.base_url if hasattr(CustomGPT, 'base_url') else "https://app.customgpt.ai"
    timeout = CustomGPT.timeout if hasattr(CustomGPT, 'timeout') else 100.0
    return CustomGPT(api_key=api_key, base_url=base_url, timeout=timeout)
def pluck_data(fields, kwargs):
    json = {}
    for field in fields:
        if field in kwargs:
            json[field] = kwargs.pop(field)
    return json

@attr.s(auto_attribs=True)
class CustomGPT:
    """ A Client which has been authenticated for use on secured endpoints 
    Attributes:
        base_url: The base URL for the API, all requests are made to a relative path to this URL
        cookies: A dictionary of cookies to be sent with every request
        headers: A dictionary of headers to be sent with every request
        timeout: The maximum amount of a time in seconds a request can take. API functions will raise
            httpx.TimeoutException if this is exceeded.
        verify_ssl: Whether or not to verify the SSL certificate of the API server. This should be True in production,
            but can be set to False for testing purposes.
        raise_on_unexpected_status: Whether or not to raise an errors.UnexpectedStatus if the API returns a
            status code that was not documented in the source OpenAPI document.
        follow_redirects: Whether or not to follow redirects. Default value is False.
    """

    api_key: str
    prefix: str = "Bearer"
    auth_header_name: str = "Authorization"
    base_url: str = attr.ib("https://app.customgpt.ai")
    cookies: Dict[str, str] = attr.ib(factory=dict, kw_only=True)
    headers: Dict[str, str] = attr.ib(factory=dict, kw_only=True)
    timeout: float = attr.ib(5.0, kw_only=True)
    verify_ssl: Union[str, bool, ssl.SSLContext] = attr.ib(True, kw_only=True)
    raise_on_unexpected_status: bool = attr.ib(False, kw_only=True)
    follow_redirects: bool = attr.ib(False, kw_only=True)

    def with_headers(self, headers: Dict[str, str]) -> "CustomGPT":
        """ Get a new client matching this one with additional headers """
        return attr.evolve(self, headers={**self.headers, **headers})

    def get_cookies(self) -> Dict[str, str]:
        return {**self.cookies}

    def with_cookies(self, cookies: Dict[str, str]) -> "CustomGPT":
        """ Get a new client matching this one with additional cookies """
        return attr.evolve(self, cookies={**self.cookies, **cookies})

    def get_timeout(self) -> float:
        return self.timeout

    def with_timeout(self, timeout: float) -> "CustomGPT":
        """ Get a new client matching this one with a new timeout (in seconds) """
        return attr.evolve(self, timeout=timeout)

    def get_headers(self) -> Dict[str, str]:
        """Get headers to be used in authenticated endpoints"""
        auth_header_value = f"{self.prefix} {self.api_key}" if self.prefix else self.api_key
        return {self.auth_header_name: auth_header_value, **self.headers}

    {% for key, collection in endpoint_collections_by_tag.items() %}
    {% if "_" in key %}
        {% set words = key.split('_') %}
        {% set capitalized_words = [] %}
        {% for word in words %}
            {% set _ = capitalized_words.append(word.capitalize()) %}
        {% endfor %}
        {% set class_name = "".join(capitalized_words) %}
    {% elif key.endswith("s") %}
        {% set class_name = key[:-1].capitalize() %}
    {% else %}
        {% set class_name = key.capitalize() %}
    {% endif %}
    class {{class_name}}:
        {% for endpoint in collection.endpoints %}
        def {{ endpoint.name.split('_')[0] }}(*args: Any, **kwargs: Any):
            client = set_client()
            {% if endpoint.json_body %}
            fields = {{endpoint.json_body.data.properties.keys() | list}}
            json = pluck_data(fields, kwargs)
            kwargs['json_body'] = {{endpoint.json_body.class_info.name}}(**json)
            {% endif %}
            {% if endpoint.multipart_body %}
            fields = {{endpoint.multipart_body.data.properties.keys()| list}}
            json = pluck_data(fields, kwargs)
            kwargs['multipart_data'] = {{endpoint.multipart_body.class_info.name}}(**json)
            {% endif %}
     
            return {{endpoint.name}}.sync_detailed(client=client, *args, **kwargs)

        def a{{ endpoint.name.split('_')[0]}}(*args: Any, **kwargs: Any):
            client = set_client()
            {% if endpoint.json_body %}
            fields = {{endpoint.json_body.data.properties.keys()| list}}
            json = pluck_data(fields, kwargs)
            kwargs['json_body'] = {{endpoint.json_body.class_info.name}}(**json)
            {% endif %}
            {% if endpoint.multipart_body %}
            fields = {{endpoint.multipart_body.data.properties.keys()| list}}
            json = pluck_data(fields, kwargs)
            kwargs['multipart_data'] = {{endpoint.multipart_body.class_info.name}}(**json)
            {% endif %}
     
            return {{endpoint.name}}.asyncio_detailed(client=client, *args, **kwargs)
    {% endfor %}
    {% endfor %}




```

Contents of templates/endpoint_init.py.jinja:
```

```

Contents of templates/endpoint_macros.py.jinja:
```
{% from "property_templates/helpers.jinja" import guarded_statement %}
{% from "helpers.jinja" import safe_docstring %}

{% macro header_params(endpoint) %}
{% if endpoint.header_parameters %}
    {% for parameter in endpoint.header_parameters.values() %}
        {% set destination = 'headers["' +  parameter.name + '"]' %}
        {% import "property_templates/" + parameter.template as param_template %}
        {% if param_template.transform_header %}
            {% set statement = param_template.transform_header(parameter, parameter.python_name, destination) %}
        {% else %}
            {% set statement = destination + " = " + parameter.python_name %}
        {% endif %}
{{ guarded_statement(parameter, parameter.python_name, statement) }}
    {% endfor %}
{% endif %}
{% endmacro %}

{% macro cookie_params(endpoint) %}
{% if endpoint.cookie_parameters %}
    {% for parameter in endpoint.cookie_parameters.values() %}
        {% if parameter.required %}
cookies["{{ parameter.name}}"] = {{ parameter.python_name }}
        {% else %}
if {{ parameter.python_name }} is not UNSET:
    cookies["{{ parameter.name}}"] = {{ parameter.python_name }}
        {% endif %}
    {% endfor %}
{% endif %}
{% endmacro %}


{% macro query_params(endpoint) %}
{% if endpoint.query_parameters %}
params: Dict[str, Any] = {}
{% for property in endpoint.query_parameters.values() %}
    {% set destination = property.python_name %}
    {% import "property_templates/" + property.template as prop_template %}
    {% if prop_template.transform %}
        {% set destination = "json_" + property.python_name %}
{{ prop_template.transform(property, property.python_name, destination) }}
    {% endif %}
    {%- if not property.json_is_dict %}
    {% if property.name == 'stream'%}
params["{{ property.name }}"] = 1 if stream else 0
    {% else %}
params["{{ property.name }}"] = {{ destination }}
    {% endif %}
    {% else %}
    }
{{ guarded_statement(property, destination, "params.update(" + destination + ")") }}
    {% endif %}


{% endfor %}

params = {k: v for k, v in params.items() if v is not UNSET and v is not None}
{% endif %}
{% endmacro %}

{% macro json_body(endpoint) %}
{% if endpoint.json_body %}
    {% set property = endpoint.json_body %}
    {% set destination = "json_" + property.python_name %}
    {% import "property_templates/" + property.template as prop_template %}
    {% if prop_template.transform %}
{{ prop_template.transform(property, property.python_name, destination) }}
    {% else %}
{{ destination }} = {{ property.python_name }}
    {% endif %}
{% endif %}
{% endmacro %}

{% macro multipart_body(endpoint) %}
{% if endpoint.multipart_body %}
    {% set property = endpoint.multipart_body %}
    {% set destination = "multipart_" + property.python_name %}
    {% import "property_templates/" + property.template as prop_template %}
    {% if prop_template.transform_multipart %}
{{ prop_template.transform_multipart(property, property.python_name, destination) }}
    {% endif %}
{% endif %}
{% endmacro %}

{# The all the kwargs passed into an endpoint (and variants thereof)) #}
{% macro arguments(endpoint) %}
{# path parameters #}
{% for parameter in endpoint.path_parameters.values() %}
{{ parameter.to_string() }},
{% endfor %}
*,
{# Proper client based on whether or not the endpoint requires authentication #}
{% if endpoint.requires_security %}
client: {},
{% else %}
client: {},
{% endif %}
{# Form data if any #}
{% if endpoint.form_body %}
form_data: {{ endpoint.form_body.get_type_string() }},
{% endif %}
{# Multipart data if any #}
{% if endpoint.multipart_body %}
multipart_data: {{ endpoint.multipart_body.get_type_string() }},
{% endif %}
{# JSON body if any #}
{% if endpoint.json_body %}
json_body: {{ endpoint.json_body.get_type_string() }},
{% endif %}
{# query parameters #}
{% for parameter in endpoint.query_parameters.values() %}
{{ parameter.to_string() }},
{% endfor %}
{% for parameter in endpoint.header_parameters.values() %}
{{ parameter.to_string() }},
{% endfor %}
{# cookie parameters #}
{% for parameter in endpoint.cookie_parameters.values() %}
{{ parameter.to_string() }},
{% endfor %}
{% endmacro %}

{# Just lists all kwargs to endpoints as name=name for passing to other functions #}
{% macro kwargs(endpoint) %}
{% for parameter in endpoint.path_parameters.values() %}
{{ parameter.python_name }}={{ parameter.python_name }},
{% endfor %}
client=client,
{% if endpoint.form_body %}
form_data=form_data,
{% endif %}
{% if endpoint.multipart_body %}
multipart_data=multipart_data,
{% endif %}
{% if endpoint.json_body %}
json_body=json_body,
{% endif %}
{% for parameter in endpoint.query_parameters.values() %}
{{ parameter.python_name }}={{ parameter.python_name }},
{% endfor %}
{% for parameter in endpoint.header_parameters.values() %}
{{ parameter.python_name }}={{ parameter.python_name }},
{% endfor %}
{% for parameter in endpoint.cookie_parameters.values() %}
{{ parameter.python_name }}={{ parameter.python_name }},
{% endfor %}
{% endmacro %}

{% macro docstring_content(endpoint, return_string, is_detailed) %}
{% if endpoint.summary %}{{ endpoint.summary | wordwrap(100)}}

{% endif -%}
{%- if endpoint.description %} {{ endpoint.description | wordwrap(100) }}

{% endif %}
{% if not endpoint.summary and not endpoint.description %}
{# Leave extra space so that Args or Returns isn't at the top #}

{% endif %}
{% set all_parameters = endpoint.list_all_parameters() %}
{% if all_parameters %}
Args:
    {% for parameter in all_parameters %}
    {{ parameter.to_docstring() | wordwrap(90) | indent(8) }}
    {% endfor %}

{% endif %}
Raises:
    errors.UnexpectedStatus: If the server returns an undocumented status code and Client.raise_on_unexpected_status is True.
    httpx.TimeoutException: If the request takes longer than Client.timeout.

Returns:
{% if is_detailed %}
    Response[{{ return_string }}]
{% else %}
    {{ return_string }}
{% endif %}
{% endmacro %}

{% macro docstring(endpoint, return_string, is_detailed) %}
{{ safe_docstring(docstring_content(endpoint, return_string, is_detailed)) }}
{% endmacro %}

```

Contents of templates/endpoint_module.py.jinja:
```
from http import HTTPStatus
from typing import Any, Dict, List, Optional, Union, cast
import inspect
import requests
import json
import re
from ...types import Response, UNSET
from ... import errors
from sseclient import SSEClient

{% for relative in endpoint.relative_imports %}
{{ relative }}
{% endfor %}

{% from "endpoint_macros.py.jinja" import header_params, cookie_params, query_params, json_body, multipart_body,
    arguments, client, kwargs, parse_response, docstring %}
{% set return_string = endpoint.response_type() %}
{% set parsed_responses = (endpoint.responses | length > 0) and return_string != "Any" %}

def _get_kwargs(
    {{ arguments(endpoint) | indent(4) }}
) -> Dict[str, Any]:
    url = "{}{{ endpoint.path }}".format(
        client.base_url
        {%- for parameter in endpoint.path_parameters.values() -%}
        ,{{parameter.name}}={{parameter.python_name}}
        {%- endfor -%}
    )

    headers: Dict[str, str] = client.get_headers()
    cookies: Dict[str, Any] = client.get_cookies()
    {{ header_params(endpoint) | indent(4) }}

    {{ cookie_params(endpoint) | indent(4) }}

    {{ query_params(endpoint) | indent(4) }}

    {{ json_body(endpoint) | indent(4) }}

    {{ multipart_body(endpoint) | indent(4) }}
    {% if 'stream' in endpoint.query_parameters.keys()  %}
    if stream:
        headers['Accept'] = 'text/event-stream'
    {% endif %}

    return {
        "method": "{{ endpoint.method }}",
        "url": url,
        "headers": headers,
        "cookies": cookies,
        "timeout": client.get_timeout(),
        "allow_redirects": client.follow_redirects,
        {% if endpoint.form_body %}
        "data": form_data.to_dict(),
        {% elif endpoint.multipart_body %}
        "files": {{ "multipart_" + endpoint.multipart_body.python_name }},
        {% elif endpoint.json_body %}
        "json": {{ "json_" + endpoint.json_body.python_name }},
        {% endif %}
        {% if endpoint.query_parameters %}
        "params": params,
        {% endif %}
        {% if 'stream' in endpoint.query_parameters.keys()  %}
        "stream": stream
        {% endif %}
    }


def _parse_response(*, client: {}, response: None) -> Optional[{{ return_string }}]:
    {% for response in endpoint.responses %}
    if response.status_code == HTTPStatus.{{ response.status_code.name }}:
        {% if parsed_responses %}{% import "property_templates/" + response.prop.template as prop_template %}
        {% if prop_template.construct %}
        {{ prop_template.construct(response.prop, 'json.loads(response.text)') | indent(8)}}
        {% else %}
        {{ response.prop.python_name }} = cast({{ response.prop.get_type_string() }}, {{ response.source }})
        {% endif %}
        return {{ response.prop.python_name }}
        {% else %}
        return None
        {% endif %}
    {% endfor %}
    if client.raise_on_unexpected_status:
        raise errors.UnexpectedStatus(response.status_code, response.content)
    else:
        return None


def _build_response(*, client: {}, response: None, content: Optional[bytes] = None) -> Response[{{ return_string }}]:
    parse = _parse_response(client=client, response=response)
    return Response(
        status_code=HTTPStatus(response.status_code),
        content=response.content if content is None else content,
        headers=response.headers,
        parsed=parse,
    )

def sync_detailed(
    {{ arguments(endpoint) | indent(4) }}
):
    {{ docstring(endpoint, return_string, is_detailed=true) | indent(4) }}
    {% if 'stream' in endpoint.query_parameters.keys()  %}
    kwargs = _get_kwargs(
        {{ kwargs(endpoint) }}
    )

    response = requests.request(
        **kwargs,
    )

    if stream:
        return SSEClient(response)
    else:
        return _build_response(client=client, response=response)
    {% else %}

    kwargs = _get_kwargs(
        {{ kwargs(endpoint) }}
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)
    {% endif %}

{% if parsed_responses %}
def sync(
    {{ arguments(endpoint) | indent(4) }}
) -> Optional[{{ return_string }}]:
    {{ docstring(endpoint, return_string, is_detailed=false) | indent(4) }}

    return sync_detailed(
        {{ kwargs(endpoint) }}
    ).parsed
{% endif %}

async def asyncio_detailed(
    {{ arguments(endpoint) | indent(4) }}
) -> Response[{{ return_string }}]:
    {% if 'stream' in endpoint.query_parameters.keys()  %}
    kwargs = _get_kwargs(
        {{ kwargs(endpoint) }}
    )

    response = requests.request(
        **kwargs,
    )

    if stream:
        return SSEClient(response)
    else:
        return _build_response(client=client, response=response)
    {% else %}

    kwargs = _get_kwargs(
        {{ kwargs(endpoint) }}
    )

    response = requests.request(
        **kwargs,
    )

    return _build_response(client=client, response=response)
    {% endif %}

{% if parsed_responses %}
async def asyncio(
    {{ arguments(endpoint) | indent(4) }}
) -> Optional[{{ return_string }}]:
    {{ docstring(endpoint, return_string, is_detailed=false) | indent(4) }}

    return (await asyncio_detailed(
        {{ kwargs(endpoint) }}
    )).parsed
{% endif %}
```

Contents of templates/errors.py.jinja:
```
""" Contains shared errors types that can be raised from API functions """

class UnexpectedStatus(Exception):
    """ Raised by api functions when the response status an undocumented status and Client.raise_on_unexpected_status is True """

    def __init__(self, status_code: int, content: bytes):
        self.status_code = status_code
        self.content = content

        super().__init__(f"Unexpected status code: {status_code}")

__all__ = ["UnexpectedStatus"]

```

Contents of templates/helpers.jinja:
```
{% macro safe_docstring(content) %}
{# This macro returns the provided content as a docstring, set to a raw string if it contains a backslash #}
{% if '\\' in content -%}
r""" {{ content }} """
{%- else -%}
""" {{ content }} """
{%- endif -%}
{% endmacro %}
```

Contents of templates/int_enum.py.jinja:
```
from enum import IntEnum

class {{ enum.class_info.name }}(IntEnum):
    {% for key, value in enum.values.items() %}
    {{ key }} = {{ value }}
    {% endfor %}

    def __str__(self) -> str:
        return str(self.value)

```

Contents of templates/model.py.jinja:
```
from typing import Any, Dict, Type, TypeVar, Tuple, Optional, BinaryIO, TextIO, TYPE_CHECKING

{% if model.additional_properties %}
from typing import List

{% endif %}

import attr
{% if model.is_multipart_body %}
import json
{% endif %}

from ..types import UNSET, Unset

{% for relative in model.relative_imports %}
{{ relative }}
{% endfor %}

{% for lazy_import in model.lazy_imports %}
{% if loop.first %}
if TYPE_CHECKING:
{% endif %}
  {{ lazy_import }}
{% endfor %}


{% if model.additional_properties %}
{% set additional_property_type = 'Any' if model.additional_properties == True else model.additional_properties.get_type_string(quoted=not model.additional_properties.is_base_type) %}
{% endif %}
{% set class_name = model.class_info.name %}
{% set module_name = model.class_info.module_name %}

{% from "helpers.jinja" import safe_docstring %}

T = TypeVar("T", bound="{{ class_name }}")

{% macro class_docstring_content(model) %}
    {% if model.title %}{{ model.title | wordwrap(116) }}

    {% endif -%}
    {%- if model.description %}{{ model.description | wordwrap(116) }}

    {% endif %}
    {% if not model.title and not model.description %}
    {# Leave extra space so that a section doesn't start on the first line #}

    {% endif %}
    {% if model.example %}
    Example:
        {{ model.example | string | wordwrap(112) | indent(12) }}

    {% endif %}
    {% if model.required_properties or model.optional_properties %}
    Attributes:
    {% for property in model.required_properties + model.optional_properties %}
        {{ property.to_docstring() | wordwrap(112) | indent(12) }}
    {% endfor %}{% endif %}
{% endmacro %}

@attr.s(auto_attribs=True)
class {{ class_name }}:
    {{ safe_docstring(class_docstring_content(model)) | indent(4) }}

    {% for property in model.required_properties + model.optional_properties %}
    {% if property.default is none and property.required %}
    {% if property.__class__.__name__ == 'EnumProperty' %}
    {{property.name}}: Union[Unset, str] = Unset
    {% else %}
    {{ property.to_string() }}
    {% endif %}
    {% endif %}
    {% endfor %}

    {% for property in model.required_properties + model.optional_properties %}
    {% if property.default is not none or not property.required %}
    {% if property.__class__.__name__ == 'EnumProperty' %}
    {{property.name}}: Union[Unset, str] = Unset
    {% else %}
    {{ property.to_string() }}
    {% endif %}
    {% endif %}
    {% endfor %}
    {% if model.additional_properties %}
    additional_properties: Dict[str, {{ additional_property_type }}] = attr.ib(init=False, factory=dict)
    {% endif %}

{% macro _to_dict(multipart=False) %}
{% for property in model.required_properties + model.optional_properties %}
{% import "property_templates/" + property.template as prop_template %}
{% if prop_template.transform %}
{{ prop_template.transform(property, "self." + property.python_name, property.python_name, multipart=multipart) }}
{% elif multipart %}
{% if property.__class__.__name__ == BooleanProperty %}
{{ property.python_name }} = self.{{ property.python_name }} if isinstance(self.{{ property.python_name }}, Unset) else (None, str(self.{{ property.python_name }}).lower().encode(), "text/plain")
{% else %}
{{ property.python_name }} = self.{{ property.python_name }} if isinstance(self.{{ property.python_name }}, Unset) else (None, str(self.{{ property.python_name }}).encode(), "text/plain")
{% endif %}
{% else %}
{{ property.python_name }} = self.{{ property.python_name }}
{% endif %}
{% endfor %}

field_dict: Dict[str, Any] = {}
{% if model.additional_properties %}
{% if model.additional_properties.template %}{# Can be a bool instead of an object #}
    {% import "property_templates/" + model.additional_properties.template as prop_template %}
{% else %}
    {% set prop_template = None %}
{% endif %}
{% if prop_template and prop_template.transform %}
for prop_name, prop in self.additional_properties.items():
    {{ prop_template.transform(model.additional_properties, "prop", "field_dict[prop_name]", multipart=multipart, declare_type=false) | indent(4) }}
{% elif multipart %}
field_dict.update({
    key: (None, str(value).encode(), "text/plain")
    for key, value in self.additional_properties.items()
})
{% else %}
field_dict.update(self.additional_properties)
{% endif %}
{% endif %}
field_dict.update({
    {% for property in model.required_properties + model.optional_properties %}
    {% if property.required %}
    "{{ property.name }}": {{ property.python_name }},
    {% endif %}
    {% endfor %}
})
{% for property in model.optional_properties %}
{% if not property.required %}
if {{ property.python_name }} is not UNSET:
    {% if property.__class__.__name__ == 'ListProperty' %}
    for index, field_value in enumerate({{property.name}}):
        field_dict[f"{{property.name}}[]"] = field_value
    {% else %}
    field_dict["{{ property.name }}"] = {{ property.python_name }}
    {% endif %}
{% endif %}
{% endfor %}

return field_dict
{% endmacro %}

    def to_dict(self) -> Dict[str, Any]:
    {% for lazy_import in model.lazy_imports %}
        {{ lazy_import }}
    {% endfor %}
        {{ _to_dict() | indent(8) }}

{% if model.is_multipart_body %}
    def to_multipart(self) -> Dict[str, Any]:
        {{ _to_dict(multipart=True) | indent(8) }}
{% endif %}

    @classmethod
    def from_dict(cls: Type[T], src_dict: Dict[str, Any]) -> T:
    {% for lazy_import in model.lazy_imports %}
        {{ lazy_import }}
    {% endfor %}
{% for property in model.required_properties + model.optional_properties %}
    {% if property.required %}
        {% set property_source = 'src_dict.get("' + property.name + '")' %}
    {% else %}
        {% set property_source = 'src_dict.get("' + property.name + '")' %}
    {% endif %}
    {% import "property_templates/" + property.template as prop_template %}
    {% if prop_template.construct %}
        {{ prop_template.construct(property, property_source) | indent(8) }}
    {% else %}
        {{ property.python_name }} = {{ property_source }}
    {% endif %}

{% endfor %}
        {{ module_name }} = cls(
{% for property in model.required_properties + model.optional_properties %}
            {{ property.python_name }}={{ property.python_name }},
{% endfor %}
        )

{% if model.additional_properties %}
    {% if model.additional_properties.template %}{# Can be a bool instead of an object #}
        {% import "property_templates/" + model.additional_properties.template as prop_template %}

{% if model.additional_properties.lazy_imports %}
    {% for lazy_import in model.additional_properties.lazy_imports %}
        {{ lazy_import }}
    {% endfor %}
{% endif %}
    {% else %}
        {% set prop_template = None %}
    {% endif %}
    {% if prop_template and prop_template.construct %}
        additional_properties = {}
        for prop_name, prop_dict in src_dict.items():
            {{ prop_template.construct(model.additional_properties, "prop_dict") | indent(12) }}
            additional_properties[prop_name] = {{ model.additional_properties.python_name }}

        {{ module_name }}.additional_properties = additional_properties
    {% else %}
        {{ module_name }}.additional_properties = src_dict
    {% endif %}
{% endif %}
        return {{ module_name }}

    {% if model.additional_properties %}
    @property
    def additional_keys(self) -> List[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> {{ additional_property_type }}:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: {{ additional_property_type }}) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties
    {% endif %}

```

Contents of templates/models_init.py.jinja:
```
""" Contains all the data models used in inputs/outputs """

{% for import in imports | sort %}
{{ import }}
{% endfor %}

{% if imports %}
__all__ = (
    {% for all in alls | sort %}
    "{{ all }}",
    {% endfor %}
)
{% endif %}

```

Contents of templates/package_init.py.jinja:
```
{% from "helpers.jinja" import safe_docstring %}

{{ safe_docstring(package_description) }}
from .client import CustomGPT

__all__ = (
    "CustomGPT",
)

```

Contents of templates/pyproject.toml.jinja:
```
{% if use_poetry %}
[tool.poetry]
name = "{{ project_name }}"
version = "{{ package_version }}"
description = "{{ package_description }}"

authors = []

readme = "README.md"
packages = [
    {include = "{{ package_name }}"},
]
include = ["CHANGELOG.md", "{{ package_name }}/py.typed"]

[tool.poetry.dependencies]
python = "^3.8"
httpx = ">=0.15.4,<0.25.0"
attrs = ">=21.3.0"
python-dateutil = "^2.8.0"

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"

{% endif %}
{% include "pyproject_no_poetry.toml.jinja" %}

```

Contents of templates/pyproject_no_poetry.toml.jinja:
```
[tool.black]
line-length = 120
target_version = ['py38', 'py39', 'py310', 'py311']
exclude = '''
(
  /(
    | \.git
    | \.venv
    | \.mypy_cache
  )/
)
'''

[tool.isort]
line_length = 120
profile = "black"

```

Contents of templates/setup.py.jinja:
```
import pathlib

from setuptools import find_packages, setup

here = pathlib.Path(__file__).parent.resolve()
long_description = (here / "README.md").read_text(encoding="utf-8")

setup(
    name="{{ project_name }}",
    version="{{ package_version }}",
    description="{{ package_description }}",
    long_description=long_description,
    long_description_content_type="text/markdown",
    packages=find_packages(),
    python_requires=">=3.8, <4",
    install_requires=["httpx >= 0.15.0, < 0.25.0", "attrs >= 21.3.0", "python-dateutil >= 2.8.0, < 3"],
    package_data={"{{ package_name }}": ["py.typed"]},
)

```

Contents of templates/str_enum.py.jinja:
```
from enum import Enum

class {{ enum.class_info.name }}(str, Enum):
    {% for key, value in enum.values|dictsort(true) %}
    {{ key }} = "{{ value }}"
    {% endfor %}

    def __str__(self) -> str:
        return str(self.value)

```

Contents of templates/types.py.jinja:
```
""" Contains some shared types for properties """
from http import HTTPStatus
from typing import Any, BinaryIO, Generic, MutableMapping, Optional, Tuple, TypeVar, Literal

import attr


class Unset:
    def __bool__(self) -> Literal[False]:
        return False


UNSET: Unset = Unset()

{# Used as `FileProperty._json_type_string` #}
FileJsonType = Tuple[Optional[str], BinaryIO, Optional[str]]


@attr.s(auto_attribs=True)
class File:
    """ Contains information for file uploads """

    payload: BinaryIO
    file_name: Optional[str] = None
    mime_type: Optional[str] = None

    def to_tuple(self) -> FileJsonType:
        """ Return a tuple representation that httpx will accept for multipart/form-data """
        return self.file_name, self.payload, self.mime_type


T = TypeVar("T")


@attr.s(auto_attribs=True)
class Response(Generic[T]):
    """ A response from an endpoint """

    status_code: HTTPStatus
    content: bytes
    headers: MutableMapping[str, str]
    parsed: Optional[T]


__all__ = ["File", "Response", "FileJsonType"]

```

Contents of templates/property_templates/any_property.py.jinja:
```

```

Contents of templates/property_templates/boolean_property.py.jinja:
```
{% macro transform_header(property, source, destination) %}
{{ destination }} = "true" if {{ source }} else "false"
{% endmacro %}

```

Contents of templates/property_templates/date_property.py.jinja:
```
{% macro construct_function(property, source) %}
isoparse({{ source }}).date()
{% endmacro %}

{% from "property_templates/property_macros.py.jinja" import construct_template %}

{% macro construct(property, source, initial_value=None) %}
{{ construct_template(construct_function, property, source, initial_value=initial_value) }}
{% endmacro %}

{% macro check_type_for_construct(property, source) %}isinstance({{ source }}, str){% endmacro %}

{% macro transform(property, source, destination, declare_type=True, multipart=False) %}
{% set transformed = source + ".isoformat()" %}
{% if multipart %}{# Multipart data must be bytes, not str #}
{% set transformed = transformed + ".encode()" %}
{% endif %}
{% if property.required %}
{{ destination }} = {{ transformed }} {% if property.nullable %}if {{ source }} else None {%endif%}
{% else %}
{% if declare_type %}
{% set type_annotation = property.get_type_string(json=True) %}
{% if multipart %}{% set type_annotation = type_annotation | replace("str", "bytes") %}{% endif %}
{{ destination }}: {{ type_annotation }} = UNSET
{% else %}
{{ destination }} = UNSET
{% endif %}
if not isinstance({{ source }}, Unset):
{% if property.nullable %}
    {{ destination }} = {{ transformed }} if {{ source }} else None
{% else %}
    {{ destination }} = {{ transformed }}
{% endif %}
{% endif %}
{% endmacro %}

```

Contents of templates/property_templates/datetime_property.py.jinja:
```
{% macro construct_function(property, source) %}
isoparse({{ source }})
{% endmacro %}

{% from "property_templates/property_macros.py.jinja" import construct_template %}

{% macro construct(property, source, initial_value=None) %}
{{ construct_template(construct_function, property, source, initial_value=initial_value) }}
{% endmacro %}

{% macro check_type_for_construct(property, source) %}isinstance({{ source }}, str){% endmacro %}

{% macro transform(property, source, destination, declare_type=True, multipart=False) %}
{% set transformed = source + ".isoformat()" %}
{% if multipart %}{# Multipart data must be bytes, not str #}
{% set transformed = transformed + ".encode()" %}
{% endif %}
{% if property.required %}
{% if property.nullable %}
{{ destination }} = {{ transformed }} if {{ source }} else None
{% else %}
{{ destination }} = {{ transformed }}
{% endif %}
{% else %}
{% if declare_type %}
{% set type_annotation = property.get_type_string(json=True) %}
{% if multipart %}{% set type_annotation = type_annotation | replace("str", "bytes") %}{% endif %}
{{ destination }}: {{ type_annotation }} = UNSET
{% else %}
{{ destination }} = UNSET
{% endif %}
if not isinstance({{ source }}, Unset):
{% if property.nullable %}
    {{ destination }} = {{ transformed }} if {{ source }} else None
{% else %}
    {{ destination }} = {{ transformed }}
{% endif %}
{% endif %}
{% endmacro %}

```

Contents of templates/property_templates/enum_property.py.jinja:
```
{% macro construct_function(property, source) %}
{{ property.class_info.name }}({{ source }})
{% endmacro %}

{% from "property_templates/property_macros.py.jinja" import construct_template %}

{% macro construct(property, source, initial_value=None) %}
{{ construct_template(construct_function, property, source, initial_value=initial_value) }}
{% endmacro %}

{% macro check_type_for_construct(property, source) %}isinstance({{ source }}, {{ property.value_type.__name__ }}){% endmacro %}

{% macro transform(property, source, destination, declare_type=True, multipart=False) %}
{% set transformed = source + ".value" %}
{% set type_string = property.get_type_string(json=True) %}
{% if multipart %}
    {% set transformed = "(None, str(" + transformed + ").encode(), \"text/plain\")" %}
    {% set type_string = "Union[Unset, Tuple[None, bytes, str]]" %}
{% endif %}
{% if property.required %}
{% if property.nullable %}
{{ destination }} = {{ transformed }} if {{ source }} else None
{% else %}
{{ destination }} = {{ transformed }}
{% endif %}
{% else %}
{{ destination }}{% if declare_type %}: {{ type_string }}{% endif %} = UNSET
if not isinstance({{ source }}, Unset):
{% if property.nullable %}
    {{ destination }} = {{ transformed }} if {{ source }} else None
{% else %}
    {{ destination }} = {{ transformed }}
{% endif %}
{% endif %}
{% endmacro %}

{% macro transform_header(property, source, destination) %}
{{ destination }} = str({{ source }})
{% endmacro %}

```

Contents of templates/property_templates/file_property.py.jinja:
```
{% macro construct_function(property, source) %}
File(
     payload = BytesIO({{ source }})
)
{% endmacro %}

{% from "property_templates/property_macros.py.jinja" import construct_template %}

{% macro construct(property, source, initial_value=None) %}
{{ construct_template(construct_function, property, source, initial_value=initial_value) }}
{% endmacro %}

{% macro check_type_for_construct(property, source) %}isinstance({{ source }}, bytes){% endmacro %}

{% macro transform(property, source, destination, declare_type=True, multipart=False) %}
{% if property.required %}
{% if property.nullable %}
{{ destination }} = {{ source }}.to_tuple() if {{ source }} else None
{% else %}
{{ destination }} = {{ source }}.to_tuple()
{% endif %}
{% else %}
{{ destination }}{% if declare_type %}: {{ property.get_type_string(json=True) }}{% endif %} = UNSET
if not isinstance({{ source }}, Unset):
{% if property.nullable %}
    {{ destination }} = {{ source }}.to_tuple() if {{ source }} else None
{% else %}
    {{ destination }} = {{ source }}.to_tuple()
{% endif %}
{% endif %}
{% endmacro %}

```

Contents of templates/property_templates/float_property.py.jinja:
```
{% macro transform_header(property, source, destination) %}
{{ destination }} = str({{ source }})
{% endmacro %}

```

Contents of templates/property_templates/helpers.jinja:
```
{% macro guarded_statement(property, source, statement) %}
{# If the property can be UNSET or None, this macro returns the provided statement guarded by an if which will check
 for those invalid values. Otherwise, it returns the statement unmodified. #}
{% if property.required and not property.nullable %}
{{ statement }}
{% else %}
    {% if property.nullable and not property.required %}
if not isinstance({{ source }}, Unset) and {{ source }} is not None:
    {{ statement }}
    {% elif property.nullable %}
if {{ source }} is not None:
    {{ statement }}
    {% else %}
if not isinstance({{ source }}, Unset):
    {{ statement }}
    {% endif %}
{% endif %}
{% endmacro %}

```

Contents of templates/property_templates/int_property.py.jinja:
```
{% macro transform_header(property, source, destination) %}
{{ destination }} = str({{ source }})
{% endmacro %}

```

Contents of templates/property_templates/list_property.py.jinja:
```
{% macro construct(property, source, initial_value="[]") %}
{% set inner_property = property.inner_property %}
{% import "property_templates/" + inner_property.template as inner_template %}
{% if inner_template.construct %}
{% set inner_source = inner_property.python_name + "_data" %}
{{ property.python_name }} = {{ initial_value }}
_{{ property.python_name }} = {{ source }}
{% if property.required and not property.nullable %}
for {{ inner_source }} in (_{{ property.python_name }}):
{% else %}
for {{ inner_source }} in (_{{ property.python_name }} or []):
{% endif %}
    {{ inner_template.construct(inner_property, inner_source) | indent(4) }}
    {{ property.python_name }}.append({{ inner_property.python_name }})
{% else %}
{{ property.python_name }} = cast({{ property.get_type_string(no_optional=True) }}, {{ source }})
{% endif %}
{% endmacro %}

{% macro _transform(property, source, destination, multipart, transform_method) %}
{% set inner_property = property.inner_property %}
{% if multipart %}
{% set multipart_destination = destination %}
{% set destination = "_temp_" + destination %}
{% endif %}
{% import "property_templates/" + inner_property.template as inner_template %}
{% if inner_template.transform %}
{% set inner_source = inner_property.python_name + "_data" %}
{{ destination }} = []
for {{ inner_source }} in {{ source }}:
    {{ inner_template.transform(inner_property, inner_source, inner_property.python_name, transform_method) | indent(4) }}
    {{ destination }}.append({{ inner_property.python_name }})
{% else %}
{{ destination }} = {{ source }}
{% endif %}
{% if multipart %}
{{ multipart_destination }} = []
for index, value in enumerate(self.{{multipart_destination}}):
    field_value = (None, str(value).encode(), "text/plain")
    {{multipart_destination}}.append(field_value)
{% endif %}
{% endmacro %}

{% macro check_type_for_construct(property, source) %}isinstance({{ source }}, list){% endmacro %}

{% macro transform(property, source, destination, declare_type=True, multipart=False, transform_method="to_dict") %}
{% set inner_property = property.inner_property %}
{% if multipart %}
    {% set type_string = "Union[Unset, Tuple[None, bytes, str]]" %}
{% else %}
    {% set type_string = property.get_type_string(json=True) %}
{% endif %}
{% if property.required %}
{% if property.nullable %}
if {{ source }} is None:
    {{ destination }} = None
else:
    {{ _transform(property, source, destination, multipart, transform_method) | indent(4) }}
{% else %}
{{ _transform(property, source, destination, multipart, transform_method) }}
{% endif %}
{% else %}
{{ destination }}{% if declare_type %}: {{ type_string }}{% endif %} = UNSET
if not isinstance({{ source }}, Unset):
{% if property.nullable %}
    if {{ source }} is None:
        {{ destination }} = None
    else:
        {{ _transform(property, source, destination, multipart, transform_method) | indent(8)}}
{% else %}
    {{ _transform(property, source, destination, multipart, transform_method) | indent(4)}}
{% endif %}
{% endif %}


{% endmacro %}

{% macro transform_multipart(property, source, destination) %}
{{ transform(property, source, destination, transform_method="to_multipart") }}
{% endmacro %}

```

Contents of templates/property_templates/model_property.py.jinja:
```
{% macro construct_function(property, source) %}
{{ property.class_info.name }}.from_dict({{ source }})
{% endmacro %}

{% from "property_templates/property_macros.py.jinja" import construct_template %}

{% macro construct(property, source, initial_value=None) %}
{{ construct_template(construct_function, property, source, initial_value=initial_value) }}
{% endmacro %}

{% macro check_type_for_construct(property, source) %}isinstance({{ source }}, dict){% endmacro %}

{% macro transform(property, source, destination, declare_type=True, multipart=False, transform_method="to_dict") %}
{% set transformed = source + "." + transform_method + "()" %}
{% if multipart %}
    {% set transformed = "(None, json.dumps(" + transformed + ").encode(), 'application/json')" %}
    {% set type_string = "Union[Unset, Tuple[None, bytes, str]]" %}
{% else %}
    {% set type_string = property.get_type_string(json=True) %}
{% endif %}
{% if property.required %}
{% if property.nullable %}
{{ destination }} = {{ transformed }} if {{ source }} else None
{% else %}
{{ destination }} = {{ transformed }}
{% endif %}
{% else %}
{{ destination }}{% if declare_type %}: {{ type_string }}{% endif %} = UNSET
if not isinstance({{ source }}, Unset):
{% if property.nullable %}
    {{ destination }} = {{ transformed }} if {{ source }} else None
{% else %}
    {{ destination }} = {{ transformed }}
{% endif %}
{% endif %}
{% endmacro %}

{% macro transform_multipart(property, source, destination) %}
{{ transform(property, source, destination, transform_method="to_multipart") }}
{% endmacro %}

```

Contents of templates/property_templates/property_macros.py.jinja:
```
{% macro construct_template(construct_function, property, source, initial_value=None) %}
{% if property.required and not property.nullable %}
{{ property.python_name }} = {{ construct_function(property, source) }}
{% else %}{# Must be nullable OR non-required #}
{% if property.__class__.__name__ == 'EnumProperty' %}
{{property.python_name}} = {{source}}
{% else %}
_{{ property.python_name }} = {{ source }}
{{ property.python_name }}: {{ property.get_type_string() }}
{% if property.nullable %}
if _{{ property.python_name }} is None:
    {{ property.python_name }} = {% if initial_value != None %}{{ initial_value }}{% else %}None{% endif %}

{% endif %}
{% if not property.required %}
{% if property.nullable %}elif{% else %}if{% endif %} isinstance(_{{ property.python_name }},  Unset):
    {{ property.python_name }} = {% if initial_value != None %}{{ initial_value }}{% else %}UNSET{% endif %}

{% endif %}
else:
    {{ property.python_name }} = {{ construct_function(property, "_" + property.python_name) }}
{% endif %}
{% endif %}
{% endmacro %}

```

Contents of templates/property_templates/union_property.py.jinja:
```
{% macro construct(property, source, initial_value=None) %}
def _parse_{{ property.python_name }}(data: object) -> {{ property.get_type_string() }}:
    {% if "None" in property.get_type_strings_in_union(json=True) %}
    if data is None:
        return data
    {% endif %}
    {% if "Unset" in property.get_type_strings_in_union(json=True) %}
    if isinstance(data, Unset):
        return data
    {% endif %}
    {% set ns = namespace(contains_unmodified_properties = false) %}
    {% for inner_property in property.inner_properties %}
    {% import "property_templates/" + inner_property.template as inner_template %}
        {% if not inner_template.construct %}
            {% set ns.contains_unmodified_properties = true %}
            {% continue %}
        {% endif %}
    {% if inner_template.check_type_for_construct and (not loop.last or ns.contains_unmodified_properties) %}
    try:
        if not {{ inner_template.check_type_for_construct(inner_property, "data") }}:
            raise TypeError()
        {{ inner_template.construct(inner_property, "data", initial_value="UNSET") | indent(8) }}
        return {{ inner_property.python_name }}
    except: # noqa: E722
        pass
    {% else  %}{# Don't do try/except for the last one nor any properties with no type checking #}
    {% if inner_template.check_type_for_construct %}
    if not {{ inner_template.check_type_for_construct(inner_property, "data") }}:
        raise TypeError()
    {% endif %}
    {{ inner_template.construct(inner_property, "data", initial_value="UNSET") | indent(4) }}
    return {{ inner_property.python_name }}
    {% endif %}
    {% endfor %}
    {% if ns.contains_unmodified_properties %}
    return cast({{ property.get_type_string() }}, data)
    {% endif %}

{{ property.python_name }} = _parse_{{ property.python_name }}({{ source }})
{% endmacro %}

{% macro transform(property, source, destination, declare_type=True, multipart=False) %}
{% set ns = namespace(contains_properties_without_transform = false, contains_modified_properties = not property.required, has_if = false) %}
{% if declare_type %}{{ destination }}: {{ property.get_type_string(json=True) }}{% endif %}

{% if not property.required %}
if isinstance({{ source }}, Unset):
    {{ destination }} = UNSET
    {% set ns.has_if = true %}
{% endif %}
{% if property.nullable %}
    {% if ns.has_if %}
elif {{ source }} is None:
    {% else %}
if {{ source }} is None:
        {% set ns.has_if = true %}
    {% endif %}
    {{ destination }} = None
{% endif %}

{% for inner_property in property.inner_properties %}
    {% import "property_templates/" + inner_property.template as inner_template %}
    {% if not inner_template.transform %}
        {% set ns.contains_properties_without_transform = true %}
        {% continue %}
    {% else %}
        {% set ns.contains_modified_properties = true %}
    {% endif %}
    {% if not ns.has_if %}
if isinstance({{ source }}, {{ inner_property.get_instance_type_string() }}):
        {% set ns.has_if = true %}
    {% elif not loop.last or ns.contains_properties_without_transform %}
elif isinstance({{ source }}, {{ inner_property.get_instance_type_string() }}):
    {% else %}
else:
    {% endif %}
    {{ inner_template.transform(inner_property, source, destination, declare_type=False, multipart=multipart) | indent(4) }}
{% endfor %}
{% if ns.contains_properties_without_transform and ns.contains_modified_properties %}
else:
    {{ destination }} = {{ source }}
{% elif ns.contains_properties_without_transform %}
{{ destination }} = {{ source }}
{% endif %}

{% endmacro %}

```

