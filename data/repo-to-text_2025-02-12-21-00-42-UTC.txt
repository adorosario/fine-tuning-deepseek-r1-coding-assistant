Directory: customgpt-cli

Directory Structure:
```
.
.
├── ./DOCKER.md
├── ./Dockerfile
├── ./README.md
├── ./__init__.py
├── ./customgpt_cli
│   ├── ./customgpt_cli/__init__.py
│   ├── ./customgpt_cli/__pycache__
│   │   ├── ./customgpt_cli/__pycache__/__init__.cpython-39.pyc
│   │   └── ./customgpt_cli/__pycache__/cli.cpython-39.pyc
│   ├── ./customgpt_cli/cli.py
│   └── ./customgpt_cli/openapi.json
├── ./customgpt_cli.egg-info
│   ├── ./customgpt_cli.egg-info/PKG-INFO
│   ├── ./customgpt_cli.egg-info/SOURCES.txt
│   ├── ./customgpt_cli.egg-info/dependency_links.txt
│   ├── ./customgpt_cli.egg-info/entry_points.txt
│   ├── ./customgpt_cli.egg-info/requires.txt
│   └── ./customgpt_cli.egg-info/top_level.txt
├── ./docker-compose.yml
├── ./projects.txt
├── ./projects.txt~
├── ./pyproject.toml
├── ./requirements.txt
├── ./setup.py
└── ./tests
    ├── ./tests/files
    │   ├── ./tests/files/test.pdf
    │   └── ./tests/files/test.png
    ├── ./tests/test_citations.sh
    ├── ./tests/test_conversations.sh
    ├── ./tests/test_limits.sh
    ├── ./tests/test_page_metadata.sh
    ├── ./tests/test_pages.sh
    ├── ./tests/test_plugins.sh
    ├── ./tests/test_project_settings.sh
    ├── ./tests/test_projects.sh
    ├── ./tests/test_reports.sh
    ├── ./tests/test_sources.sh
    └── ./tests/test_user.sh
```

Contents of DOCKER.md:
```
# Docker Support for CustomGPT CLI Development

This document explains how to build and run the CustomGPT CLI tool using Docker in a development environment.

## Development Setup

The development setup mounts the current directory into the container, allowing you to modify code and test changes without rebuilding the image.

### Authentication

You can provide your API key in two ways:

1. Environment Variable (recommended):
   ```bash
   # On host machine
   export CUSTOMGPT_API_KEY=your_api_key
   docker run -it --rm \
     -v $(pwd):/app \
     -e CUSTOMGPT_API_KEY=$CUSTOMGPT_API_KEY \
     customgpt-cli-dev

   # Inside container
   customgpt-cli list-projects  # uses CUSTOMGPT_API_KEY from environment
   ```

2. Command Line Argument:
   ```bash
   # Inside container
   customgpt-cli --api-key YOUR_API_KEY list-projects
   ```

Note: Command line argument takes precedence over environment variable if both are set.

### Building the Development Image

Build the image from the project root:
```bash
docker build -t customgpt-cli-dev .
```

### Running in Development Mode

Start an interactive development session:
```bash
docker run -it --rm \
  -v $(pwd):/app \
  customgpt-cli-dev
```

This command:
- Mounts the current directory to `/app` (source code)
- Starts an interactive bash session

## Common Development Workflows

### 1. Modifying and Testing Code

When you modify the code:
```bash
# Inside the container
pip install -e /app  # Reinstall the package after changes
customgpt-cli --help  # Test your changes
```

### 2. Running CLI Commands

Set your API key and run commands:
```bash
# Inside the container
export CUSTOMGPT_API_KEY=your_api_key

# Test your implementation
customgpt-cli list-projects
customgpt-cli create-project --name "Test Project" --file test.pdf
```

### 3. Quick Command Execution

Run a single command without starting an interactive session:
```bash
docker run --rm \
  -v $(pwd):/app \
  customgpt-cli-dev customgpt-cli --api-key YOUR_API_KEY list-projects
```

## Using Docker Compose for Development

Create a `docker-compose.yml` file:

```yaml
version: '3'
services:
  cli:
    build: .
    volumes:
      - .:/app
    environment:
      - CUSTOMGPT_API_KEY=${CUSTOMGPT_API_KEY}
```

Start an interactive development session:
```bash
docker-compose run --rm cli
```

Run a specific command:
```bash
docker-compose run --rm cli customgpt-cli list-projects
```

## Development Tips

### Code Changes

1. **Live Code Updates**:
   - The source code is mounted at `/app`
   - Changes to the code are immediately available in the container
   - Remember to reinstall the package after changes: `pip install -e /app`

2. **Working with Files**:
   - Project directory is mounted at `/app` 

### Testing

1. **Running Tests**:
```bash
# Inside the container
cd /app
python -m pytest tests/
```

2. **Debugging**:
```bash
# Inside the container
python -m pdb /app/customgpt_cli/cli.py
```

### Environment Variables

Set up your development environment:
```bash
# On host terminal
export CUSTOMGPT_API_KEY=your_api_key

# Start container with environment variables
docker run -it --rm \
  -v $(pwd):/app \
  -e CUSTOMGPT_API_KEY \
  customgpt-cli-dev

# Inside container, API key is already available
customgpt-cli list-projects

# Or override with command line argument
customgpt-cli --api-key different_key list-projects
```

### File Permissions

If you encounter permission issues:
```bash
# In host terminal
sudo chown -R $(id -u):$(id -g) .
```

## Development Best Practices

1. **Version Control**:
   - The `.dockerignore` file excludes development artifacts
   - Keep the Docker image clean of development files
   - Don't commit API keys or sensitive data

2. **Testing Changes**:
   - Test changes in the container before committing
   - Verify functionality with different Python versions if needed
   - Check file permissions for generated files

3. **Performance**:
   - The development image includes all source files
   - Use volume mounts for development
   - Consider building a slimmer production image if needed

## Troubleshooting

1. **Module Not Found**:
```bash
# Inside container
pip install -e /app  # Reinstall the package
```

2. **File Permission Issues**:
```bash
# Inside container
ls -la /app  # Check file ownership
```

3. **Docker Volume Issues**:
```bash
# On host
docker volume ls  # List volumes
docker volume prune  # Clean up unused volumes
```

## Production Deployment

For production deployment, consider:
1. Creating a separate production Dockerfile
2. Removing development dependencies
3. Setting up proper user permissions
4. Configuring appropriate security measures

```

Contents of Dockerfile:
```
FROM python:3.9-slim

# Set working directory
WORKDIR /app

# Install system dependencies including jq for JSON processing
RUN apt-get update && apt-get install -y \
    jq \
    python3-pip \
    && rm -rf /var/lib/apt/lists/*

COPY . .
RUN pip install --no-cache-dir -r requirements.txt

RUN pip install -e .

# Note: The actual code will be mounted at runtime
CMD ["/bin/bash"]
```

Contents of __init__.py:
```
"""CustomGPT CLI - Command line interface for CustomGPT SDK."""

__version__ = "0.1.0"

```

Contents of docker-compose.yml:
```
version: '3'
services:
  cli:
    build: .
    volumes:
      - .:/app
      - .:/data
    environment:
      - CUSTOMGPT_API_KEY=${CUSTOMGPT_API_KEY}

```

Contents of requirements.txt:
```
customgpt-client>=1.1.6
tabulate>=0.9.0
```

Contents of setup.py:
```
from setuptools import setup, find_packages

setup(
    name="customgpt-cli",
    version="0.1.0",
    packages=find_packages(),
    install_requires=[
        "customgpt-client>=1.1.6",
        "tabulate>=0.9.0",
    ],
    entry_points={
        "console_scripts": [
            "customgpt-cli=customgpt_cli.cli:main",
        ],
    },
)

```

Contents of projects.txt~:
```
2024-12-12 15:00:34,317 - customgpt_cli.cli - WARNING - Error processing projects: nothing to repeat at position 0
Error processing projects - displaying unfiltered results:
52093
51998
51892
51885
50730
50228
50217
50188
50175
49703
49298
49286
49238
49196
49189
49183
49171
49152
49151
49146
49144
49143
49142
49115
48810
48808
48807
48798
48793
48792
48788
48782
48729
48726
48713
48711
48709
48706
48703
48701
48699
48698
48697
48694
48693
48692
48691
48690
48688
48687
48686
48670
10133

```

Contents of projects.txt:
```
No projects found or unable to retrieve projects

```

Contents of README.md:
```
# CustomGPT CLI

[![PyPI version](https://badge.fury.io/py/customgpt-cli.svg)](https://badge.fury.io/py/customgpt-cli)
[![Python Support](https://img.shields.io/pypi/pyversions/customgpt-cli.svg)](https://pypi.org/project/customgpt-cli/)
[![Documentation Status](https://readthedocs.org/projects/customgpt-cli/badge/?version=latest)](https://customgpt-cli.readthedocs.io/en/latest/?badge=latest)
[![Coverage Status](https://codecov.io/gh/yourusername/customgpt-cli/branch/main/graph/badge.svg)](https://codecov.io/gh/yourusername/customgpt-cli)
[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Docker Pulls](https://img.shields.io/docker/pulls/yourusername/customgpt-cli.svg)](https://hub.docker.com/r/yourusername/customgpt-cli)

🚀 A powerful command-line interface for CustomGPT SDK, enabling efficient project management and automation.

## ✨ Features

- 🛠️ Full CustomGPT SDK integration
- 🔐 Secure API key management
- 📊 Project management and monitoring
- 🤖 Conversation handling
- 📄 Page management
- 🐳 Docker support
- 🔄 Bulk operations
- 📊 Advanced filtering

## Installation

```bash
pip install customgpt-cli
```

## Authentication

The CLI requires your CustomGPT API key. You can provide it in two ways:

1. Environment Variable (recommended):
```bash
export CUSTOMGPT_API_KEY=your_api_key
customgpt-cli list-projects
```

2. Command Line Argument:
```bash
customgpt-cli --api-key YOUR_API_KEY list-projects
```

Note: Command line argument takes precedence over environment variable if both are set.

## Usage

### Project Management

Create a project:
```bash
# Using environment variable
export CUSTOMGPT_API_KEY=your_api_key

# With a sitemap, return project ID
customgpt-cli create-project --name "My Test Project With Sitemap" --sitemap "https://adorosario.github.io/small-sitemap.xml" --format id-only

# With a file, returning JSON output. 
customgpt-cli create-project --name "My Test Project With File" --file /path/to/file.pdf --format json
```

List projects with filtering:
```bash
# Basic listing
customgpt-cli list-projects

# Filter by name pattern (supports regex)
customgpt-cli list-projects --name-filter "test.*project"

# Filter by activity
customgpt-cli list-projects --inactive-days 30

# Filter by query count
customgpt-cli list-projects --min-queries 100 --max-queries 1000

# Change output format
customgpt-cli list-projects --format json
customgpt-cli list-projects --format table
customgpt-cli list-projects --format id-only
```

Show a project details: 
```bash
customgpt-cli show-project --project-id PROJECT_ID --format json
```

Update a project:
```bash
customgpt-cli update-project --project-id PROJECT_ID --name "New Name" --is-shared 1 --format json
```

Delete projects:
```bash
# Delete single project
customgpt-cli delete-projects --project-ids PROJECT_ID

# Delete multiple projects
customgpt-cli delete-projects --project-ids "id1,id2,id3"

# Delete (with dry run)
customgpt-cli delete-projects --project-ids PROJECT_ID --dry-run

# Force delete without confirmation
customgpt-cli delete-projects --project-ids PROJECT_ID --force
```

### Conversation Management

Create a conversation:
```bash
customgpt-cli create-conversation --project-id PROJECT_ID --name "My Conversation"
```

Send a message:
```bash
# Without streaming
customgpt-cli send-message --project-id PROJECT_ID --session-id SESSION_ID --prompt "Hello"

# With streaming
customgpt-cli send-message --project-id PROJECT_ID --session-id SESSION_ID --prompt "Hello" --stream

# With custom persona
customgpt-cli send-message --project-id PROJECT_ID --session-id SESSION_ID --prompt "Hello" --persona "You are a helpful assistant"
```

### Page Management

Get project pages:
```bash
customgpt-cli get-pages --project-id PROJECT_ID
```

Delete a page:
```bash
customgpt-cli delete-page --project-id PROJECT_ID --page-id PAGE_ID
```

Reindex a page:
```bash
customgpt-cli reindex-page --project-id PROJECT_ID --page-id PAGE_ID
```

### Project Settings Management

Get project settings:
```bash
customgpt-cli get-project-settings --project-id PROJECT_ID
```

Update project settings:
```bash
customgpt-cli update-project-settings --project-id $PROJECT_ID --default-prompt "Test prompt" --chatbot-avatar "./tests/files/test.png" --chatbot-background "./tests/files/test.png" --example-questions '["Test questions"]' --response-source "default" --chatbot-msg-lang "en" --chatbot-color "#0e57cc" --chatbot-toolbar-color "#0e57cc" --persona-instructions "Test instructions" --citations-answer-source-label-msg "Test label" --citations-sources-label-msg "Test label" --hang-in-there-msg "Test message" --chatbot-siesta-msg "Test message" --is-loading-indicator-enabled --enable-citations 0 --enable-feedbacks --citations-view-type "user" --no-answer-message "Test message" --ending-message "Test message" --remove-branding --enable-recaptcha-for-public-chatbots --chatbot-model "gpt-4-o" --is-selling-enabled --license-slug "test" --selling-url "test"
```

### Plugin Management

Get plugins:
```bash
customgpt-cli get-plugins --project-id PROJECT_ID
```

Create plugins:
```bash
customgpt-cli create-plugin --project-id $PROJECT_ID --model-name "TestPlugin" --human-name "Test Assistant" --keywords "test,automation" --description "This is a helpful automation tool." --is-active
```

Update plugins:
```bash
customgpt-cli update-plugin --project-id $PROJECT_ID --model-name "Updated" --human-name "Updated Assistant" --keywords "updated,assistant" --description "Trusted information about indoor plants and gardening." --is-active
```

### Page Metadata Management

Get page metadata:
```bash
customgpt-cli get-page-metadata --project-id PROJECT_ID --page-id PAGE_ID
```

Update page metadata:
```bash
customgpt-cli update-page-metadata --project-id PROJECT_ID --page-id PAGE_ID --title "Page Title" --url "https://page-url.com" --description "Page description" --image "https://image-url.com/image.png"
```

### Report Management

Get reports:
```bash
# Get traffic report
customgpt-cli get-traffic-report --project-id PROJECT_ID --filters '["traffic", "pages"]'

# Get queries report
customgpt-cli get-queries-report --project-id PROJECT_ID --filters '["queries", "pages"]'

# Get conversations report
customgpt-cli get-conversations-report --project-id PROJECT_ID --filters '["conversations", "pages"]'

# Get analysis report
customgpt-cli get-analysis-report --project-id PROJECT_ID --filters '["analysis", "pages"]'
```

### Limits Management

Get limits:
```bash
customgpt-cli get-limits
```

### Citations Management

Get citations:
```bash
customgpt-cli get-citations --project-id PROJECT_ID --citation-id CITATION_ID
```

### Sources Management

Get sources:
```bash
customgpt-cli list-sources --project-id PROJECT_ID
```

Create a source:
```bash
# Create source with sitemap
customgpt-cli create-source --project-id PROJECT_ID --sitemap-path URL --file-data-retension --is-ocr-enabled --is-anonymized

# Create source with file
customgpt-cli create-source --project-id PROJECT_ID --file PATH --file-data-retension --is-ocr-enabled --is-anonymized
```

Update source:
```bash
customgpt-cli update-source --project-id PROJECT_ID --source-id SOURCE_ID --executive-js --data-refresh-frequency never --create-new-pages --remove-unexist-pages --refresh-existing-pages always --refresh-schedule ["00:00","08:00"]
```

Delete source:
```bash
customgpt-cli delete-source --project-id PROJECT_ID --source-id SOURCE_ID
```

Sync source:
```bash
customgpt-cli sync-source --project-id PROJECT_ID --source-id SOURCE_ID
```

### User Management

Get user:
```bash
customgpt-cli get-user
```

## Scripting Examples

Here is an examples of how to use the CLI in scripts:

1. Export project IDs to a file and process them:
```bash
#!/bin/bash
export CUSTOMGPT_API_KEY=your_api_key

# Export IDs
customgpt-cli list-projects --name-filter "test" --format id-only > projects.txt

# Process the IDs
customgpt-cli delete-projects --project-ids $(paste -s -d, projects.txt) --force
```

## Output Formats

The CLI supports multiple output formats for better integration with other tools:

- `table`: Human-readable formatted table (default)
- `json`: JSON format for parsing
- `csv`: CSV format for stats data
- `id-only`: Just the IDs, one per line (good for scripting)

## Safety Features

The CLI includes several safety features:

- `--dry-run`: Shows what would be deleted without actually deleting
- Confirmation prompts for destructive operations
- `--force` flag to skip confirmations in scripts
- Error handling with informative messages

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

## License

MIT License
```

Contents of pyproject.toml:
```
[tool.poetry]
name = "customgpt-cli"
version = "0.1.3"
description = "No-code AI agent creation platform for enterprise knowledge automation"
authors = ["CustomGPT Team <support@customgpt.ai>"]
readme = "README.md"
packages = [{include = "customgpt_cli"}]
homepage = "https://customgpt.ai"
repository = "https://github.com/customgpt/customgpt-cli"
keywords = ["ai", "agent", "cli", "automation", "enterprise"]

[tool.poetry.dependencies]
python = "^3.8"
customgpt-client = ">=1.1.6"
tabulate = ">=0.9.0"

[tool.poetry.scripts]
customgpt-cli = "customgpt_cli.cli:main"

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.black]
line-length = 88
target-version = ['py38']

[tool.mypy]
ignore_missing_imports = true

```

Contents of customgpt_cli/openapi.json:
```
{"openapi":"3.0.2","info":{"title":"CustomGPT.ai","description":"API Documentation for CustomGPT.ai.","contact":{"name":"CustomGPT.ai","url":"https://app.customgpt.ai","email":"hello@customgpt.ai"},"version":"1.0.0"},"servers":[{"url":"https://app.customgpt.ai","description":"API Version 1"}],"paths":{"/api/v1/projects":{"get":{"tags":["Projects"],"summary":"List all projects.","description":"Returns a list of your projects. The projects are returned sorted by creation date, with the most recent projects appearing first. It is a paginated API and you can use the page parameter to fetch the next page of projects. The default page size is 10.\n\nHere is an example to list projects: using [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/List_all_projects_for_an_account_with_pagination.ipynb) and using our python [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_List_all_projects_using_pagination.ipynb).","parameters":[{"name":"page","in":"query","description":"Page number to return","required":false,"schema":{"default":1,"type":"integer","example":1}},{"name":"duration","in":"query","description":"The duration of the projects to list.","required":false,"schema":{"type":"integer"},"example":90},{"name":"order","in":"query","description":"The order of the projects to list. Defaults to desc.","required":false,"schema":{"enum":["asc","desc"],"default":"desc","type":"string","example":"desc"}},{"name":"orderBy","in":"query","description":"The orderBy to sort the results by given field","required":false,"schema":{"enum":["id","created_at"],"default":"id","type":"string","example":"id"}},{"name":"width","in":"query","description":"The width of the embed code. Defaults to 100%.","required":false,"schema":{"default":"100%","type":"string","example":"50rem"}},{"name":"height","in":"query","description":"The height of the embed code. Defaults to 100%.","required":false,"schema":{"default":"auto","type":"string","example":"50rem"}},{"name":"name","in":"query","description":"Filter the results by project name","required":false,"schema":{"type":"string","example":"Sample project"}}],"responses":{"200":{"description":"Successfully retrieved list of projects that belong to the user.","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"type":"object","properties":{"current_page":{"description":"The current page number","type":"integer","example":1},"data":{"type":"array","items":{"$ref":"#/components/schemas/Project"}},"first_page_url":{"description":"The first page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"from":{"description":"The first item number of the current page","type":"integer","example":1},"last_page":{"description":"The last page number","type":"integer","example":1},"last_page_url":{"description":"The last page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"next_page_url":{"description":"The next page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"path":{"description":"The current page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"per_page":{"description":"The number of items per page","type":"integer","example":10},"prev_page_url":{"description":"The previous page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"to":{"description":"The last item number of the current page","type":"integer","example":1},"total":{"description":"The total number of items","type":"integer","example":1}}}}}}}},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"post":{"tags":["Projects"],"summary":"Create a new project.","description":"Create a new project by importing data either from a sitemap or an uploaded file. This endpoint enables you to initiate the creation of a new project by supplying the necessary project data that will be used as the context. You can choose to import the project structure and content from a sitemap url or upload a specific file format that contains the context can be any text, audio or video format. The system will process the provided data and generate a new project based on the imported or uploaded information.\nHere is an example to create an agent using a sitemap: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Create_Bot_By_Sitemap.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Create_Bot_By_Sitemap.ipynb).","requestBody":{"description":"Create a new project from a sitemap or a file","content":{"multipart/form-data":{"schema":{"type":"object","properties":{"project_name":{"description":"Project name","type":"string","example":"My project"},"sitemap_path":{"description":"The sitemap path","type":"string","example":"https://example.com/sitemap.xml"},"file_data_retension":{"description":"File data retension","type":"boolean","example":true},"is_ocr_enabled":{"description":"OCR enabled","type":"boolean","example":false},"is_anonymized":{"description":"Anonymized","type":"boolean","example":false},"file":{"description":"The submitted file.","format":"binary","type":"string","example":"file.pdf"}}}}}},"responses":{"201":{"$ref":"#/components/responses/ProjectCreatedResponse"},"400":{"$ref":"#/components/responses/CreateProjectErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}":{"get":{"tags":["Projects"],"summary":"Show a certain project.","description":"Retrieve details of a project based on its unique project ID. This endpoint allows you to fetch specific information about a project.","parameters":[{"name":"projectId","in":"path","description":"The unique project identifier.","required":true,"schema":{"type":"integer","example":1}},{"name":"width","in":"query","description":"The width of the embed code. Defaults to 100%.","required":false,"schema":{"default":"100%","type":"string","example":"50rem"}},{"name":"height","in":"query","description":"The height of the embed code. Defaults to 100%.","required":false,"schema":{"default":"auto","type":"string","example":"50rem"}}],"responses":{"200":{"$ref":"#/components/responses/ListProjectResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"post":{"tags":["Projects"],"summary":"Update a certain project.","description":"Update a project with specific details based on its unique projectId. This endpoint allows you to modify and revise the information associated with a particular project\nHere is an example to a update a specific object: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Update%20a%20project%20name.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Update_a_project_name.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The unique identifier of a project.","required":true,"schema":{"type":"integer"}}],"requestBody":{"description":"Update a project","content":{"multipart/form-data":{"schema":{"type":"object","properties":{"project_name":{"description":"Project name","type":"string","example":"My project"},"is_shared":{"description":"Whether the project is shared or not","type":"boolean","example":true},"sitemap_path":{"description":"Sitemap path","type":"string","example":"https://example.com/sitemap.xml"},"file_data_retension":{"description":"File data retension","type":"boolean","example":true},"is_ocr_enabled":{"description":"OCR enabled","type":"boolean","example":false},"is_anonymized":{"description":"Anonymized","type":"boolean","example":false},"file":{"description":"File","format":"binary","type":"string","example":"file.pdf"}}}}}},"responses":{"200":{"$ref":"#/components/responses/UpdateProjectResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"delete":{"tags":["Projects"],"summary":"Delete a certain project.","description":"Delete a project by its unique project ID. This endpoint allows you to remove an existing project from the system based on its ID.\nHere is an example to delete a project: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Delete_a_project.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Delete_a_project.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The unique identifier of a project.","required":true,"schema":{"type":"integer"}}],"responses":{"200":{"$ref":"#/components/responses/DeleteProjectResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/replicate":{"post":{"tags":["Projects"],"summary":"Replicate project by given Project ID.","description":"Create a copy pf project by replicating project info, settings, sitemap sources and uploaded files. This endpoint enables you to initiate the replication of a project by supplying the necessary project id value. The system will process the replicated data and generate a new project based on the information of existing project.","parameters":[{"name":"projectId","in":"path","description":"The unique project identifier.","required":true,"schema":{"type":"integer","example":1}}],"responses":{"201":{"$ref":"#/components/responses/ProjectCreatedResponse"},"400":{"$ref":"#/components/responses/CreateProjectErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/stats":{"get":{"tags":["Projects"],"summary":"Get the stats for a certain project.","description":"Retrieve statistical data for a project using its unique projectId. This endpoint provides extensive statistics about the project's performance, activity, or other relevant metrics.\nHere is an example to a specific object stats: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Get_Project_Stats.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Get_Project_Stats.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The unique identifier of a project.","required":true,"schema":{"type":"integer"}}],"responses":{"200":{"$ref":"#/components/responses/ProjectStatsResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/pages":{"get":{"tags":["Pages"],"summary":"List all pages that belong to a project.","description":"Retrieve a list of all pages associated with a project. This endpoint allows you to fetch project details and a collection of pages that belong to a specific project. Each page object includes information such as the page ID, URL, hash of the URL, project ID, crawl status, index status, file details (if applicable), creation and update timestamps, and other relevant attributes.\nHere is an example to list all pages belonging to project: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/List_all_pages_of_a_project.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_List_all_pages_belonging_to_a_project.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The unique project identifier.","required":true,"schema":{"type":"integer","example":1}},{"name":"page","in":"query","description":"Page number to return","required":false,"schema":{"default":1,"type":"integer"}},{"name":"duration","in":"query","description":"The duration of the projects to list. Defaults to 90 days.","required":false,"schema":{"default":90,"type":"integer"}},{"name":"order","in":"query","description":"The order of the projects to list. Defaults to desc.","required":false,"schema":{"enum":["asc","desc"],"default":"desc","type":"string"}}],"responses":{"200":{"description":"List of pages successfully retrieved.","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"type":"object","properties":{"project":{"$ref":"#/components/schemas/Project"},"pages":{"type":"object","properties":{"current_page":{"description":"The current page number","type":"integer","example":1},"data":{"type":"array","items":{"$ref":"#/components/schemas/Page"}},"first_page_url":{"description":"The first page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"from":{"description":"The first item number of the current page","type":"integer","example":1},"last_page":{"description":"The last page number","type":"integer","example":1},"last_page_url":{"description":"The last page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"next_page_url":{"description":"The next page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"path":{"description":"The current page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"per_page":{"description":"The number of items per page","type":"integer","example":10},"prev_page_url":{"description":"The previous page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"to":{"description":"The last item number of the current page","type":"integer","example":1},"total":{"description":"The total number of items","type":"integer","example":1}}}}}}}}}},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/pages/{pageId}":{"delete":{"tags":["Pages"],"summary":"Delete a certain page that belongs to a certain project.","description":"Delete a specific page within a project based on its unique projectId and pageId. This endpoint allows you to remove a particular page from the project, permanently deleting its associated context.\nHere is an example to delete a certain page: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Delete_a_page_from_the_project.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Delete_a_project_page.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The unique project identifier.","required":true,"schema":{"type":"integer"}},{"name":"pageId","in":"path","description":"The page id","required":true,"schema":{"type":"integer"}}],"responses":{"200":{"$ref":"#/components/responses/DeleteProjectResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/pages/{pageId}/reindex":{"post":{"tags":["Pages"],"summary":"Reindex a certain page that belongs to a certain project.","description":"Reindex a specific page within a project based on its unique projectId and pageId. This endpoint allows you to refresh a particular page from the project. Our system will crawl and index page content newly.","parameters":[{"name":"projectId","in":"path","description":"The unique project identifier.","required":true,"schema":{"type":"integer"}},{"name":"pageId","in":"path","description":"The page id","required":true,"schema":{"type":"integer"}}],"responses":{"200":{"description":"Page reindex process start successfully","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"type":"object","properties":{"updated":{"description":"Whether the page start reindex process successfully or not","type":"boolean","example":true}}}}}}}},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"403":{"$ref":"#/components/responses/PageReindexErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/pages/{pageId}/metadata":{"get":{"tags":["Pages Metadata"],"summary":"Get the Metadata for a certain page.","description":"Retrieve the Metadata for a page based on its unique identifier. This endpoint allows you to fetch the metadata associated with a specific page.","parameters":[{"name":"projectId","in":"path","description":"The unique identifier of the project.","required":true,"schema":{"type":"integer"}},{"name":"pageId","in":"path","description":"The unique identifier of the page.","required":true,"schema":{"type":"string"}}],"responses":{"200":{"description":"Get the Page metadata data for a citation","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/PageMetadata"}}}}}},"400":{"$ref":"#/components/responses/CreatePageMetadataErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/PageNotFoundErrorResponse"}},"security":[{"BearerToken":[]}]},"put":{"tags":["Pages Metadata"],"summary":"Update metadata for a certain page.","description":"Update the metadata for a specific page identified by its unique pageId. This endpoint allows you to update the associated metadata of the page.","parameters":[{"name":"projectId","in":"path","description":"The id of a project in which page is stored.","required":true,"schema":{"type":"integer"}},{"name":"pageId","in":"path","description":"The id of a page in which metadata will be updated.","required":true,"schema":{"type":"integer"}}],"requestBody":{"description":"Update a page metadata","content":{"application/json":{"schema":{"type":"object","properties":{"title":{"description":"The title of the page used in citations","type":"string","maxLength":255,"nullable":true,"example":"Title"},"url":{"description":"The url of the page used in citations","type":"string","maxLength":2000,"nullable":true,"example":"https://example.com/"},"description":{"description":"The description of the page used in citations","type":"string","maxLength":500,"nullable":true,"example":"One to two sentences."},"image":{"description":"The url of the image used in citations","type":"string","maxLength":2000,"nullable":true,"example":"https://example.com/image.png"}}}}}},"responses":{"200":{"description":"Get the Page metadata data for a citation","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/PageMetadata"}}}}}},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/PageNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/settings":{"get":{"tags":["Project Settings"],"summary":"Get project settings.","description":"Retrieve the project settings for a specific project. This endpoint allows you to fetch the configuration and settings associated with the project.\nHere is an example to get a project settings: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Get_Settings_for_a_particular_project.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Get_settings_for_a_particular_project.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The unique project identifier.","required":true,"schema":{"type":"integer"}}],"responses":{"200":{"$ref":"#/components/responses/ListProjectSettingsResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"post":{"tags":["Project Settings"],"summary":"Update project settings.","description":"Update the project settings for a specific project. This endpoint allows you to update the configuration and settings associated with the project.\nHere is an example to get a project settings: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Update_settings_for_a_particular_project.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Update_project_settings.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The unique project identifier.","required":true,"schema":{"type":"integer"}}],"requestBody":{"description":"Update project settings","content":{"multipart/form-data":{"schema":{"properties":{"chat_bot_avatar":{"description":"This is the avatar that is shown in the agent response. You can make it a profile picture or your company logo.","format":"binary","type":"string","example":"avatar.png"},"chat_bot_bg":{"description":"This is the background image shown in the agent conversations widget. You can change it to a company logo or background image.","format":"binary","type":"string","example":"bg.png"},"default_prompt":{"description":"This is the default prompt shown to the user. You can customize this for your company or client.","type":"string","maxLength":255,"example":"How can I help you?"},"example_questions[]":{"description":"These are example questions shown to guide users. You can create customized questions to suit your company or client needs.","type":"array","items":{"type":"string","example":"How can I help you?"}},"response_source":{"description":"By default, we ask ChatGPT to use only your content in its response (recommended). If you wish ChatGPT to improvise and use its own knowledgebase as well, you can select \"My Content + ChatGPT\"","enum":["default","own_content","openai_content"],"type":"string","maxLength":255,"example":"own_content"},"chatbot_msg_lang":{"description":"By default, the agent messages like 'Ask Me Anything' are in English. You can customize this to your preferred language. Please note: This setting does not control what language ChatGPT responds in. That is controlled by the user's question. So a user asking in Portuguese, will most likely get a response from ChatGPT in Portuguese.","enum":[["sq","ar","hy","az","ba","eu","be","bn","bh","bs","pt-BR","bg","yue","ca","hne","hr","cs","da","doi","nl","en","et","fo","fi","fr","gl","ka","de","el","gu","hry","he","hi","hu","id","ga","it","ja","jv","kn","ks","kk","kok","ko","ky","lv","lt","mk","mai","ms","mt","cmn","mr","mwr","nan","mo","mn","me","ne","no","or","ps","fa","pl","pt","pa","raj","ro","ru","sa","sat","sr","sd","si","sk","sl","es","sw","sv","tg","ta","tt","te","th","tr","tk","uk","ur","uz","vi","cy","wuu"]],"type":"string","maxLength":255,"example":"en"},"chatbot_color":{"description":"Color of the agent in hex format","type":"string","maxLength":9,"example":"#000000"},"chatbot_toolbar_color":{"description":"Color of the agent toolbar in hex format","type":"string","maxLength":9,"example":"#000000"},"persona_instructions":{"description":"Customize your agent behavior by adjusting the system parameter to control its personality traits  and role.","type":"string","maxLength":12000,"nullable":true,"example":"You are a custom AI Agent called CustomGPT.ai, a friendly lawyer who answers questions based on the given context."},"citations_answer_source_label_msg":{"description":"This is the message shown to indicate where the response came from. You can customize this message based on your business or language.","type":"string","maxLength":255,"nullable":true,"example":"Where did this answer come from?"},"citations_sources_label_msg":{"description":"This is the message shown for the Sources label.  You can customize this message based on your business or language.","type":"string","maxLength":255,"nullable":true,"example":"Sources"},"hang_in_there_msg":{"description":"This is the message shown when the agent is thinking and waiting to answer. You can customize this message based on your tone, personality or language.","type":"string","maxLength":255,"nullable":true,"example":"Hang in there! I'm thinking.."},"chatbot_siesta_msg":{"description":"This is the message shown when the agent has encountered a problem or error. You can customize this message based on your tone, personality or language.","type":"string","maxLength":255,"nullable":true,"example":"Oops! The agent is taking a siesta. This usually happens when OpenAI is down! Please try again later."},"is_loading_indicator_enabled":{"description":"Show animated loading indicator while waiting for a response from the agent","default":true,"type":"boolean","nullable":true,"example":true},"enable_citations":{"description":"Each agent response shows an option for the user to see the sources/citations from your content from which the response was generated.","enum":[0,1,2,3],"default":3,"type":"integer","nullable":true,"example":3},"enable_feedbacks":{"description":"Each agent response shows an thumbs up/down for the user to left own feedback.","default":true,"type":"boolean","nullable":true,"example":true},"citations_view_type":{"description":"Control how citations are shown. By default, the user can initiate to see the citations. You can choose to have it \"Auto Shown\" or \"Auto Hide\"","enum":["user","show","hide"],"default":"user","type":"string","nullable":true,"example":"user"},"no_answer_message":{"description":"This is the message shown when the agent cannot answer. You can customize it to a message asking the user to contact customer support or leave their email / phone.","default":"I'm sorry, I don't know the answer","type":"string","maxLength":1000,"nullable":true,"example":"Sorry, I don't have an answer for that."},"ending_message":{"description":"You can instruct ChatGPT to end every response with some text like asking \"Please email us for further support\" (Not recommended for most use cases)","type":"string","maxLength":1000,"nullable":true,"example":"Please email us for further support"},"remove_branding":{"description":"Controls what branding is shown at the bottom of the agent.","default":false,"type":"boolean","nullable":true,"example":false},"enable_recaptcha_for_public_chatbots":{"description":"Should we check messages from guests with Recaptcha when your agent is publicly available (i.e. shared or embedded).","default":false,"type":"boolean","nullable":true,"example":false},"chatbot_model":{"description":"This is the model used by the agent. You can choose a different model to suit your needs.","enum":["gpt-4-o","gpt-4-turbo","gpt-4","gpt-4o-mini","claude-3-sonnet","claude-3.5-sonnet"],"type":"string","nullable":true,"example":"gpt-4-o"},"is_selling_enabled":{"description":"Enable selling of the agent for monetization","default":false,"type":"boolean","nullable":true,"example":false}}}}}},"responses":{"200":{"$ref":"#/components/responses/UpdateProjectSettingsResponse"},"400":{"$ref":"#/components/responses/UpdateProjectSettingsErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/plugins":{"get":{"tags":["Project Plugins"],"summary":"Show a certain project plugin.","description":"Retrieve the plugin details associated with a project. This endpoint provides information about the project plugin.","parameters":[{"name":"projectId","in":"path","description":"The unique project id.","required":true,"schema":{"type":"integer","example":1}}],"responses":{"200":{"$ref":"#/components/responses/ListProjectPluginResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectPluginNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"post":{"tags":["Project Plugins"],"summary":"Create a plugin.","description":"Create a new plugin for a specific project identified by its unique projectId. This endpoint enables you to create a custom plugin for the project. Which allows you to share the custom agent as openai plugin to be shared globally.","parameters":[{"name":"projectId","in":"path","description":"The id of a project in which plugin will be stored.","required":true,"schema":{"type":"integer"}}],"requestBody":{"description":"Create a project plugin","content":{"application/json":{"schema":{"type":"object","properties":{"model_name":{"description":"Model Name","type":"string","example":"IndoorPlants"},"human_name":{"description":"Name For Human","type":"string","example":"The Indoor Plants Channel"},"keywords":{"description":"Keywords For Model","type":"string","example":"Indoor plants, Gardening, Trusted information."},"description":{"description":"Description For Human","type":"string","example":"Trusted information about indoor plants and gardening."},"is_active":{"description":"Whether the project plugin is active or not","default":false,"type":"boolean","example":true}}}}}},"responses":{"201":{"$ref":"#/components/responses/CreateProjectPluginResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"put":{"tags":["Project Plugins"],"summary":"Update a plugin.","description":"Update the plugin configuration for a specific project identified by its unique projectId. This endpoint allows you to update the associated attributes of the plugin.","parameters":[{"name":"projectId","in":"path","description":"The id of a project in which plugin will be stored.","required":true,"schema":{"type":"integer"}}],"requestBody":{"description":"Update a project plugin","content":{"application/json":{"schema":{"type":"object","properties":{"model_name":{"description":"Model Name","type":"string","example":"IndoorPlants"},"human_name":{"description":"Name For Human","type":"string","example":"The Indoor Plants Channel"},"keywords":{"description":"Keywords For Model","type":"string","example":"Indoor plants, Gardening, Trusted information."},"description":{"description":"Description For Human","type":"string","example":"Trusted information about indoor plants and gardening."},"is_active":{"description":"Whether the project plugin is active or not","default":false,"type":"boolean","example":true}}}}}},"responses":{"200":{"$ref":"#/components/responses/UpdateProjectPluginResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectPluginNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/conversations":{"get":{"tags":["Conversations"],"summary":"List all conversations for a project.","description":"Retrieve all conversations associated with a project based on its unique projectId. This endpoint allows you to fetch a collection of conversations related to a specific project.","parameters":[{"name":"projectId","in":"path","description":"The ID of the project to get the conversations for","required":true,"schema":{"type":"integer","example":1}},{"name":"page","in":"query","description":"Page number to return","required":false,"schema":{"default":1,"type":"integer"}},{"name":"order","in":"query","description":"The order to sort the results in given direction","required":false,"schema":{"enum":["asc","desc"],"default":"desc","type":"string","example":"desc"}},{"name":"orderBy","in":"query","description":"The orderBy to sort the results by given field","required":false,"schema":{"enum":["id","created_at"],"default":"id","type":"string","example":"id"}},{"name":"userFilter","in":"query","description":"Filter the results by the user that created the conversation","required":false,"schema":{"enum":["all","anonymous","team_member"],"default":"all","type":"string","example":"all"}},{"name":"name","in":"query","description":"Filter the results by conversation name","required":false,"schema":{"type":"string","example":"Ask me anything"}}],"responses":{"200":{"description":"List of conversations for a project","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"type":"object","properties":{"current_page":{"description":"The current page number","type":"integer","example":1},"data":{"type":"array","items":{"$ref":"#/components/schemas/Conversation"}},"first_page_url":{"description":"The first page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"from":{"description":"The first item number of the current page","type":"integer","example":1},"last_page":{"description":"The last page number","type":"integer","example":1},"last_page_url":{"description":"The last page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"next_page_url":{"description":"The next page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"path":{"description":"The current page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"per_page":{"description":"The number of items per page","type":"integer","example":10},"prev_page_url":{"description":"The previous page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"to":{"description":"The last item number of the current page","type":"integer","example":1},"total":{"description":"The total number of items","type":"integer","example":1}}}}}}}},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"post":{"tags":["Conversations"],"summary":"Create a new conversation.","description":"Create a new conversation for a project identified by its unique projectId. This endpoint allows you to initiate a new conversation within a specific project. A conversation serves as a platform for users to exchange messages regarding project-related matters. By providing the projectId, you can establish a conversation within the context of the project allowing you to seamlessly communicate with it.\nHere is an example to create a conversation: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Create_a_new_conversation_and_send_a_message_to_the_conversation.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Create_a_new_conversation_and_send_a_message_to_the_conversation.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The unique project identifier.","required":true,"schema":{"type":"integer"}}],"requestBody":{"description":"Create a new conversation","content":{"application/json":{"schema":{"type":"object","properties":{"name":{"description":"Conversation name","type":"string","maxLength":255,"example":"My conversation"}}}}}},"responses":{"201":{"$ref":"#/components/responses/CreateConversationResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/conversations/{sessionId}":{"put":{"tags":["Conversations"],"summary":"Update a conversation.","description":"Update a conversation within a project identified by its unique projectId and sessionId. This endpoint allows you to modify and update the properties of a specific conversation. By providing the projectId and sessionId, you can target the desired conversation and make changes to its attributes.\nHere is an example to update a conversation: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Update_Delete_a_conversation.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Update_Delete_a_conversation.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The unique project identifier.","required":true,"schema":{"type":"integer"}},{"name":"sessionId","in":"path","description":"The unique session identifier.","required":true,"schema":{"type":"string"}}],"requestBody":{"description":"Update a conversation","content":{"application/json":{"schema":{"type":"object","properties":{"name":{"description":"The new name of the conversation","type":"string","example":"My new conversation name"}}}}}},"responses":{"200":{"description":"Update conversation information","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/Conversation"}}}}}},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"delete":{"tags":["Conversations"],"summary":"Delete a conversation.","description":"Delete a conversation within a project identified by its unique projectId and sessionId. This endpoint allows you to remove a specific conversation from the project, permanently deleting all associated messages. By providing the projectId and sessionId, you can target the conversation to be deleted, ensuring the removal of all conversation-related data.\nHere is an example to delete a conversation: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Update_Delete_a_conversation.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Update_Delete_a_conversation.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The unique project identifier.","required":true,"schema":{"type":"integer"}},{"name":"sessionId","in":"path","description":"The unique session identifier.","required":true,"schema":{"type":"string"}}],"responses":{"200":{"$ref":"#/components/responses/DeleteProjectResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/conversations/{sessionId}/messages":{"get":{"tags":["Conversations"],"summary":"Retrieve messages that have been sent in a conversation.","description":"Retrieve all messages sent within a conversation of a project identified by its unique projectId and sessionId. This endpoint allows you to retrieve a collection of messages exchanged in a specific conversation. Messages contain the content, timestamps, and other relevant information shared during the course of the conversation. By providing the projectId and sessionId, you can access all the messages associated with that particular conversation within the project context.\nHere is an example to retrieve messages of a conversation: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Retrieve_messages_for_a_conversation.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Retrieve_Messages_of_conversation.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The ID of the project to get the messages for","required":true,"schema":{"type":"integer","example":1}},{"name":"sessionId","in":"path","description":"The session ID of the converstaions to get the messages for","required":true,"schema":{"type":"string","example":"1"}},{"name":"page","in":"query","description":"Page number to return","required":false,"schema":{"default":1,"type":"integer"}},{"name":"order","in":"query","description":"The order to sort the results by","required":false,"schema":{"enum":["asc","desc"],"default":"desc","type":"string","example":"desc"}}],"responses":{"200":{"$ref":"#/components/responses/ConversationMessageListResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"post":{"tags":["Conversations"],"summary":"Send a message to a conversation.","description":"Send a message to a conversation within a project identified by its unique projectId and sessionId. This endpoint enables you to send a new message to a specific conversation, facilitating seamless communication and collaboration within the project. By providing the projectId and sessionId, you can target the desired conversation and contribute to the ongoing discussion. This API endpoint supports real-time streaming, allowing for instant message delivery and dynamic updates which enables efficient and interactive communication between the user and agent.\nHere is an example to send a message to a conversation: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Create_a_new_conversation_and_send_a_message_to_the_conversation.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Create_a_new_conversation_and_send_a_message_to_the_conversation.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The ID of the project to get the messages for","required":true,"schema":{"type":"integer","example":1}},{"name":"sessionId","in":"path","description":"The session ID of the converstaions to get the messages for","required":true,"schema":{"type":"string","example":"1"}},{"name":"stream","in":"query","description":"Whether to stream the response or not, if stream the responses will be sent as data-only server-sent events as they become available, with the stream terminated by a `status: \"finish\"` message. [Example Python code](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Create_a_new_conversation_and_send_a_message_to_the_conversation.ipynb).","required":false,"schema":{"default":false,"type":"boolean"}},{"name":"lang","in":"query","description":"The language to use for the prompt","required":false,"schema":{"default":"en","type":"string"}},{"name":"external_id","in":"query","description":"The external ID of the prompt history.","required":false,"schema":{"type":"string","maxLength":128}},{"name":"Cache-Control","in":"header","description":"With this header set to `no-cache`, if the prompt has already been generated, a fresh response will be generated. Otherwise, the cached response will be returned.","required":false,"schema":{"enum":["no-cache"],"type":"string","nullable":true}}],"requestBody":{"description":"Send a message to a conversation.","content":{"application/json":{"schema":{"type":"object","properties":{"prompt":{"description":"Prompt to send to OpenAI","type":"string","example":"Write me hello world program in C"},"custom_persona":{"description":"Custom persona to use for the conversation","type":"string","nullable":true,"example":"You are a custom AI Agent called *agent name*, a friendly *agent role* who works for *organization* and answers questions based on the given context. Be as helpful as possible. Always prioritize the customer. Escalate complex issues. Stay on topic. Use appropriate language, Acknowledge limitations."},"chatbot_model":{"description":"Agent model to use for the conversation","enum":["gpt-4-o","gpt-4-turbo","gpt-4","gpt-4o-mini","claude-3-sonnet","claude-3.5-sonnet"],"type":"string","nullable":true,"example":"gpt-4-o"},"response_source":{"description":"By default, we ask ChatGPT to use only your content in its response (recommended). If you wish ChatGPT to improvise and use its own knowledgebase as well, you can set this to \"openai_content\".","enum":["default","own_content","openai_content"],"default":"default","type":"string","nullable":true,"example":"default"}}}}}},"responses":{"200":{"$ref":"#/components/responses/SendConversationResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"429":{"$ref":"#/components/responses/SendMessageResourceExhaustedErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/conversations/{sessionId}/messages/{promptId}":{"get":{"tags":["Message"],"summary":"Get a message by message ID","parameters":[{"name":"projectId","in":"path","description":"The ID of the project to get the messages for","required":true,"schema":{"type":"integer","example":1}},{"name":"sessionId","in":"path","description":"The session ID of the conversation to get the messages for","required":true,"schema":{"type":"string","example":"1"}},{"name":"promptId","in":"path","description":"The message id of the message","required":true,"schema":{"type":"integer","example":"1"}}],"responses":{"200":{"$ref":"#/components/responses/GetConversationMessageResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ConversationMessageNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/conversations/{sessionId}/messages/{promptId}/feedback":{"put":{"tags":["Message"],"summary":"Update the reaction for a specific message","parameters":[{"name":"projectId","in":"path","description":"The ID of the project to get the messages for","required":true,"schema":{"type":"integer","example":1}},{"name":"sessionId","in":"path","description":"The session ID of the conversation to get the messages for","required":true,"schema":{"type":"string","example":"1"}},{"name":"promptId","in":"path","description":"The message id of the message","required":true,"schema":{"type":"integer","example":"1"}}],"requestBody":{"description":"Update a message feedback","content":{"application/json":{"schema":{"type":"object","properties":{"reaction":{"description":"The new reaction","enum":[["neutral","disliked","liked"]],"type":"string","example":"liked"}}}}}},"responses":{"200":{"$ref":"#/components/responses/UpdateMessageFeedbackResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ConversationMessageNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/citations/{citationId}":{"get":{"tags":["Citations"],"summary":"Get the Open Graph data for a citation.","description":"Retrieve the Open Graph data for a citation based on its unique identifier. This endpoint allows you to fetch the Open Graph metadata associated with a specific citation.\nHere is an example to get citation detail: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Get_citation_details.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Get_Citation_Details.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The unique project identifier.","required":true,"schema":{"type":"integer","example":1}},{"name":"citationId","in":"path","description":"The unique citation identifier.","required":true,"schema":{"type":"integer","example":1}}],"responses":{"200":{"description":"Get the Page metadata data for a citation","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/PageMetadata"}}}}}},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/PageNotFoundErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/sources":{"get":{"tags":["Sources"],"summary":"List a certain project's sources.","description":"Retrieve a list of all sources associated with a given project. This endpoint provides a collection of sources that are linked to a specific project. Sources serve as references or contexts for the project.","parameters":[{"name":"projectId","in":"path","description":"The unique identifier of a project.","required":true,"schema":{"type":"integer"}}],"responses":{"200":{"$ref":"#/components/responses/ListProjectsResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"post":{"tags":["Sources"],"summary":"Create a new project source.","description":"Create a new data source for a given project, allowing you to add additional context by specifying a sitemap URL or uploading a file. This endpoint enables you to enrich the project's information by incorporating relevant data sources.\nHere is an example to add a new source to project: [API](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/Add_a_sitemap_to_an_existing_project.ipynb) [SDK](https://github.com/Poll-The-People/customgpt-cookbook/blob/main/examples/SDK_Add_a_Sitemap_to_project.ipynb).","parameters":[{"name":"projectId","in":"path","description":"The unique identifier of a project.","required":true,"schema":{"type":"integer"}}],"requestBody":{"description":"Create a new project source from a sitemap or a file","content":{"multipart/form-data":{"schema":{"type":"object","properties":{"sitemap_path":{"description":"The sitemap path","type":"string","example":"https://example.com/sitemap.xml"},"file_data_retension":{"description":"File data retension","type":"boolean","example":true},"is_ocr_enabled":{"description":"OCR enabled","type":"boolean","example":false},"is_anonymized":{"description":"Anonymized","type":"boolean","example":false},"file":{"description":"The submitted file.","format":"binary","type":"string","example":"file.pdf"}}}}}},"responses":{"201":{"$ref":"#/components/responses/CreateProjectSourceResponse"},"400":{"$ref":"#/components/responses/FlaskServiceErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/sources/{sourceId}":{"put":{"tags":["Sources"],"summary":"Update project source settings.","description":"Update a data source settings, allowing you to change additional settings.","parameters":[{"name":"projectId","in":"path","description":"The unique identifier of a project.","required":true,"schema":{"type":"integer"}},{"name":"sourceId","in":"path","required":true,"schema":{"type":"integer"}}],"requestBody":{"description":"Update a project source","content":{"application/json":{"schema":{"type":"object","properties":{"executive_js":{"description":"Whether the project source should execute JavaScript","default":true,"type":"boolean","example":true},"data_refresh_frequency":{"description":"The project source data refresh frequency","enum":[["never","daily","weekly","monthly","advanced"]],"default":"never","type":"string","example":"never"},"create_new_pages":{"description":"Add new pages to project automatically during refresh project source","default":true,"type":"boolean","example":true},"remove_unexist_pages":{"description":"Remove pages from project automatically during refresh project source","default":true,"type":"boolean","example":false},"refresh_existing_pages":{"description":"Refresh existing page during refresh project source","enum":[["never","always","if_updated"]],"default":"never","type":"string","example":"never"},"refresh_schedule":{"description":"Custom schedule for advanced data frequency","default":[],"type":"array","items":{"$ref":"#/components/schemas/Time"},"nullable":true,"example":{"days":[1,3,5],"hours":["08:00","23:59"]}}}}}}},"responses":{"201":{"$ref":"#/components/responses/UpdateProjectSourceResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectSourceNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"delete":{"tags":["Sources"],"summary":"Delete a project source.","description":"Delete a source for a given project.","parameters":[{"name":"projectId","in":"path","description":"The unique identifier of a project.","required":true,"schema":{"type":"integer"}},{"name":"sourceId","in":"path","description":"The unique identifier of a source.","required":true,"schema":{"type":"integer"}}],"responses":{"200":{"description":"Project source deleted successfully","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"type":"object","properties":{"deleted":{"description":"Whether the project source was deleted successfully or not","type":"boolean","example":true}}}}}}}},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/sources/{sourceId}/instant-sync":{"put":{"tags":["Sources"],"summary":"Instant sync the specified sitemap","parameters":[{"name":"projectId","in":"path","required":true,"schema":{"type":"integer"}},{"name":"sourceId","in":"path","description":"The source id","required":true,"schema":{"type":"integer"}}],"responses":{"201":{"$ref":"#/components/responses/SyncProjectSourceResponse"},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"403":{"$ref":"#/components/responses/SyncSourceErrorResponse"},"404":{"$ref":"#/components/responses/ProjectSourceNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/reports/traffic":{"get":{"tags":["Reports & Analytics"],"summary":"Provide summary of various metrics of users interactions with the application.","description":"Provide summary of various metrics of users interactions with the application such as the users number (both named and anonymous),\ntheir geographical locations, the browsers they use, and the sources from which they arrived at the application.","parameters":[{"name":"projectId","in":"path","description":"The ID of the project to get traffic for","required":true,"schema":{"type":"integer","example":1}},{"name":"filters","in":"query","description":"Filters to return traffic metrics for.","required":true,"style":"form","schema":{"type":"array","items":{"enum":["sources"],"type":"string"}}}],"responses":{"200":{"description":"Get the traffic metrics for a project","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/ProjectAnalyticsTraffic"}}}}}},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/reports/queries":{"get":{"tags":["Reports & Analytics"],"summary":"Provide summary of overall query metrics accross all conversations.","parameters":[{"name":"projectId","in":"path","description":"The ID of the project to get queries for","required":true,"schema":{"type":"integer","example":1}},{"name":"filters","in":"query","description":"Filters to return queries metrics for.","required":true,"style":"form","schema":{"type":"array","items":{"enum":["total","query_status"],"type":"string"}}}],"responses":{"200":{"description":"Get the query metrics for a project","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/ProjectAnalyticsQuery"}}}}}},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/reports/conversations":{"get":{"tags":["Reports & Analytics"],"summary":"Provide summary of overall conversation metrics.","parameters":[{"name":"projectId","in":"path","description":"The ID of the project to get conversations for","required":true,"schema":{"type":"integer","example":1}},{"name":"filters","in":"query","description":"Filters to return conversations metrics for.","required":true,"style":"form","schema":{"type":"array","items":{"enum":["total","average_queries_per_conversation"],"type":"string"}}}],"responses":{"200":{"description":"Get the conversation metrics data for a project","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/ProjectAnalyticsConversation"}}}}}},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/reports/analysis":{"get":{"tags":["Reports & Analytics"],"summary":"Provide graph-ready analysis data of various metrics.","parameters":[{"name":"projectId","in":"path","description":"The ID of the project to get analysis for","required":true,"schema":{"type":"integer","example":1}},{"name":"filters","in":"query","description":"Filters to return graph-ready analysis data for.","required":true,"style":"form","schema":{"type":"array","items":{"enum":["queries","conversations","queries_per_conversation"],"type":"string"}}},{"name":"interval","in":"query","description":"Interval to return graph-ready analysis data inbetween.","required":false,"schema":{"enum":["daily","weekly"],"default":"weekly","type":"string"}}],"responses":{"200":{"description":"Get the graph-ready data analysis for a project","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/ProjectAnalyticsAnalysis"}}}}}},"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/licenses":{"get":{"tags":["Project Licenses"],"summary":"Get all licenses for a project","description":"Returns a list of licenses for a specific project.","parameters":[{"name":"projectId","in":"path","description":"The unique identifier of a project.","required":true,"schema":{"type":"integer"}}],"responses":{"200":{"$ref":"#/components/responses/ProjectLicenseListResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"post":{"tags":["Project Licenses"],"summary":"Create a new license for a project","description":"Creates a new license for a specific project.","parameters":[{"name":"projectId","in":"path","description":"The unique identifier of a project.","required":true,"schema":{"type":"integer"}}],"requestBody":{"description":"Create a project license","content":{"application/json":{"schema":{"type":"object","properties":{"name":{"description":"The name of the license","type":"string","example":"My License"}}}}}},"responses":{"201":{"$ref":"#/components/responses/ProjectLicenseCreatedResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"422":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/projects/{projectId}/licenses/{licenseId}":{"get":{"tags":["Project Licenses"],"summary":"Get a license for a project","description":"Returns a specific license that belongs to a specific project.","parameters":[{"name":"projectId","in":"path","description":"The unique identifier of a project.","required":true,"schema":{"type":"integer"}},{"name":"licenseId","in":"path","description":"The unique identifier of a license.","required":true,"schema":{"type":"integer"}}],"responses":{"200":{"$ref":"#/components/responses/ProjectLicenseShowResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectLicenseNotFoundErrorResponse"},"422":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"put":{"tags":["Project Licenses"],"summary":"Update a license for a project","description":"Updates the name of a specific license that belongs to a specific project.","parameters":[{"name":"projectId","in":"path","description":"The unique identifier of a project.","required":true,"schema":{"type":"integer"}},{"name":"licenseId","in":"path","description":"The unique identifier of a license.","required":true,"schema":{"type":"integer"}}],"requestBody":{"description":"Update a project license","content":{"application/json":{"schema":{"type":"object","properties":{"name":{"description":"The new name of the license","type":"string","example":"My new license name"}}}}}},"responses":{"200":{"$ref":"#/components/responses/ProjectLicenseUpdatedResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectLicenseNotFoundErrorResponse"},"422":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"delete":{"tags":["Project Licenses"],"summary":"Delete a license for a project","description":"Deletes a specific license that belongs to a specific project.","parameters":[{"name":"projectId","in":"path","description":"The unique identifier of a project.","required":true,"schema":{"type":"integer"}},{"name":"licenseId","in":"path","description":"The unique identifier of a license.","required":true,"schema":{"type":"integer"}}],"responses":{"200":{"$ref":"#/components/responses/ProjectLicenseDeletedResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/ProjectLicenseNotFoundErrorResponse"},"422":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/preview/{id}":{"get":{"tags":["Pages"],"summary":"Preview file from citation.","parameters":[{"name":"id","in":"path","required":true,"schema":{"type":"string"}}],"responses":{"400":{"$ref":"#/components/responses/BadArgumentErrorResponse"},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"404":{"$ref":"#/components/responses/PageNotFoundErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}},"/api/v1/user":{"get":{"tags":["Users"],"summary":"Show the user's profile.","description":"Retrieve the profile information of the current user. This endpoint allows you to fetch the details and attributes associated with the user's profile, providing valuable information about the user's account and preferences.","responses":{"200":{"description":"Retrieve user account info","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/User"}}}}}},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]},"post":{"tags":["Users"],"summary":"Update the user's profile.","description":"Update the profile of the current user. This endpoint allows the user to modify and update their profile information and preferences within the application or system.","requestBody":{"description":"Update user account info","content":{"multipart/form-data":{"schema":{"properties":{"profile_photo":{"description":"User profile photo","format":"binary","type":"string","example":"avatar.png"},"name":{"description":"User name","type":"string","maxLength":255,"example":"John Doe"}}}}}},"responses":{"200":{"description":"Update user account info","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/User"}}}}}},"401":{"$ref":"#/components/responses/ApiTokenValidationErrorResponse"},"500":{"$ref":"#/components/responses/InternalServerErrorResponse"}},"security":[{"BearerToken":[]}]}}},"components":{"schemas":{"Time":{"type":"object","properties":{"days":{"description":"Index of days in which sitemap should be refreshed. Starts from 0 (Sunday) to 6 (Saturday).","type":"array","items":{"type":"integer","example":0},"example":[0,1,4,6]},"hours":{"description":"List of times in which sitemap should be refreshed. Must be in HH:MM format.","type":"array","items":{"type":"string","example":"23:45"},"example":["00:00","08:00","23:45"]}}},"Conversation":{"type":"object","properties":{"created_at":{"description":"When was this conversation created?","format":"date-time","type":"string","example":"2023-04-30 16:43:53"},"updated_at":{"description":"When was this conversation updated?","format":"date-time","type":"string","example":"2023-04-30 16:43:53"},"deleted_at":{"description":"When was this conversation deleted?","format":"date-time","type":"string","example":"2023-04-30 16:43:53"},"id":{"description":"Conversation ID","type":"integer","example":1},"name":{"description":"Conversation name","type":"string","example":"Conversation 1"},"project_id":{"description":"Project ID for this conversation","type":"string","example":1},"created_by":{"description":"User ID for the user who created this conversation","type":"string","example":1},"session_id":{"description":"Session ID for this conversation","format":"uuid","type":"string","example":"f1b9aaf0-5e4e-11eb-ae93-0242ac130002"}}},"ProjectSettings":{"type":"object","properties":{"chatbot_avatar":{"description":"This is the avatar that is shown in the agent response. You can make it a profile picture or your company logo.","type":"string","example":"https://example.com/agent_avatar.png"},"chatbot_background":{"description":"This is the background image shown in the agent conversations widget. You can change it to a company logo or background image.","type":"string","example":"https://example.com/agent_background.png"},"default_prompt":{"description":"This is the default prompt shown to the user. You can customize this for your company or client.","type":"string","example":"How can I help you?"},"example_questions":{"description":"These are example questions shown to guide users. You can create customized questions to suit your company or client needs.","type":"array","items":{"type":"string","example":"How do I get started?"},"example":["How do I get started?"]},"response_source":{"description":"By default, we ask ChatGPT to use only your content in its response (recommended). If you wish ChatGPT to improvise and use its own knowledgebase as well, you can select \"My Content + ChatGPT\"","enum":["default","own_content","openai_content"],"type":"string","example":"own_content"},"chatbot_msg_lang":{"description":"By default, the agent messages like 'Ask Me Anything' are in English. You can customize this to your preferred language. Please note: This setting does not control what language ChatGPT responds in. That is controlled by the user's question. So a user asking in Portuguese, will most likely get a response from ChatGPT in Portuguese.","type":"string","example":"en"},"chatbot_color":{"description":"Color of the agent in hex format","type":"string","example":"#000000"},"chatbot_toolbar_color":{"description":"Color of the agent toolbar in hex format","type":"string","example":"#000000"},"persona_instructions":{"description":"Customize your agent behavior by adjusting the system parameter to control its personality traits  and role.","type":"string","nullable":true,"example":"You are a custom agent assistant called CustomGPT.ai, a friendly lawyer who answers questions based on the given context."},"citations_answer_source_label_msg":{"description":"This is the message shown to indicate where the response came from. You can customize this message based on your business or language.","type":"string","nullable":true,"example":"Where did this answer come from?"},"citations_sources_label_msg":{"description":"This is the message shown for the Sources label.  You can customize this message based on your business or language.","type":"string","nullable":true,"example":"Sources"},"hang_in_there_msg":{"description":"This is the message shown when the agent is thinking and waiting to answer. You can customize this message based on your tone, personality or language.","type":"string","nullable":true,"example":"Hang in there! I'm thinking.."},"chatbot_siesta_msg":{"description":"This is the message shown when the agent has encountered a problem or error. You can customize this message based on your tone, personality or language.","type":"string","nullable":true,"example":"Oops! The agent is taking a siesta. This usually happens when OpenAI is down! Please try again later."},"is_loading_indicator_enabled":{"description":"Show animated loading indicator while waiting for a response from the agent","default":true,"type":"boolean","nullable":true,"example":true},"enable_citations":{"description":"Each agent response shows an option for the user to see the sources/citations from your content from which the response was generated.","enum":[0,1,2,3],"default":3,"type":"integer","nullable":true,"example":3},"enable_feedbacks":{"description":"Each agent response shows an thumbs up/down for the user to left own feedback.","default":true,"type":"boolean","nullable":true,"example":true},"citations_view_type":{"description":"Control how citations are shown. By default, the user can initiate to see the citations. You can choose to have it \"Auto Shown\" or \"Auto Hide\"","enum":["user","show","hide"],"default":"user","type":"string","nullable":true,"example":"user"},"no_answer_message":{"description":"This is the message shown when the agent cannot answer. You can customize it to a message asking the user to contact customer support or leave their email / phone.","default":"I'm sorry, I don't know the answer","type":"string","nullable":true,"example":"Sorry, I don't have an answer for that."},"ending_message":{"description":"You can instruct ChatGPT to end every response with some text like asking \"Please email us for further support\" (Not recommended for most use cases)","type":"string","nullable":true,"example":"Please email us for further support"},"remove_branding":{"description":"Controls what branding is shown at the bottom of the agent.","default":false,"type":"boolean","nullable":true,"example":false},"enable_recaptcha_for_public_chatbots":{"description":"Should we check messages from guests with Recaptcha when your agent is publicly available (i.e. shared or embedded).","default":false,"type":"boolean","nullable":true,"example":false},"chatbot_model":{"description":"This is the model used by the agent. You can choose a different model to suit your needs.","enum":["gpt-4-o","gpt-4-turbo","gpt-4","gpt-4o-mini","claude-3-sonnet","claude-3.5-sonnet"],"default":"gpt-4-o","type":"string","nullable":true,"example":"gpt-4-o"},"is_selling_enabled":{"description":"Enable selling of agent for monetization","default":false,"type":"boolean","nullable":true,"example":false},"license_slug":{"description":"License slug used for monetization","type":"boolean","nullable":true,"readOnly":true},"selling_url":{"description":"Selling URL used for monetization","type":"string","nullable":true,"readOnly":true}}},"ProjectPlugin":{"type":"object","properties":{"model_name":{"description":"Model Name","type":"string","example":"IndoorPlants"},"human_name":{"description":"Name For Human","type":"string","example":"The Indoor Plants Channel"},"keywords":{"description":"Keywords For Model","type":"string","example":"Indoor plants, Gardening, Trusted information."},"description":{"description":"Description For Human","type":"string","example":"Trusted information about indoor plants and gardening."},"logo":{"description":"Project plugin logo","type":"string","example":"https://app.customgpt.ai/logo.svg"},"is_active":{"description":"Whether the project plugin is active or not","default":false,"type":"boolean","example":true}}},"Project":{"type":"object","properties":{"id":{"description":"Project ID","type":"integer","example":1},"project_name":{"description":"Project name","type":"string","example":"My Project"},"sitemap_path":{"description":"Project sitemap","type":"string","example":"https://www.example.com/sitemap.xml"},"is_chat_active":{"description":"Whether the agent is active or not","default":false,"type":"boolean","example":true},"user_id":{"description":"User ID of the project owner","type":"integer","example":1},"team_id":{"description":"Team ID of the project owner","type":"integer","example":1},"created_at":{"description":"Date and time when the project was created","default":"2023-05-08 13:06:55","format":"date-time","type":"string","example":"2021-01-01 00:00:00"},"updated_at":{"description":"Date and time when the project was last updated","default":"2023-05-08 13:06:55","format":"date-time","type":"string","example":"2021-01-01 00:00:00"},"deleted_at":{"description":"Date and time when the project was deleted","format":"date-time","type":"string","nullable":true,"example":"2021-01-01 00:00:00"},"type":{"description":"Project type","enum":["SITEMAP","URL"],"default":"SITEMAP","type":"string","example":"SITEMAP"},"is_shared":{"description":"Whether the project is shared or not","default":false,"type":"boolean","example":true},"shareable_slug":{"description":"Shareable slug that can be used to share the project","format":"md5","type":"string","nullable":true,"example":"1234567890abcdef1234567890abcdef"},"shareable_link":{"description":"Shareable link that can be used to share the project","format":"url","type":"string","nullable":true},"embed_code":{"description":"Embed code that can be used to embed the project","format":"html","type":"string","nullable":true},"live_chat_code":{"description":"Live chat code that can be used to embed the live chat","format":"html","type":"string","nullable":true}}},"ProjectLicense":{"type":"object","properties":{"name":{"description":"License Name","type":"string","maxLength":255,"example":"My License"},"key":{"description":"License Key","format":"uuid","type":"string","example":"123e4567-e89b-12d3-a456-426614174000"},"project_id":{"description":"Project ID this license belongs to","type":"integer","example":7},"created_at":{"description":"Date and time when the license was created","format":"date-time","type":"string","example":"2021-01-01 00:00:00"},"updated_at":{"description":"Date and time when the license was last updated","format":"date-time","type":"string","example":"2021-01-01 00:00:00"}}},"PromptHistory":{"type":"object","properties":{"id":{"description":"The unique identifier of the prompt history.","type":"integer","example":1},"user_id":{"description":"The unique identifier of the user.","type":"integer","example":1},"user_query":{"description":"The user prompt query.","type":"string","example":"What is the meaning of life?"},"openai_response":{"description":"The OpenAI response to the user prompt query.","type":"string","example":"The meaning of life is to be happy."},"created_at":{"description":"The date and time the prompt history was created.","format":"date-time","type":"string","example":"2021-01-01 00:00:00"},"updated_at":{"description":"The date and time the prompt history was last updated.","format":"date-time","type":"string","example":"2021-01-01 00:00:00"},"conversation_id":{"description":"The unique identifier of the conversation.","type":"integer","example":1},"citations":{"description":"The citations for the prompt history.","default":[],"type":"array","items":{"type":"integer","example":1},"example":[1,2,3]},"metadata":{"type":"object","properties":{"user_ip":{"description":"The IP address of the user.","type":"string","example":"127.0.0.1"},"user_agent":{"description":"The user agent of the user.","type":"string","example":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko)"},"external_id":{"description":"The external ID of the prompt history.","type":"string","maxLength":128,"example":"ext_id_1234567890"},"request_source":{"description":"The source of the request.","type":"string","example":"web"}},"example":{"user_ip":"127.0.0.1","user_agent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko)","external_id":"ext_id_1234567890","request_source":"web"}},"response_feedback":{"type":"object","properties":{"created_at":{"description":"The timestamp when the feedback was created","format":"date-time","type":"string","example":"2024-08-27T21:07:20.000000Z"},"updated_at":{"description":"The timestamp when the feedback was last updated","format":"date-time","type":"string","example":"2024-08-27T21:07:20.000000Z"},"user_id":{"description":"The ID of the user who provided the feedback","type":"integer","nullable":true,"example":1},"reaction":{"description":"The reaction provided by the user","enum":[["neutral","disliked","liked"]],"type":"string","example":"liked"}}}}},"User":{"type":"object","properties":{"created_at":{"description":"When was this user created?","format":"date-time","type":"string","example":"2023-04-30 16:43:53"},"email":{"description":"User email","format":"email","type":"string","example":"user@domain.com"},"id":{"description":"User ID","type":"integer","example":1},"current_team_id":{"description":"User currently active team ID","type":"integer","example":1},"name":{"description":"User name","type":"string","example":"John Doe"},"profile_photo_url":{"description":"User profile photo URL","format":"url","type":"string","example":"https://app.customgpt.ai/user/1/profile_photo_url"},"updated_at":{"description":"When was this user updated?","format":"date-time","type":"string","example":"2023-04-30 16:43:53"}}},"ProjectSource":{"type":"object","properties":{"id":{"description":"The project source ID","type":"integer","example":1},"created_at":{"description":"The project source creation date","format":"date-time","type":"string","example":"2021-01-01 00:00:00"},"updated_at":{"description":"The project source update date","format":"date-time","type":"string","example":"2021-01-01 00:00:00"},"type":{"description":"The project source type","enum":["sitemap","upload"],"type":"string","example":"sitemap"},"settings":{"description":"The project source settings","type":"object","properties":{"executive_js":{"description":"Whether the project source should execute JavaScript","default":true,"type":"boolean","example":true},"data_refresh_frequency":{"description":"The project source data refresh frequency","enum":[["never","daily","weekly","monthly","advanced"]],"default":"never","type":"string","example":"never"},"create_new_pages":{"description":"Add new pages to project automatically during refresh project source","default":true,"type":"boolean","example":true},"remove_unexist_pages":{"description":"Remove pages from project automatically during refresh project source","default":true,"type":"boolean","example":false},"refresh_existing_pages":{"description":"Refresh existing page during refresh project source","enum":[["never","always","if_updated"]],"default":"never","type":"string","example":"never"},"sitemap_path":{"description":"The project source sitemap path","type":"string","example":"https://example.com/sitemap.xml"}}},"pages":{"description":"The project source pages","type":"array","items":{"$ref":"#/components/schemas/Page"},"nullable":true}}},"ProjectAnalyticsQuery":{"type":"object","properties":{"total":{"description":"Total number of queries over all conversations","type":"integer","example":10},"query_status":{"description":"Number of successful and failed queries over all conversations","type":"array","items":{"type":"object","properties":{"status":{"enum":["failed","success"],"type":"string"},"count":{"type":"integer","example":2}}}}}},"ProjectAnalyticsConversation":{"type":"object","properties":{"total":{"description":"Total number of conversations","type":"integer","example":10},"average_queries_per_conversation":{"description":"Average number of queries per conversations","type":"integer","example":1.2}}},"ProjectAnalyticsAnalysis":{"type":"object","properties":{"queries":{"type":"array","items":{"type":"object","properties":{"queries_number":{"type":"integer","example":5},"created_at_interval":{"type":"string","example":"Sat"}}}},"conversations":{"type":"array","items":{"type":"object","properties":{"queries_number":{"type":"integer","example":5},"created_at_interval":{"type":"string","example":"Sat"}}}},"queries_per_conversation":{"type":"array","items":{"type":"object","properties":{"queries_number":{"type":"integer","example":1.5},"created_at_interval":{"type":"string","example":"Sat"}}}}}},"ProjectAnalyticsTraffic":{"type":"object","properties":{"sources":{"type":"array","items":{"type":"object","properties":{"request_source":{"enum":["web","api","embed","livechat","sge","ai-assistant","instant-viewer"],"type":"string","example":"web"},"request_source_number":{"type":"integer","example":20}}}}}},"Page":{"type":"object","properties":{"id":{"description":"Page ID","type":"integer","example":1},"page_url":{"description":"URL of the page or file","type":"string","example":"https://example.com"},"page_url_hash":{"description":"Hash of the URL of the page or file","format":"md5","type":"string","example":"d41d8cd98f00b204e9800998ecf8427e"},"project_id":{"description":"Project ID","type":"integer","example":1},"s3_path":{"description":"This is the path where the page is stored in S3.\\nNote: This is omitted in the response if the page is not a file","type":"string","nullable":true,"example":"project-1/page-1/file.pdf"},"crawl_status":{"description":"Crawl status of the page","enum":["ok","queued","failed","n/a","limited"],"default":"queued","type":"string","example":"queued"},"index_status":{"description":"Index status of the page","enum":["ok","queued","failed","n/a","limited"],"default":"queued","type":"string","example":"queued"},"is_file":{"description":"Whether the page is a file or not","default":false,"type":"boolean","example":true},"is_refreshable":{"description":"Whether the page can be refreshed or not","default":false,"type":"boolean","example":true},"is_file_kept":{"description":"Whether the file is kept after processing or not.\\nNote: This is omitted in the response if the page is not a file","default":true,"type":"boolean","example":true},"filename":{"description":"Filename of the page.\\nNote: This is omitted in the response if the page is not a file","type":"string","nullable":true,"example":"file.pdf"},"filesize":{"description":"Filesize of the page.\\nNote: This is omitted in the response if the page is not a file","type":"integer","nullable":true,"example":100},"created_at":{"description":"Date and time when the page was created","format":"date-time","type":"string","example":"2021-01-01 00:00:00"},"updated_at":{"description":"Date and time when the page was updated","format":"date-time","type":"string","example":"2021-01-01 00:00:00"},"deleted_at":{"description":"Date and time when the page was deleted","format":"date-time","type":"string","example":"2021-01-01 00:00:00"}}},"PageMetadata":{"type":"object","properties":{"id":{"description":"The unique identifier of the page","type":"integer","example":1},"url":{"description":"The URL of the page","type":"string","nullable":true,"example":"https://www.example.com"},"title":{"description":"The title of the page","type":"string","nullable":true,"example":"Example Domain"},"description":{"description":"The description of the page","type":"string","nullable":true,"example":"This domain is for use in illustrative examples in documents. You may use this domain in literature without prior coordination or asking for permission."},"image":{"description":"The image of the page","type":"string","nullable":true,"example":"https://www.example.com/image.png"}}}},"responses":{"InternalServerErrorResponse":{"description":"Internal Server Error","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":500},"message":{"type":"string","example":"Internal Server Error"}}}}}}}},"ListProjectsResponse":{"description":"Successfully retrieved list of sources that belong to a project.","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"type":"object","properties":{"sitemaps":{"type":"array","items":{"$ref":"#/components/schemas/ProjectSource"}},"uploads":{"$ref":"#/components/schemas/ProjectSource"}}}}}}}},"ProjectNotFoundErrorResponse":{"description":"Project not found","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":404},"message":{"description":"The error message","enum":["Project id is required","Project with id {projectId} not found"],"type":"string","example":"Project with id 1 not found"}}}}}}}},"SyncSourceErrorResponse":{"description":"Source sync failed","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":403},"message":{"description":"The error message","enum":["Your plan not eligible for instant sync","Next instant sync will be available in \\{seconds\\} seconds","Project source can't be synced"],"type":"string","example":"Subscription not eligible for instant sync"}}}}}}}},"UpdatePageMetadataErrorResponse":{"description":"Update page metadata failed","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":400},"message":{"description":"The error message","type":"string","example":"Image must be valid url."}}}}}}}},"UpdateProjectSettingsResponse":{"description":"Project settings have been updated","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"type":"object","properties":{"updated":{"description":"Whether the project was updated successfully or not","type":"boolean","example":true}}}}}}}},"ProjectLicenseUpdatedResponse":{"description":"Updated project license","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"license":{"$ref":"#/components/schemas/ProjectLicense"}}}}}},"ProjectPluginNotFoundErrorResponse":{"description":"Project plugin not found","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":404},"message":{"description":"The error message","enum":["Project plugin id is required","Project plugin with id {pluginId} not found","Plugin for project with id {projectId} not found"],"type":"string","example":"Project plugin with id 1 not found"}}}}}}}},"ListProjectResponse":{"description":"Retrieve certain project that belongs to the user","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/Project"}}}}}},"DeleteProjectResponse":{"description":"Project deleted successfully","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"type":"object","properties":{"deleted":{"description":"Whether the project was deleted successfully or not","type":"boolean","example":true}}}}}}}},"ProjectSourceNotFoundErrorResponse":{"description":"Project source not found","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":404},"message":{"description":"The error message","enum":["Project source id is required","Project source with id {sourceId} not found"],"type":"string","example":"Project source with id 1 not found"}}}}}}}},"ProjectCreatedResponse":{"description":"Project has been created","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/Project"}}}}}},"UpdateMessageFeedbackResponse":{"description":"Feedback has been updated","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/PromptHistory"}}}}}},"PageNotFoundErrorResponse":{"description":"Page not found","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":404},"message":{"description":"The error message","enum":["Page id is required","Page with id {pageId} not found"],"type":"string","example":"Page with id 1 not found"}}}}}}}},"ConversationMessageListResponse":{"description":"List all messages in a conversation","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"type":"object","properties":{"conversation":{"$ref":"#/components/schemas/Conversation"},"messages":{"type":"object","properties":{"current_page":{"description":"The current page number","type":"integer","example":1},"data":{"type":"array","items":{"$ref":"#/components/schemas/PromptHistory"}},"first_page_url":{"description":"The first page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"from":{"description":"The first item number of the current page","type":"integer","example":1},"last_page":{"description":"The last page number","type":"integer","example":1},"last_page_url":{"description":"The last page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"next_page_url":{"description":"The next page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"path":{"description":"The current page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"per_page":{"description":"The number of items per page","type":"integer","example":10},"prev_page_url":{"description":"The previous page url","type":"string","example":"https://app.customgpt.ai/api/v1/users?page=1"},"to":{"description":"The last item number of the current page","type":"integer","example":1},"total":{"description":"The total number of items","type":"integer","example":1}}}}}}}}}},"CreateProjectErrorResponse":{"description":"Project creation failed","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":400},"message":{"description":"The error message","enum":["Project name can't be empty","Sitemap path can't be empty","You have reached your monthly project limit"],"type":"string","example":"Project name can't be empty"}}}}}}}},"UpdateProjectResponse":{"description":"Project has been updated","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/Project"}}}}}},"CreateProjectSourceResponse":{"description":"Successfully created a new project source.","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/ProjectSource"}}}}}},"PageReindexErrorResponse":{"description":"Page cannot be reindexed","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":400},"message":{"description":"The error message","enum":["Page with id {pageId} cannot be reindexed"],"type":"string","example":"Page with id 1 cannot be reindexed"}}}}}}}},"ProjectLicenseNotFoundErrorResponse":{"description":"Project license not found","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":404},"message":{"description":"The error message","enum":["License ID is required","Project license with id {licenseId} not found"],"type":"string","example":"Project license with id 1 not found"}}}}}}}},"ListProjectSettingsResponse":{"description":"Project settings that belong to a certain project","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/ProjectSettings"}}}}}},"CreatePageMetadataErrorResponse":{"description":"Create page metadata failed","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":400},"message":{"description":"The error message","type":"string","example":"Something went wrong."}}}}}}}},"ProjectLicenseListResponse":{"description":"List of available project licenses","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ProjectLicense"}}}}}}},"SendConversationResponse":{"description":"Send a message to a conversation","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/PromptHistory"}}}}}},"UpdateProjectPluginResponse":{"description":"Project plugin have been updated","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/ProjectPlugin"}}}}}},"GetConversationMessageResponse":{"description":"Retrieve certain conversation message","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/PromptHistory"}}}}}},"UpdateProjectSettingsErrorResponse":{"description":"Update project settings failed","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":400},"message":{"description":"The error message","enum":["Please upload a valid image file for avatar","Please upload a valid image file for background","Language Proficiency is required."],"type":"string","example":"Please upload a valid image file for avatar"}}}}}}}},"ConversationMessageNotFoundErrorResponse":{"description":"Conversation message not found","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":404},"message":{"description":"The error message","enum":["Conversation message id is required","Conversation message with id {messageId} not found"],"type":"string","example":"Conversation message with id 1 not found"}}}}}}}},"BadArgumentErrorResponse":{"description":"Bad Argument","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":400},"message":{"description":"The error message","type":"string","example":"Project id must be integer"}}}}}}}},"UpdateProjectSourceResponse":{"description":"Successfully updated project source.","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/ProjectSource"}}}}}},"ProjectLicenseShowResponse":{"description":"Show project license","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"license":{"$ref":"#/components/schemas/ProjectLicense"}}}}}},"ListProjectPluginResponse":{"description":"Project plugin that belong to a certain project","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/ProjectPlugin"}}}}}},"FlaskServiceErrorResponse":{"description":"Service unavailable","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":400},"message":{"description":"The error message","type":"string","example":"Sitemap URL is empty"}}}}}}}},"SendMessageResourceExhaustedErrorResponse":{"description":"Resource Exhausted when sending a message to a conversation","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":429},"message":{"description":"The error message","type":"string","example":"You have exhausted your current query credits. Please contact hello@customgpt.ai for further assistance."}}}}}}}},"SyncProjectSourceResponse":{"description":"Project source sync started.","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/ProjectSource"}}}}}},"ProjectLicenseDeletedResponse":{"description":"Deleted project license","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"type":"object","properties":{"deleted":{"description":"The project license has been deleted","type":"boolean","example":true}}}}}}}},"ApiTokenValidationErrorResponse":{"description":"API Token is either missing or invalid","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"error"},"url":{"description":"The URL of the request","type":"string","example":"https://app.customgpt.ai/api/v1/projects/1"},"data":{"type":"object","properties":{"code":{"description":"The error status code","enum":[400,401,403,404,500,503],"type":"integer","example":401},"message":{"type":"string","example":"API Token is either missing or invalid"}}}}}}}},"CreateProjectPluginResponse":{"description":"Project plugin have been created","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/ProjectPlugin"}}}}}},"ProjectStatsResponse":{"description":"Project stats","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"type":"object","properties":{"pages_found":{"description":"Number of pages found for the project","type":"integer","example":100},"pages_crawled":{"description":"Number of pages crawled for the project","type":"integer","example":100},"pages_indexed":{"description":"Number of pages indexed for the project","type":"integer","example":100},"crawl_credits_used":{"description":"Number of crawl credits used for the project","type":"integer","example":100},"query_credits_used":{"description":"Number of query credits used for the project","type":"integer","example":100},"total_queries":{"description":"Number of queries used for the project","type":"integer","example":100},"total_words_indexed":{"description":"Number of index credits used for the project","type":"integer","example":100},"total_storage_credits_used":{"description":"Number of words stored for the project","type":"integer","example":100}}}}}}}},"ProjectLicenseCreatedResponse":{"description":"Project license","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"type":"object","properties":{"license":{"$ref":"#/components/schemas/ProjectLicense"},"licenseKey":{"description":"The license key","format":"uuid","type":"string","example":"123e4567-e89b-12d3-a456-426614174000"}}}}}}}},"CreateConversationResponse":{"description":"Create a new conversation","content":{"application/json":{"schema":{"type":"object","properties":{"status":{"description":"The status of the response","enum":["error","success"],"type":"string","example":"success"},"data":{"$ref":"#/components/schemas/Conversation"}}}}}}},"securitySchemes":{"BearerToken":{"type":"http","scheme":"bearer","bearerFormat":"JWT"}}},"tags":[{"name":"Projects","description":"API Endpoints for Projects"},{"name":"Pages","description":"API Endpoints for Pages"},{"name":"Users","description":"API Endpoints for Users"},{"name":"Project Settings","description":"API Endpoints for Project Settings"},{"name":"Project Plugins","description":"API Endpoints for Project Plugins"},{"name":"Conversations","description":"API Endpoints for Conversations"},{"name":"Citations","description":"API Endpoints for Citations"}],"x-readme":{"explorer-enabled":true,"proxy-enabled":true,"samples-enabled":true}}
```

Contents of customgpt_cli/__init__.py:
```

```

Contents of customgpt_cli/cli.py:
```
#!/usr/bin/env python3
"""
CustomGPT CLI - Command line interface for CustomGPT SDK.

This module provides a command-line interface for interacting with the CustomGPT SDK,
allowing users to manage projects, conversations, and pages through simple commands.
"""

import argparse
import sys
import logging
import os
import time
import json
import ast

from typing import Optional, List, Dict, Any, Union
from pathlib import Path
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from customgpt_client import CustomGPT
from customgpt_client.types import File

def setup_logging() -> logging.Logger:
    """
    Configure and setup logging based on environment variables.
    
    Environment Variables:
        CUSTOMGPT_CLI_LOG_LEVEL: Logging level (default: INFO)
        CUSTOMGPT_CLI_LOG_FILE: Optional file path for logging output
        
    Returns:
        logging.Logger: Configured logger instance
    """
    # Get log level from environment variable
    log_level_name = os.environ.get('CUSTOMGPT_CLI_LOG_LEVEL', 'INFO').upper()
    log_level = getattr(logging, log_level_name, logging.INFO)
    
    # Configure handlers
    handlers = []
    log_file = os.environ.get('CUSTOMGPT_CLI_LOG_FILE')
    
    if log_file:
        handlers.append(logging.FileHandler(log_file))
    else:
        handlers.append(logging.StreamHandler(sys.stdout))
    
    # Setup basic configuration
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=handlers
    )
    
    # Get logger for this module
    logger = logging.getLogger(__name__)
    
    # Log initial configuration
    logger.debug("Log level set to: %s", log_level_name)
    if log_file:
        logger.debug("Logging to file: %s", log_file)
    
    return logger

# Setup logging once at module level
logger = setup_logging()

# Type aliases
ProjectID = str
SessionID = str
PageID = str
JsonDict = Dict[str, Any]

class CustomGPTCLI:
    def __init__(self):
        self.parser = self._create_parser()
        
    def _create_parser(self) -> argparse.ArgumentParser:
        # Create main parser
        parser = argparse.ArgumentParser(description='CustomGPT CLI Tool')
        parser.add_argument('--api-key', help='CustomGPT API Key (can also be set via CUSTOMGPT_API_KEY env var)', required=False)
        
        # Create subparsers for different commands
        subparsers = parser.add_subparsers(dest='command', help='Available commands')
        
        # Project commands
        self._add_project_commands(subparsers)
        
        # Conversation commands
        self._add_conversation_commands(subparsers)
        
        # Page commands
        self._add_page_commands(subparsers)

        self._add_citations_commands(subparsers)

        self._add_sources_commands(subparsers)

        self._add_reports_commands(subparsers)

        self._add_user_commands(subparsers)

        self._add_project_settings_commands(subparsers)

        self._add_plugins_commands(subparsers)

        self._add_limits_commands(subparsers)

        self._add_page_metadata_commands(subparsers)

        self._add_preview_commands(subparsers)
        
        return parser
    
    def _add_project_commands(self, subparsers):
        # Create project
        create_project = subparsers.add_parser('create-project', help='Create a new project')
        create_project.add_argument('--name', required=True, help='Project name')
        create_project.add_argument('--sitemap', help='Sitemap URL')
        create_project.add_argument('--file', help='Path to file')
        create_project.add_argument('--format', 
                        choices=['table', 'json', 'id-only'],
                        default='table',
                        help='Output format (default: table)')
        # Show project
        show_project = subparsers.add_parser('show-project', help='Show project details')
        show_project.add_argument('--project-id', required=True, help='Project ID')
        show_project.add_argument('--format', 
                                choices=['table', 'json', 'id-only'],
                                default='table',
                                help='Output format (default: table)')
                                
        # List projects
        list_projects = subparsers.add_parser('list-projects', help='List all projects')
        list_projects.add_argument('--page', type=int, default=1, help='Page number')
        list_projects.add_argument('--name-filter', help='Filter projects by name (supports regex)')
        list_projects.add_argument('--inactive-days', type=int, help='Filter projects inactive for X days')

        # Stats-based filters - both min and max
        list_projects.add_argument('--min-queries', type=int, help='Filter projects with at least X queries')
        list_projects.add_argument('--max-queries', type=int, help='Filter projects with at most X queries')
        list_projects.add_argument('--min-pages-found', type=int, help='Filter projects with at least X pages found')
        list_projects.add_argument('--max-pages-found', type=int, help='Filter projects with at most X pages found')
        list_projects.add_argument('--min-pages-crawled', type=int, help='Filter projects with at least X pages crawled')
        list_projects.add_argument('--max-pages-crawled', type=int, help='Filter projects with at most X pages crawled')
        list_projects.add_argument('--min-pages-indexed', type=int, help='Filter projects with at least X pages indexed')
        list_projects.add_argument('--max-pages-indexed', type=int, help='Filter projects with at most X pages indexed')
        list_projects.add_argument('--min-words-indexed', type=int, help='Filter projects with at least X words indexed')
        list_projects.add_argument('--max-words-indexed', type=int, help='Filter projects with at most X words indexed')
        list_projects.add_argument('--min-storage-credits', type=int, help='Filter projects with at least X storage credits used')
        list_projects.add_argument('--max-storage-credits', type=int, help='Filter projects with at most X storage credits used')
        list_projects.add_argument('--min-crawl-credits', type=int, help='Filter projects with at least X crawl credits used')
        list_projects.add_argument('--max-crawl-credits', type=int, help='Filter projects with at most X crawl credits used')
        list_projects.add_argument('--min-query-credits', type=int, help='Filter projects with at least X query credits used')
        list_projects.add_argument('--max-query-credits', type=int, help='Filter projects with at most X query credits used')
        list_projects.add_argument('--format', choices=['table', 'json', 'csv', 'id-only'], default='table', 
                                help='Output format')
                
        # Update project
        update_project = subparsers.add_parser('update-project', help='Update project')
        update_project.add_argument('--project-id', required=True, help='Project ID')
        update_project.add_argument('--name', help='New project name')
        update_project.add_argument('--is-shared', type=int, choices=[0, 1], help='Share status')
        update_project.add_argument('--format', 
                              choices=['table', 'json', 'id-only'],
                              default='table',
                              help='Output format (default: table)')

        # Add replicate project command
        replicate_project = subparsers.add_parser('replicate-project', 
                                                help='Replicate an existing project')
        replicate_project.add_argument('--project-id', 
                                    required=True,
                                    type=int,
                                    help='Project ID to replicate')
        replicate_project.add_argument('--format', 
                                    choices=['table', 'json', 'id-only'],
                                    default='table',
                                    help='Output format (default: table)')
        
        # Add get project stats command
        project_stats = subparsers.add_parser('project-stats',
                                        help='Get statistics for a project')
        project_stats.add_argument('--project-id',
                                required=True,
                                type=int,
                                help='Project ID')
        project_stats.add_argument('--format',
                                choices=['table', 'json', 'id-only'],
                                default='table',
                                help='Output format (default: table)')
       
        # Delete projects
        delete_projects = subparsers.add_parser('delete-projects', help='Delete multiple projects')
        delete_projects.add_argument('--project-ids', required=True, help='Comma-separated list of project IDs')
        delete_projects.add_argument('--dry-run', action='store_true', help='Show what would be deleted without actually deleting')
        delete_projects.add_argument('--force', action='store_true', help='Skip confirmation prompt')
    
    def _handle_default_format(self, response):
        try:
            response_data = json.loads(response.content)
        except json.JSONDecodeError:
            print("Error: Invalid JSON response from API")
            sys.exit(1)
        
        json_string = json.dumps(response_data, indent=2)
        if response.status_code not in [200, 201, 202, 204]:
            print(json_string)
            sys.exit(1)
        
        print(json_string)
        
    def _add_conversation_commands(self, subparsers):
            """Add all conversation-related command parsers."""
            
            # Create conversation
            create_conv = subparsers.add_parser('create-conversation', 
                                            help='Create a new conversation')
            create_conv.add_argument('--project-id', 
                                required=True, 
                                type=int,
                                help='Project ID')
            create_conv.add_argument('--name', 
                                required=True, 
                                help='Conversation name')
            create_conv.add_argument('--format', 
                                choices=['table', 'json', 'id-only'],
                                default='table',
                                help='Output format (default: table)')
            
            # Update conversation
            update_conv = subparsers.add_parser('update-conversation',
                                            help='Update an existing conversation')
            update_conv.add_argument('--project-id',
                                required=True,
                                type=int,
                                help='Project ID')
            update_conv.add_argument('--session-id',
                                required=True,
                                help='Session ID')
            update_conv.add_argument('--name',
                                required=True,
                                help='New conversation name')
            update_conv.add_argument('--format',
                                choices=['table', 'json', 'id-only'],
                                default='table',
                                help='Output format (default: table)')
            
            # Delete conversation
            delete_conv = subparsers.add_parser('delete-conversation',
                                            help='Delete a conversation')
            delete_conv.add_argument('--project-id',
                                required=True,
                                type=int,
                                help='Project ID')
            delete_conv.add_argument('--session-id',
                                required=True,
                                help='Session ID')
            delete_conv.add_argument('--force',
                                action='store_true',
                                help='Skip confirmation prompt')
            
            # Send message
            send_msg = subparsers.add_parser('send-message',
                                            help='Send a message to a conversation')
            send_msg.add_argument('--project-id',
                                required=True,
                                type=int,
                                help='Project ID')
            send_msg.add_argument('--session-id',
                                required=True,
                                help='Session ID')
            send_msg.add_argument('--prompt',
                                required=True,
                                help='Message prompt')
            send_msg.add_argument('--stream',
                                action='store_true',
                                help='Enable streaming responses')
            send_msg.add_argument('--persona',
                                help='Custom persona instructions')
            send_msg.add_argument('--model',
                                choices=['gpt-4-o', 'gpt-4-turbo', 'gpt-4', 'gpt-4o-mini', 
                                    'claude-3-sonnet', 'claude-3.5-sonnet'],
                                help='Chatbot model to use')
            send_msg.add_argument('--response-source',
                                choices=['default', 'own_content', 'openai_content'],
                                default='default',
                                help='Response source configuration')
            send_msg.add_argument('--format',
                                choices=['table', 'json', 'id-only'],
                                default='table',
                                help='Output format (default: table)')
            
            # Get messages
            get_msgs = subparsers.add_parser('get-messages',
                                            help='Retrieve messages from a conversation')
            get_msgs.add_argument('--project-id',
                                required=True,
                                type=int,
                                help='Project ID')
            get_msgs.add_argument('--session-id',
                                required=True,
                                help='Session ID')
            get_msgs.add_argument('--page',
                                type=int,
                                default=1,
                                help='Page number (default: 1)')
            get_msgs.add_argument('--order',
                                choices=['asc', 'desc'],
                                default='desc',
                                help='Sort order (default: desc)')
            get_msgs.add_argument('--format',
                                choices=['table', 'json', 'id-only'],
                                default='table',
                                help='Output format (default: table)')
            
            # Get specific message
            get_msg = subparsers.add_parser('get-message',
                                        help='Retrieve a specific message')
            get_msg.add_argument('--project-id',
                            required=True,
                            type=int,
                            help='Project ID')
            get_msg.add_argument('--session-id',
                            required=True,
                            help='Session ID')
            get_msg.add_argument('--prompt-id',
                            required=True,
                            type=int,
                            help='Message/Prompt ID')
            get_msg.add_argument('--format',
                            choices=['table', 'json', 'id-only'],
                            default='table',
                            help='Output format (default: table)')
            
            # Update message feedback
            update_feedback = subparsers.add_parser('update-message-feedback',
                                                help='Update feedback for a message')
            update_feedback.add_argument('--project-id',
                                    required=True,
                                    type=int,
                                    help='Project ID')
            update_feedback.add_argument('--session-id',
                                    required=True,
                                    help='Session ID')
            update_feedback.add_argument('--prompt-id',
                                    required=True,
                                    type=int,
                                    help='Message/Prompt ID')
            update_feedback.add_argument('--reaction',
                                    required=True,
                                    choices=['neutral', 'disliked', 'liked'],
                                    help='Feedback reaction')
            update_feedback.add_argument('--format',
                                    choices=['table', 'json', 'id-only'],
                                    default='table',
                                    help='Output format (default: table)')

    def _add_page_commands(self, subparsers):
        # Get pages
        get_pages = subparsers.add_parser('get-pages', help='Get project pages')
        get_pages.add_argument('--project-id', required=True, help='Project ID')
        get_pages.add_argument('--page', type=int, default=1, help='Page number to return')
        get_pages.add_argument('--duration', type=int, help='The duration of the projects to list. Defaults to 90 days.')
        get_pages.add_argument('--order', choices=['asc', 'desc'], default='desc', help='The order of the projects to list. Defaults to desc.')
        
        # Delete page
        delete_page = subparsers.add_parser('delete-page', help='Delete a page')
        delete_page.add_argument('--project-id', required=True, help='Project ID')
        delete_page.add_argument('--page-id', required=True, help='Page ID')
        
        # Reindex page
        reindex_page = subparsers.add_parser('reindex-page', help='Reindex a page')
        reindex_page.add_argument('--project-id', required=True, help='Project ID')
        reindex_page.add_argument('--page-id', required=True, help='Page ID')

    def _add_citations_commands(self, subparsers):
        """Add all citations-related command parsers."""
        # Get citations
        get_citations = subparsers.add_parser('get-citation', help='Get citation details')
        get_citations.add_argument('--project-id', required=True, help='Project ID')
        get_citations.add_argument('--citation-id', required=True, help='Citation ID')

    def _add_sources_commands(self, subparsers):
        """Add all sources-related command parsers."""
        # List sources
        list_sources = subparsers.add_parser(
            'list-sources', 
            help='Retrieve a list of all sources associated with a specific project',
            description='List all data sources linked to a given project. These sources serve as references or contexts for the project.'
        )
        list_sources.add_argument('--project-id', required=True, help='The unique identifier of the project whose sources you want to list')

        # Create source
        create_source = subparsers.add_parser(
            'create-source', 
            help='Create a new data source for a project',
            description='Add a new source to a project by specifying a sitemap URL or uploading a file. This enriches the project\'s information by incorporating additional data sources.'
        )
        create_source.add_argument('--project-id', required=True, help='The unique identifier of the project to add the source to')
        create_source.add_argument('--sitemap-path', help='URL of the sitemap to be added as a source (e.g., https://example.com/sitemap.xml)')
        create_source.add_argument('--file-data-retension', action='store_true', help='Retain file data for future reference')
        create_source.add_argument('--is-ocr-enabled', action='store_true', help='Enable Optical Character Recognition (OCR) for documents')
        create_source.add_argument('--is-anonymized', action='store_true', help='Anonymize the source data')
        create_source.add_argument('--file', help='Path to the file to be uploaded as a source')

        # Update source
        update_source = subparsers.add_parser(
            'update-source', 
            help='Update settings for an existing project source',
            description='Modify configuration of a specific data source, including JavaScript execution, refresh frequency, and page management settings.'
        )
        update_source.add_argument('--project-id', required=True, help='The unique identifier of the project')
        update_source.add_argument('--source-id', required=True, help='The unique identifier of the source to update')
        update_source.add_argument('--executive-js', action='store_true', help='Enable JavaScript execution for the source')
        update_source.add_argument('--data-refresh-frequency', 
            choices=['never', 'daily', 'weekly', 'monthly', 'advanced'], 
            default='never', 
            help='Frequency of data source refresh (default: never)'
        )
        update_source.add_argument('--create-new-pages', action='store_true', help='Automatically add new pages during source refresh')
        update_source.add_argument('--remove-unexist-pages', action='store_true', help='Automatically remove non-existent pages during source refresh')
        update_source.add_argument('--refresh-existing-pages', 
            choices=['never', 'always', 'if_updated'], 
            default='never', 
            help='Policy for refreshing existing pages (default: never)'
        )
        update_source.add_argument('--refresh-schedule', help='Custom refresh schedule for advanced frequency (JSON format)')

        # Delete source
        delete_source = subparsers.add_parser(
            'delete-source', 
            help='Delete a specific source from a project',
            description='Permanently remove a data source from the specified project.'
        )
        delete_source.add_argument('--project-id', required=True, help='The unique identifier of the project')
        delete_source.add_argument('--source-id', required=True, help='The unique identifier of the source to delete')

        # Sync source
        sync_source = subparsers.add_parser(
            'sync-source', 
            help='Perform an instant sync of the specified source',
            description='Immediately synchronize a specific source, updating its content in real-time.'
        )
        sync_source.add_argument('--project-id', required=True, help='The unique identifier of the project')
        sync_source.add_argument('--source-id', required=True, help='The unique identifier of the source to sync')

    def _add_reports_commands(self, subparsers):
        """Add all reports-related command parsers."""
        # Get traffic report
        get_traffic_report = subparsers.add_parser('get-traffic-report', help='Get traffic report')
        get_traffic_report.add_argument('--project-id', required=True, help='Project ID')
        get_traffic_report.add_argument('--filters', help='Filters')

        # Get queries report
        get_queries_report = subparsers.add_parser('get-queries-report', help='Get queries report')
        get_queries_report.add_argument('--project-id', required=True, help='Project ID')
        get_queries_report.add_argument('--filters', help='Filters')

        # Get conversations report
        get_conversations_report = subparsers.add_parser('get-conversations-report', help='Get conversations report')
        get_conversations_report.add_argument('--project-id', required=True, help='Project ID')
        get_conversations_report.add_argument('--filters', help='Filters')

        # Get analysis report
        get_analysis_report = subparsers.add_parser('get-analysis-report', help='Get analysis report')
        get_analysis_report.add_argument('--project-id', required=True, help='Project ID')
        get_analysis_report.add_argument('--filters', help='Filters')
        get_analysis_report.add_argument('--interval', choices=['daily', 'weekly'], default='weekly', help='Interval')

    def _add_user_commands(self, subparsers):
        """Add all user-related command parsers."""
        # Get user
        get_user = subparsers.add_parser('get-user', help='Get user')

    def _add_project_settings_commands(self, subparsers):
        """Add all project settings-related command parsers."""
        # Get project settings
        get_project_settings = subparsers.add_parser('get-project-settings', help='Get project settings')
        get_project_settings.add_argument('--project-id', required=True, help='Project ID')

        # Update project settings
        update_project_settings = subparsers.add_parser('update-project-settings', help='Update project settings')
        update_project_settings.add_argument('--project-id', required=True, help='Project ID')
        update_project_settings.add_argument('--chatbot-avatar', help='Chatbot avatar')
        update_project_settings.add_argument('--chatbot-background', help='Chatbot background')
        update_project_settings.add_argument('--default-prompt', help='Default prompt')
        update_project_settings.add_argument('--example-questions', help='Example questions')
        update_project_settings.add_argument('--response-source', help='Response source')
        update_project_settings.add_argument('--chatbot-msg-lang', help='Chatbot msg lang')
        update_project_settings.add_argument('--chatbot-color', help='Chatbot color')
        update_project_settings.add_argument('--chatbot-toolbar-color', help='Chatbot toolbar color')
        update_project_settings.add_argument('--persona-instructions', help='Persona instructions')
        update_project_settings.add_argument('--citations-answer-source-label-msg', help='Citations answer source label msg')
        update_project_settings.add_argument('--citations-sources-label-msg', help='Citations sources label msg')
        update_project_settings.add_argument('--hang-in-there-msg', help='Hang in there msg')
        update_project_settings.add_argument('--chatbot-siesta-msg', help='Chatbot siesta msg')
        update_project_settings.add_argument('--is-loading-indicator-enabled', action='store_true', help='Is loading indicator enabled')
        update_project_settings.add_argument('--enable-citations', help='Enable citations')
        update_project_settings.add_argument('--enable-feedbacks', action='store_true', help='Enable feedbacks')
        update_project_settings.add_argument('--citations-view-type', choices=['user', 'show', 'hide'], default='user', help='Citations view type')
        update_project_settings.add_argument('--no-answer-message', help='No answer message')
        update_project_settings.add_argument('--ending-message', help='Ending message')
        update_project_settings.add_argument('--remove-branding', action='store_true', help='Remove branding')
        update_project_settings.add_argument('--enable-recaptcha-for-public-chatbots', action='store_true', help='Enable recaptcha for public chatbots')
        update_project_settings.add_argument('--chatbot-model', choices=['gpt-4-o', 'gpt-4-turbo', 'gpt-4', 'gpt-4o-mini', 'claude-3-sonnet', 'claude-3.5-sonnet'], default='gpt-4-o', help='Chatbot model')
        update_project_settings.add_argument('--is-selling-enabled', action='store_true', help='Is selling enabled')
        update_project_settings.add_argument('--license-slug', help='License slug')
        update_project_settings.add_argument('--selling-url', help='Selling URL')
    
    def _add_plugins_commands(self, subparsers):
        """Add all plugins-related command parsers."""
        # List plugins
        list_plugins = subparsers.add_parser('list-plugins', help='List plugins')
        list_plugins.add_argument('--project-id', required=True, help='Project ID')
        # Create plugin
        create_plugin = subparsers.add_parser('create-plugin', help='Create plugin')
        create_plugin.add_argument('--project-id', required=True, help='Project ID')
        create_plugin.add_argument('--model-name', required=True, help='Model name')
        create_plugin.add_argument('--human-name', required=True, help='Human name')
        create_plugin.add_argument('--keywords', required=True, help='Keywords')
        create_plugin.add_argument('--description', required=True, help='Description')
        create_plugin.add_argument('--is-active', action='store_true', help='Is active')

        # Update plugin
        update_plugin = subparsers.add_parser('update-plugin', help='Update plugin')
        update_plugin.add_argument('--project-id', required=True, help='Project ID')
        update_plugin.add_argument('--model-name', required=True, help='Model name')
        update_plugin.add_argument('--human-name', required=True, help='Human name')
        update_plugin.add_argument('--keywords', required=True, help='Keywords')
        update_plugin.add_argument('--description', required=True, help='Description')
        update_plugin.add_argument('--is-active', action='store_true', help='Is active')        

    def _add_limits_commands(self, subparsers):
        """Add all limits-related command parsers."""
        # Get limits
        get_limits = subparsers.add_parser('get-limits', help='Get limits')

    def _add_page_metadata_commands(self, subparsers):
        """Add all page metadata-related command parsers."""
        # Get page metadata
        get_page_metadata = subparsers.add_parser('get-page-metadata', help='Get page metadata')
        get_page_metadata.add_argument('--project-id', required=True, help='Project ID')
        get_page_metadata.add_argument('--page-id', required=True, help='Page ID')

        # Update page metadata
        update_page_metadata = subparsers.add_parser('update-page-metadata', help='Update page metadata')
        update_page_metadata.add_argument('--project-id', required=True, help='Project ID')
        update_page_metadata.add_argument('--page-id', required=True, help='Page ID')
        update_page_metadata.add_argument('--title', help='Title')
        update_page_metadata.add_argument('--url', help='Url')
        update_page_metadata.add_argument('--description', help='Description')
        update_page_metadata.add_argument('--image', help='Image')

    def _add_preview_commands(self, subparsers):
        """Add all preview-related command parsers."""
        # Preview file
        preview_file = subparsers.add_parser('preview-file', help='Preview file')
        preview_file.add_argument('--id', required=True, help='Page Id')

    def _handle_rate_limit(self, response, retry_count, max_retries):
        """
        Handle rate limiting for API responses.
        
        Args:
            response: API response object
            retry_count: Current retry attempt number
            max_retries: Maximum number of retry attempts
            
        Returns:
            tuple: (should_retry, retry_after)
            - should_retry: Boolean indicating if retry should be attempted
            - retry_after: Number of seconds to wait before retry
        """
        if response.status_code == 429:
            retry_after = int(response.headers.get('Retry-After', 30))
            remaining = response.headers.get('X-RateLimit-Remaining', 'unknown')
            reset_time = response.headers.get('X-RateLimit-Reset', 'unknown')
            
            logger.warning(f"Rate limited. Remaining requests: {remaining}, "
                        f"Reset time: {reset_time}, "
                        f"Retry after: {retry_after}s")
            
            if retry_count < max_retries:
                print(f"Rate limited, waiting {retry_after} seconds before retry...")
                return True, retry_after
            
            return False, 0
        return False, 0

    def _make_api_call(self, api_func, max_retries=3, **kwargs):
        """
        Make an API call with retry logic for rate limiting.
        
        Args:
            api_func: Function to call (e.g., CustomGPT.Project.list)
            max_retries: Maximum number of retries for rate-limited requests
            **kwargs: Arguments to pass to the API function
            
        Returns:
            API response or None if failed after retries
        """
        retry_count = 0
        while retry_count <= max_retries:
            try:
                response = api_func(**kwargs)
                
                should_retry, retry_after = self._handle_rate_limit(response, retry_count, max_retries)
                if should_retry:
                    time.sleep(retry_after)
                    retry_count += 1
                    continue
                
                return response
            except AttributeError as e:
                return None
            except Exception as e:
                logger.error(f"Exception in API call to {api_func.__name__}: {str(e)}", exc_info=True)
                return None
                
        return None

    def _get_project_stats(self, project_id, max_retries=3):
        """Get project stats using standard API call handler."""
        response = self._make_api_call(
            CustomGPT.Project.stats,
            max_retries=max_retries,
            project_id=project_id
        )
        return response.parsed.data if response and hasattr(response, 'parsed') else None

    def _get_all_projects(self, max_retries=3):
        """Fetch all projects across multiple pages using standard API call handler."""
        all_projects = []
        page = 1
        
        while True:
            response = self._make_api_call(
                CustomGPT.Project.list,
                max_retries=max_retries,
                page=page
            )
            
            if not response or not hasattr(response, 'parsed') or not response.parsed or \
            not hasattr(response.parsed, 'data') or not response.parsed.data or \
            not hasattr(response.parsed.data, 'data'):
                logger.warning(f"Incomplete or invalid response on page {page} - stopping pagination")
                break
                
            projects = response.parsed.data.data
            if not projects:
                break
                
            all_projects.extend(projects)
            
            if hasattr(response.parsed.data, 'total') and len(all_projects) >= response.parsed.data.total:
                break
                
            page += 1
            
        return all_projects

    def _delete_single_project(self, project, max_retries=3):
        """Delete a single project using standard API call handler."""
        response = self._make_api_call(
            CustomGPT.Project.delete,
            max_retries=max_retries,
            project_id=project.id
        )
        
        if not response:
            return False
            
        deleted_status = (response.parsed and 
                        hasattr(response.parsed, 'data') and 
                        response.parsed.data and 
                        hasattr(response.parsed.data, 'deleted') and 
                        response.parsed.data.deleted)
        
        if not deleted_status:
            logger.warning(f"Failed to delete project {project.id}. Response: {response}")
        
        return deleted_status

    def _parse_datetime(self, dt_value: Any) -> Optional[datetime]:
        """Safely parse a datetime value that might be a string or datetime object."""
        if isinstance(dt_value, datetime):
            return dt_value.replace(tzinfo=timezone.utc) if dt_value.tzinfo is None else dt_value
        elif isinstance(dt_value, str):
            try:
                # Try parsing ISO format
                dt = datetime.fromisoformat(dt_value.replace('Z', '+00:00'))
                return dt.replace(tzinfo=timezone.utc) if dt.tzinfo is None else dt
            except ValueError:
                try:
                    # Try parsing common datetime formats
                    formats = [
                        '%Y-%m-%dT%H:%M:%S.%f%z',
                        '%Y-%m-%d %H:%M:%S',
                        '%Y-%m-%dT%H:%M:%S.%fZ'
                    ]
                    for fmt in formats:
                        try:
                            dt = datetime.strptime(dt_value, fmt)
                            return dt.replace(tzinfo=timezone.utc) if dt.tzinfo is None else dt
                        except ValueError:
                            continue
                    logger.warning(f"Could not parse datetime value: {dt_value}")
                    return None
                except Exception as e:
                    logger.warning(f"Error parsing datetime {dt_value}: {e}")
                    return None
        return None

    def _format_project_output(self, projects, format_type='table'):
        """
        Format project data for output.
        
        Args:
            projects: List of project objects
            format_type: Output format ('table', 'json', 'csv', or 'id-only')
            
        Returns:
            str: Formatted output string
        """
        if format_type == 'json':
            import json
            from datetime import datetime
            
            class DateTimeEncoder(json.JSONEncoder):
                def default(self, obj):
                    if isinstance(obj, datetime):
                        return obj.isoformat()
                    return super().default(obj)
            
            project_data = []
            for p in projects:
                project_dict = {
                    'id': p.id,
                    'project_name': p.project_name,
                    'created_at': p.created_at,
                    'updated_at': p.updated_at,
                    'type': p.type,
                    'is_chat_active': p.is_chat_active,
                    'is_shared': p.is_shared,
                    'sitemap_path': p.sitemap_path,
                    'stats': None
                }
                
                stats = self._get_project_stats(p.id)
                if stats:
                    project_dict['stats'] = {
                        'pages_found': getattr(stats, 'pages_found', 0),
                        'pages_crawled': getattr(stats, 'pages_crawled', 0),
                        'pages_indexed': getattr(stats, 'pages_indexed', 0),
                        'total_words_indexed': getattr(stats, 'total_words_indexed', 0),
                        'total_storage_credits_used': getattr(stats, 'total_storage_credits_used', 0),
                        'crawl_credits_used': getattr(stats, 'crawl_credits_used', 0),
                        'query_credits_used': getattr(stats, 'query_credits_used', 0),
                        'total_queries': getattr(stats, 'total_queries', 0)
                    }
                
                project_data.append(project_dict)
                
            return json.dumps(project_data, indent=2, cls=DateTimeEncoder)
        
        elif format_type == 'id-only':
            return '\n'.join(str(p.id) for p in projects)
        
        elif format_type == 'csv':
            import csv
            from io import StringIO
            from datetime import datetime
            
            # Define CSV headers including both project info and stats
            headers = [
                'ID', 'Name', 'Type', 'Created At', 'Updated At', 'Is Chat Active', 
                'Is Shared', 'Sitemap Path', 'Pages Found', 'Pages Crawled', 
                'Pages Indexed', 'Words Indexed', 'Storage Credits Used', 
                'Crawl Credits Used', 'Query Credits Used', 'Total Queries'
            ]
            
            # Create StringIO to write CSV data
            output = StringIO()
            writer = csv.writer(output)
            writer.writerow(headers)
            
            # Write data rows
            for p in projects:
                # Get stats with retry logic
                stats = self._get_project_stats(p.id)
                
                # Format timestamps
                created_at = p.created_at.isoformat() if isinstance(p.created_at, datetime) else p.created_at
                updated_at = p.updated_at.isoformat() if isinstance(p.updated_at, datetime) else p.updated_at
                
                # Base project data
                row = [
                    p.id,
                    p.project_name,
                    p.type,
                    created_at,
                    updated_at,
                    p.is_chat_active,
                    p.is_shared,
                    p.sitemap_path or ''
                ]
                
                # Add stats data if available
                if stats:
                    row.extend([
                        getattr(stats, 'pages_found', 0),
                        getattr(stats, 'pages_crawled', 0),
                        getattr(stats, 'pages_indexed', 0),
                        getattr(stats, 'total_words_indexed', 0),
                        getattr(stats, 'total_storage_credits_used', 0),
                        getattr(stats, 'crawl_credits_used', 0),
                        getattr(stats, 'query_credits_used', 0),
                        getattr(stats, 'total_queries', 0)
                    ])
                else:
                    row.extend(['N/A'] * 8)  # Add N/A for missing stats
                
                writer.writerow(row)
            
            return output.getvalue()
        
        else:  # table format
            from tabulate import tabulate
            headers = [
                'ID', 'Name', 'Created At', 'Updated At', 'Type',
                'Pages Found', 'Pages Crawled', 'Pages Indexed',
                'Words Indexed', 'Storage Credits', 'Crawl Credits',
                'Query Credits', 'Total Queries'
            ]
            rows = []
            for p in projects:
                stats = self._get_project_stats(p.id)  # Use the retry-enabled method
                if stats:
                    stats_values = [
                        getattr(stats, 'pages_found', 'N/A'),
                        getattr(stats, 'pages_crawled', 'N/A'),
                        getattr(stats, 'pages_indexed', 'N/A'),
                        getattr(stats, 'total_words_indexed', 'N/A'),
                        getattr(stats, 'total_storage_credits_used', 'N/A'),
                        getattr(stats, 'crawl_credits_used', 'N/A'),
                        getattr(stats, 'query_credits_used', 'N/A'),
                        getattr(stats, 'total_queries', 'N/A')
                    ]
                else:
                    stats_values = ['N/A'] * 8
                
                rows.append([
                    p.id, 
                    p.project_name, 
                    p.created_at, 
                    p.updated_at, 
                    p.type,
                    *stats_values
                ])
            return tabulate(rows, headers=headers, tablefmt='grid')

    def _filter_projects(self, projects, name_filter=None, inactive_days=None, **stats_filters):
        """
        Filter projects based on various criteria including detailed stats.
        
        Args:
            projects: List of projects to filter
            name_filter: Regex pattern to filter project names
            inactive_days: Filter projects inactive for X days
            **stats_filters: Stats-based filters including:
                - min_queries/max_queries: Filter by number of queries
                - min_pages_found/max_pages_found: Filter by pages found
                - min_pages_crawled/max_pages_crawled: Filter by pages crawled
                - min_pages_indexed/max_pages_indexed: Filter by pages indexed
                - min_words_indexed/max_words_indexed: Filter by words indexed
                - min_storage_credits/max_storage_credits: Filter by storage credits
                - min_crawl_credits/max_crawl_credits: Filter by crawl credits
                - min_query_credits/max_query_credits: Filter by query credits
        
        Returns:
            list: Filtered list of projects
        """
        import re

        filtered_projects = projects

        if name_filter:
            pattern = re.compile(name_filter, re.IGNORECASE)
            filtered_projects = [p for p in filtered_projects 
                            if pattern.search(p.project_name)]

        if inactive_days is not None:
            cutoff_date = datetime.now(timezone.utc) - timedelta(days=inactive_days)
            filtered_projects = [
                p for p in filtered_projects 
                if (parsed_date := self._parse_datetime(p.updated_at)) is not None 
                and parsed_date < cutoff_date
            ]

        # Stats-based filtering
        stat_field_mappings = {
            'min_queries': ('total_queries', 0, float('inf')),
            'max_queries': ('total_queries', 0, float('inf')),
            'min_pages_found': ('pages_found', 0, float('inf')),
            'max_pages_found': ('pages_found', 0, float('inf')),
            'min_pages_crawled': ('pages_crawled', 0, float('inf')),
            'max_pages_crawled': ('pages_crawled', 0, float('inf')),
            'min_pages_indexed': ('pages_indexed', 0, float('inf')),
            'max_pages_indexed': ('pages_indexed', 0, float('inf')),
            'min_words_indexed': ('total_words_indexed', 0, float('inf')),
            'max_words_indexed': ('total_words_indexed', 0, float('inf')),
            'min_storage_credits': ('total_storage_credits_used', 0, float('inf')),
            'max_storage_credits': ('total_storage_credits_used', 0, float('inf')),
            'min_crawl_credits': ('crawl_credits_used', 0, float('inf')),
            'max_crawl_credits': ('crawl_credits_used', 0, float('inf')),
            'min_query_credits': ('query_credits_used', 0, float('inf')),
            'max_query_credits': ('query_credits_used', 0, float('inf')),
        }

        # Remove None values from stats_filters
        active_filters = {k: v for k, v in stats_filters.items() if v is not None}
        
        if active_filters:
            filtered_projects_with_stats = []
            for project in filtered_projects:
                try:
                    stats = self._get_project_stats(project.id)
                    if not stats:
                        continue
                        
                    include_project = True
                    
                    # Track min and max values for each stat field
                    stat_ranges = {}
                    
                    # First pass: collect min/max values for each stat field
                    for filter_name, filter_value in active_filters.items():
                        if filter_name not in stat_field_mappings:
                            continue
                            
                        stat_field, min_default, max_default = stat_field_mappings[filter_name]
                        stat_value = getattr(stats, stat_field, None)
                        
                        if stat_value is None:
                            include_project = False
                            break
                            
                        # Initialize or update stat ranges
                        if stat_field not in stat_ranges:
                            stat_ranges[stat_field] = {
                                'min': min_default,
                                'max': max_default,
                                'value': stat_value
                            }
                        
                        # Update min/max bounds based on filters
                        if filter_name.startswith('min_'):
                            stat_ranges[stat_field]['min'] = max(stat_ranges[stat_field]['min'], filter_value)
                        elif filter_name.startswith('max_'):
                            stat_ranges[stat_field]['max'] = min(stat_ranges[stat_field]['max'], filter_value)
                    
                    # Second pass: check if value is within min/max range for each stat
                    for stat_field, ranges in stat_ranges.items():
                        if not (ranges['min'] <= ranges['value'] <= ranges['max']):
                            include_project = False
                            break
                    
                    if include_project:
                        filtered_projects_with_stats.append(project)
                except Exception as e:
                    logger.warning(f"Could not get stats for project {project.id}: {e}")
            
            filtered_projects = filtered_projects_with_stats

        return filtered_projects

    def _delete_single_project(self, project, max_retries=3):
        """
        Delete a single project with retry logic for rate limiting.
        
        Args:
            project: Project object containing id and project_name
            max_retries: Maximum number of retries for rate-limited requests
            
        Returns:
            bool: True if deletion was successful, False otherwise
        """
        retry_count = 0
        while retry_count <= max_retries:
            try:
                response = CustomGPT.Project.delete(project_id=project.id)
                
                # Log the response
                logger.debug(f"Delete response for project {project.id}:")
                logger.debug(f"Response status code: {response.status_code}")
                logger.debug(f"Response headers: {response.headers}")
                logger.debug(f"Response parsed: {response.parsed}")
                
                # Handle rate limiting
                if response.status_code == 429:
                    retry_after = int(response.headers.get('Retry-After', 30))
                    remaining = response.headers.get('X-RateLimit-Remaining', 'unknown')
                    reset_time = response.headers.get('X-RateLimit-Reset', 'unknown')
                    
                    logger.warning(f"Rate limited when deleting project {project.id}. "
                                f"Remaining requests: {remaining}, "
                                f"Reset time: {reset_time}, "
                                f"Retry after: {retry_after}s")
                    
                    if retry_count < max_retries:
                        logger.warning(f"Rate limited, waiting {retry_after} seconds before retry...")
                        time.sleep(retry_after)
                        retry_count += 1
                        continue
                    return False
                
                # Get deletion status
                deleted_status = (response.parsed and 
                                hasattr(response.parsed, 'data') and 
                                response.parsed.data and 
                                hasattr(response.parsed.data, 'deleted') and 
                                response.parsed.data.deleted)
                
                if not deleted_status:
                    logger.warning(f"Failed to delete project {project.id}. Response: {response}")
                
                return deleted_status

            except Exception as e:
                logger.error(f"Exception deleting project {project.id}: {str(e)}", exc_info=True)
                return False

    def _handle_create_project(self, args):
        """
        Handle the create-project command with improved error handling and output formatting.
        
        Args:
            args: Parsed command line arguments
            
        Returns:
            None - prints output to stdout
        """
        try:
            # Validate input requirements
            if not args.sitemap and not args.file:
                print("Error: Either --sitemap or --file must be provided")
                sys.exit(1)
                
            if args.sitemap and args.file:
                print("Error: Cannot provide both --sitemap and --file. Please choose one.")
                sys.exit(1)
                
            # Prepare creation arguments
            create_args = {'project_name': args.name}
            
            # Handle sitemap path
            if args.sitemap:
                create_args['sitemap_path'] = args.sitemap
                logger.debug(f"Creating project with sitemap: {args.sitemap}")
                
            # Handle file upload
            elif args.file:
                try:
                    file_path = Path(args.file)
                    if not file_path.exists():
                        print(f"Error: File not found: {args.file}")
                        sys.exit(1)
                        
                    if not file_path.is_file():
                        print(f"Error: Not a file: {args.file}")
                        sys.exit(1)
                        
                    with open(file_path, 'rb') as f:
                        file_content = f.read()
                    create_args['file'] = File(payload=file_content, file_name=str(file_path.name))
                    logger.debug(f"Creating project with file: {file_path.name}")
                    
                except Exception as e:
                    print(f"Error reading file {args.file}: {str(e)}")
                    logger.error(f"File read error", exc_info=True)
                    sys.exit(1)
            
            # Make API call with retry logic
            result = self._make_api_call(CustomGPT.Project.create, **create_args)
            
            if not result or not hasattr(result, 'parsed'):
                print("Error: Failed to create project - invalid API response")
                sys.exit(1)
                
            # Check for error response
            if hasattr(result, 'status_code') and result.status_code >= 400:
                error_msg = "Unknown error"
                if hasattr(result.parsed, 'message'):
                    error_msg = result.parsed.message
                elif hasattr(result.parsed, 'error'):
                    error_msg = result.parsed.error
                    
                print(f"Error creating project: {error_msg}")
                sys.exit(1)
                
            # Get response JSON content
            try:
                import json
                response_data = json.loads(result.content)
            except json.JSONDecodeError:
                print("Error: Invalid JSON response from API")
                sys.exit(1)
                
            if 'data' not in response_data:
                print("Error: Unexpected API response format - missing data field")
                sys.exit(1)
                
            project_data = response_data['data']
            
            # Format output based on requested format
            if hasattr(args, 'format'):
                if args.format == 'id-only':
                    print(project_data.get('id', 'N/A'))
                elif args.format == 'json':
                    # For JSON output, return the complete response data
                    print(json.dumps(response_data, indent=2))
                else:  # default format - human readable
                    print(f"Successfully created project:")
                    print(f"  ID: {project_data.get('id', 'N/A')}")
                    print(f"  Name: {project_data.get('project_name', 'N/A')}")
                    print(f"  Type: {project_data.get('type', 'N/A')}")
                    if project_data.get('sitemap_path'):
                        print(f"  Sitemap: {project_data['sitemap_path']}")
                    print(f"  Created at: {project_data.get('created_at', 'N/A')}")
            else:
                # Basic output if format not specified
                print(f"Successfully created project {project_data.get('id', 'N/A')}: {project_data.get('project_name', 'N/A')}")
                
        except Exception as e:
            logger.error("Unexpected error in create project", exc_info=True)
            print(f"Error: {str(e)}")
            sys.exit(1)

    def _handle_show_project(self, args):
        """
        Handle the show-project command with output formatting.
        
        Args:
            args: Parsed command line arguments
        """
        try:
            result = self._make_api_call(CustomGPT.Project.get, project_id=args.project_id)
            
            if not result:
                print("Error: Failed to get project - no API response")
                sys.exit(1)
                
            # Check for error response
            if result.status_code >= 400:
                error_msg = "Unknown error"
                try:
                    response_data = json.loads(result.content)
                    error_msg = response_data.get('message', response_data.get('error', 'Unknown error'))
                except:
                    pass
                print(f"Error getting project: {error_msg}")
                sys.exit(1)
                
            # Get response JSON content
            try:
                response_data = json.loads(result.content)
            except json.JSONDecodeError:
                print("Error: Invalid JSON response from API")
                sys.exit(1)
                
            if 'data' not in response_data:
                print("Error: Unexpected API response format - missing data field")
                sys.exit(1)
                
            project_data = response_data['data']
            
            # Format output based on requested format
            if args.format == 'id-only':
                print(project_data.get('id', 'N/A'))
            elif args.format == 'json':
                # For JSON output, return the complete response data
                print(json.dumps(response_data, indent=2))
            else:  # default table format
                print("Project Details:")
                
                # Group the fields by category for better organization
                code_fields = ['embed_code', 'live_chat_code']  # Fields containing code snippets
                url_fields = ['shareable_link']  # Fields containing URLs
                skip_fields = []  # Fields to skip if needed
                
                # First print regular fields (not code or urls)
                for key, value in sorted(project_data.items()):
                    if key not in code_fields + url_fields + skip_fields:
                        # Convert boolean values to Yes/No for better readability
                        if isinstance(value, bool):
                            value = "Yes" if value else "No"
                        # Handle null values
                        elif value is None:
                            value = "N/A"
                            
                        # Format key for display (convert snake_case to Title Case)
                        display_key = key.replace('_', ' ').title()
                        print(f"  {display_key}: {value}")
                
                # Then print URL fields
                url_values = [(key, value) for key, value in project_data.items() 
                            if key in url_fields and value]
                if url_values:
                    print("\nShare Information:")
                    for key, value in url_values:
                        display_key = key.replace('_', ' ').title()
                        print(f"  {display_key}: {value}")
                
                # Finally print code fields
                code_values = [(key, value) for key, value in project_data.items() 
                            if key in code_fields and value]
                if code_values:
                    for key, value in code_values:
                        print(f"\n{key.replace('_', ' ').title()}:")
                        print(f"  {value}")
                
        except Exception as e:
            logger.error("Unexpected error in show project", exc_info=True)
            print(f"Error: {str(e)}")
            sys.exit(1)
            
    def _handle_update_project(self, args):
        """
        Handle the update-project command with improved error handling and output formatting.
        
        Args:
            args: Parsed command line arguments
        """
        try:
            # Prepare update arguments
            update_args = {'project_id': args.project_id}
            if args.name:
                update_args['project_name'] = args.name
            if args.is_shared is not None:
                update_args['is_shared'] = args.is_shared
                
            # Make API call with retry logic
            result = self._make_api_call(CustomGPT.Project.update, **update_args)
            
            if not result:
                print("Error: Failed to update project - no API response")
                sys.exit(1)
                
            # Check for error response
            if result.status_code >= 400:
                error_msg = "Unknown error"
                try:
                    response_data = json.loads(result.content)
                    error_msg = response_data.get('message', response_data.get('error', 'Unknown error'))
                except:
                    pass
                print(f"Error updating project: {error_msg}")
                sys.exit(1)
                
            # Get response JSON content
            try:
                response_data = json.loads(result.content)
            except json.JSONDecodeError:
                print("Error: Invalid JSON response from API")
                sys.exit(1)
                
            if 'data' not in response_data:
                print("Error: Unexpected API response format - missing data field")
                sys.exit(1)
                
            project_data = response_data['data']
            
            # Format output based on requested format
            if args.format == 'id-only':
                print(project_data.get('id', 'N/A'))
            elif args.format == 'json':
                # For JSON output, return the complete response data
                print(json.dumps(response_data, indent=2))
            else:  # default table format
                print(f"Successfully updated project:")
                print(f"  ID: {project_data.get('id', 'N/A')}")
                print(f"  Name: {project_data.get('project_name', 'N/A')}")
                print(f"  Type: {project_data.get('type', 'N/A')}")
                print(f"  Is Shared: {project_data.get('is_shared', 'N/A')}")
                print(f"  Updated at: {project_data.get('updated_at', 'N/A')}")
                
        except Exception as e:
            logger.error("Unexpected error in update project", exc_info=True)
            print(f"Error: {str(e)}")
            sys.exit(1)
    
    def _handle_project_commands(self, args):
        """Handle all project-related commands."""
        if args.command == 'create-project':
            self._handle_create_project(args)
        elif args.command == 'show-project':
            self._handle_show_project(args)             
        elif args.command == 'list-projects':
            all_projects = self._get_all_projects()
            
            if not all_projects:
                print("No projects found or unable to retrieve projects")
                return
                
            try:
                filtered_projects = self._filter_projects(
                    all_projects,
                    name_filter=args.name_filter,
                    inactive_days=args.inactive_days,
                    min_queries=args.min_queries,
                    max_queries=args.max_queries,
                    min_pages_found=args.min_pages_found,
                    min_pages_crawled=args.min_pages_crawled,
                    min_pages_indexed=args.min_pages_indexed,
                    min_words_indexed=args.min_words_indexed,
                    min_storage_credits=args.min_storage_credits,
                    min_crawl_credits=args.min_crawl_credits,
                    min_query_credits=args.min_query_credits
                )
                print(self._format_project_output(filtered_projects, args.format))
            except Exception as e:
                logger.warning(f"Error processing projects: {str(e)}")
                print("Error processing projects - displaying unfiltered results:")
                print(self._format_project_output(all_projects, args.format))
                
        elif args.command == 'update-project':
            self._handle_update_project(args)

        elif args.command == 'replicate-project':
            result = self._make_api_call(
                CustomGPT.Project.replicate,
                project_id=args.project_id
            )
            
            if not result:
                print("Error: Failed to replicate project")
                sys.exit(1)
                
            try:
                response_data = json.loads(result.content)
                if args.format == 'json':
                    print(json.dumps(response_data, indent=2))
                elif args.format == 'id-only':
                    print(response_data.get('data', {}).get('id', 'N/A'))
                else:  # table format
                    project_data = response_data.get('data', {})
                    print(f"Successfully replicated project:")
                    print(f"  ID: {project_data.get('id', 'N/A')}")
                    print(f"  Name: {project_data.get('project_name', 'N/A')}")
                    print(f"  Type: {project_data.get('type', 'N/A')}")
                    print(f"  Created at: {project_data.get('created_at', 'N/A')}")
            except Exception as e:
                print(f"Error parsing response: {str(e)}")
                sys.exit(1)
                
        elif args.command == 'project-stats':
            result = self._make_api_call(
                CustomGPT.Project.stats,
                project_id=args.project_id
            )
            
            if not result:
                print("Error: Failed to get project stats")
                sys.exit(1)
                
            try:
                response_data = json.loads(result.content)
                if args.format == 'json':
                    print(json.dumps(response_data, indent=2))
                elif args.format == 'id-only':
                    print(args.project_id)
                else:  # table format
                    stats_data = response_data.get('data', {})
                    print(f"Project Statistics:")
                    print(f"  Pages Found: {stats_data.get('pages_found', 'N/A')}")
                    print(f"  Pages Crawled: {stats_data.get('pages_crawled', 'N/A')}")
                    print(f"  Pages Indexed: {stats_data.get('pages_indexed', 'N/A')}")
                    print(f"  Total Words Indexed: {stats_data.get('total_words_indexed', 'N/A')}")
                    print(f"  Storage Credits Used: {stats_data.get('total_storage_credits_used', 'N/A')}")
                    print(f"  Crawl Credits Used: {stats_data.get('crawl_credits_used', 'N/A')}")
                    print(f"  Query Credits Used: {stats_data.get('query_credits_used', 'N/A')}")
                    print(f"  Total Queries: {stats_data.get('total_queries', 'N/A')}")
            except Exception as e:
                print(f"Error parsing response: {str(e)}")
                sys.exit(1)

        elif args.command == 'delete-projects':
            # Get projects to delete
            projects_to_delete = []
            
            if args.project_ids:
                project_ids = [int(id.strip()) for id in args.project_ids.split(',')]
                all_projects = self._get_all_projects()
                projects_to_delete = [p for p in all_projects if p.id in project_ids]
                
                # Log which IDs were not found
                found_ids = {p.id for p in projects_to_delete}
                not_found_ids = set(project_ids) - found_ids
                if not_found_ids:
                    print(f"Warning: Could not find projects with IDs: {', '.join(str(id) for id in not_found_ids)}")
            
            else:
                print("Error: Must provide --project-ids")
                return

            if not projects_to_delete:
                print("No projects found matching the criteria")
                return

            # Show what will be deleted
            print("\nProjects that will be deleted:")
            print(self._format_project_output(projects_to_delete))
            
            if args.dry_run:
                return
            
            if not args.force:
                confirm = input(f"\nAre you sure you want to delete {len(projects_to_delete)} "
                            f"projects? (yes/no): ")
                if confirm.lower() != 'yes':
                    print("Operation cancelled")
                    return

            # Perform deletion
            success_count = 0
            error_count = 0
            
            for project in projects_to_delete:
                success = self._delete_single_project(project)
                print(f"Deleted project {project.id}: {project.project_name} -> Status: {'success' if success else 'failed'}")
                if success:
                    success_count += 1
                else:
                    error_count += 1

            print(f"\nDeletion complete: {success_count} succeeded, {error_count} failed")

    def _handle_conversation_commands(self, args):
        """Handle all conversation-related commands."""
        if args.command == 'create-conversation':
            result = self._make_api_call(
                CustomGPT.Conversation.create,
                project_id=args.project_id,
                name=args.name
            )
            
            if not result:
                print("Error: Failed to create conversation")
                sys.exit(1)
                
            try:
                response_data = json.loads(result.content)
                if args.format == 'json':
                    print(json.dumps(response_data, indent=2))
                else:
                    print(f"Successfully created conversation with ID: {response_data['data']['id']}")
            except Exception as e:
                print(f"Error parsing response: {str(e)}")
                sys.exit(1)
                
        elif args.command == 'update-conversation':
            result = self._make_api_call(
                CustomGPT.Conversation.update,
                project_id=args.project_id,
                session_id=args.session_id,
                name=args.name
            )
            
            if not result:
                print("Error: Failed to update conversation")
                sys.exit(1)
                
            try:
                response_data = json.loads(result.content)
                if args.format == 'json':
                    print(json.dumps(response_data, indent=2))
                else:
                    print(f"Successfully updated conversation {args.session_id}")
            except Exception as e:
                print(f"Error parsing response: {str(e)}")
                sys.exit(1)
                
        elif args.command == 'delete-conversation':
            if not args.force:
                confirm = input(f"Are you sure you want to delete conversation {args.session_id}? (yes/no): ")
                if confirm.lower() != 'yes':
                    print("Operation cancelled")
                    return
                    
            result = self._make_api_call(
                CustomGPT.Conversation.delete,
                project_id=args.project_id,
                session_id=args.session_id
            )
            
            if not result:
                print("Error: Failed to delete conversation")
                sys.exit(1)
                
            try:
                response_data = json.loads(result.content)
                if response_data.get('data', {}).get('deleted'):
                    print(f"Successfully deleted conversation {args.session_id}")
                else:
                    print("Failed to delete conversation")
            except Exception as e:
                print(f"Error parsing response: {str(e)}")
                sys.exit(1)
                
        elif args.command == 'send-message':
            api_args = {
                'project_id': args.project_id,
                'session_id': args.session_id,
                'prompt': args.prompt,
                'stream': args.stream
            }
            
            # Add optional parameters if provided
            if hasattr(args, 'persona') and args.persona:
                api_args['custom_persona'] = args.persona
            if hasattr(args, 'model') and args.model:
                api_args['chatbot_model'] = args.model
            if hasattr(args, 'response_source') and args.response_source:
                api_args['response_source'] = args.response_source

            try:
                if args.stream:
                    # Handle streaming response
                    result = CustomGPT.Conversation.send(**api_args)
                    if result and hasattr(result, 'events'):
                        try:
                            if args.format == 'json':
                                # JSON format: print full event data
                                for event in result.events():
                                    if hasattr(event, 'data'):
                                        print(event.data)
                            else:
                                # Typing effect: only print progress messages
                                import sys
                                import time

                                for event in result.events():
                                    if hasattr(event, 'data'):
                                        try:
                                            event_data = json.loads(event.data)
                                            if event_data.get('status') == 'progress' and 'message' in event_data:
                                                sys.stdout.write(event_data['message'])
                                                sys.stdout.flush()
                                                # Small delay for typing effect (50ms)
                                                time.sleep(0.05)
                                        except json.JSONDecodeError:
                                            continue
                                # Add newline at the end
                                print()
                        except Exception as e:
                            print(f"Error in stream processing: {str(e)}", file=sys.stderr)
                            sys.exit(1)
                    else:
                        print("Error: No streaming response received", file=sys.stderr)
                        sys.exit(1)
                else:
                    # Handle non-streaming response
                    result = self._make_api_call(CustomGPT.Conversation.send, **api_args)
                    if result:
                        try:
                            response_data = json.loads(result.content)
                            if args.format == 'json':
                                print(json.dumps(response_data, indent=2))
                            else:
                                print(response_data.get('data', {}).get('openai_response', 'No response received'))
                        except Exception as e:
                            print(f"Error parsing response: {str(e)}", file=sys.stderr)
                            sys.exit(1)
                    else:
                        print("Error: Failed to send message", file=sys.stderr)
                        sys.exit(1)
            except Exception as e:
                print(f"Error sending message: {str(e)}", file=sys.stderr)
                sys.exit(1)

        elif args.command == 'get-messages':
            result = self._make_api_call(
                CustomGPT.Conversation.messages,
                project_id=args.project_id,
                session_id=args.session_id,
                page=args.page if hasattr(args, 'page') else 1,
                order=args.order if hasattr(args, 'order') else 'desc'
            )
            
            if not result:
                print("Error: Failed to retrieve messages")
                sys.exit(1)
                
            try:
                response_data = json.loads(result.content)
                if args.format == 'json':
                    print(json.dumps(response_data, indent=2))
                else:
                    messages = response_data.get('data', {}).get('messages', {}).get('data', [])
                    if not messages:
                        print("No messages found")
                    else:
                        for msg in messages:
                            print(f"Message ID: {msg.get('id')}")
                            print(f"Query: {msg.get('user_query')}")
                            print(f"Response: {msg.get('openai_response')}")
                            print("-" * 50)
            except Exception as e:
                print(f"Error parsing response: {str(e)}")
                sys.exit(1)
                
        elif args.command == 'get-message':
            result = self._make_api_call(
                CustomGPT.Message.get,
                project_id=args.project_id,
                session_id=args.session_id,
                prompt_id=args.prompt_id
            )
            
            if not result:
                print("Error: Failed to retrieve message")
                sys.exit(1)
                
            try:
                response_data = json.loads(result.content)
                if args.format == 'json':
                    print(json.dumps(response_data, indent=2))
                else:
                    msg = response_data.get('data', {})
                    print(f"Message ID: {msg.get('id')}")
                    print(f"Query: {msg.get('user_query')}")
                    print(f"Response: {msg.get('openai_response')}")
                    if msg.get('citations'):
                        print("\nCitations:", msg.get('citations'))
                    if msg.get('response_feedback'):
                        print("\nFeedback:", msg.get('response_feedback'))
            except Exception as e:
                print(f"Error parsing response: {str(e)}")
                sys.exit(1)
                
        elif args.command == 'update-message-feedback':
            result = self._make_api_call(
                CustomGPT.Message.feedback,
                project_id=args.project_id,
                session_id=args.session_id,
                prompt_id=args.prompt_id,
                reaction=args.reaction
            )
            
            if not result:
                print("Error: Failed to update message feedback")
                sys.exit(1)
                
            try:
                response_data = json.loads(result.content)
                if args.format == 'json':
                    print(json.dumps(response_data, indent=2))
                else:
                    print(f"Successfully updated feedback for message {args.prompt_id}")
            except Exception as e:
                print(f"Error parsing response: {str(e)}")
                sys.exit(1)

    def _handle_page_commands(self, args):
        """Handle all page-related commands."""
        if args.command == 'get-pages':
            result = self._make_api_call(
                CustomGPT.Page.get,
                project_id=args.project_id,
                page=args.page,
                duration=args.duration,
                order=args.order
            )
            
        elif args.command == 'delete-page':
            result = self._make_api_call(
                CustomGPT.Page.delete,
                project_id=args.project_id,
                page_id=args.page_id
            )
            
        elif args.command == 'reindex-page':
            result = self._make_api_call(
                CustomGPT.Page.reindex,
                project_id=args.project_id,
                page_id=args.page_id
            )
        
        self._handle_default_format(result)

    def _handle_citations_commands(self, args):
        """Handle all citations-related commands."""
        if args.command == 'get-citation':
            result = self._make_api_call(
                CustomGPT.Citation.get,
                project_id=args.project_id,
                citation_id=args.citation_id
        )
        
        self._handle_default_format(result)
    
    def _handle_sources_commands(self, args):
        """Handle all sources-related commands based on OpenAPI/openapi.json."""
        try:
            if args.command == 'list-sources':
                result = self._make_api_call(
                    CustomGPT.Source.list,
                    project_id=args.project_id
                )

            elif args.command == 'create-source':
                if args.file:
                    if not os.path.exists(args.file):
                        print(f"Error: File {args.file} does not exist")
                        sys.exit(1)
                    try:
                        with open(args.file, 'rb') as f:
                            file_content = f.read()
                        result = self._make_api_call(
                            CustomGPT.Source.create,
                            project_id=args.project_id,
                            file_data_retension=args.file_data_retension,
                            is_ocr_enabled=args.is_ocr_enabled,
                            is_anonymized=args.is_anonymized,
                            file=File(payload=file_content, file_name=os.path.basename(args.file))
                        )
                    except IOError as e:
                        print(f"Error reading file: {e}")
                        sys.exit(1)
                else:
                    if not args.sitemap_path:
                        print("Error: Either file or sitemap_path must be provided")
                        sys.exit(1)
                    result = self._make_api_call(
                        CustomGPT.Source.create,
                        project_id=args.project_id,
                        sitemap_path=args.sitemap_path,
                        file_data_retension=args.file_data_retension,
                        is_ocr_enabled=args.is_ocr_enabled,
                        is_anonymized=args.is_anonymized
                    )

            elif args.command == 'update-source':
                result = self._make_api_call(
                    CustomGPT.Source.update,
                    project_id=args.project_id,
                    source_id=args.source_id,
                    executive_js=args.executive_js,
                    data_refresh_frequency=args.data_refresh_frequency,
                    create_new_pages=args.create_new_pages,
                    remove_unexist_pages=args.remove_unexist_pages,
                    refresh_existing_pages=args.refresh_existing_pages
                )

            elif args.command == 'delete-source':
                result = self._make_api_call(
                    CustomGPT.Source.delete,
                    project_id=args.project_id,
                    source_id=args.source_id
                )

            elif args.command == 'sync-source':
                result = self._make_api_call(
                    CustomGPT.Source.synchronize,
                    project_id=args.project_id,
                    source_id=args.source_id
                )
            self._handle_default_format(result)
        except Exception as e:
            print(f"Failed to perform source {args.command}")
            sys.exit(1)

    def _handle_reports_commands(self, args):
        """Handle all reports-related commands based on OpenAPI/openapi.json."""
        try:
            if args.command == 'get-traffic-report':
                result = self._make_api_call(
                    CustomGPT.ReportsAnalytics.traffic,
                    project_id=args.project_id,
                    filters=args.filters
                )

            elif args.command == 'get-queries-report':
                result = self._make_api_call(
                    CustomGPT.ReportsAnalytics.queries,
                    project_id=args.project_id,
                    filters=args.filters
                )

            elif args.command == 'get-conversations-report':
                result = self._make_api_call(
                    CustomGPT.ReportsAnalytics.conversations,
                    project_id=args.project_id,
                    filters=args.filters
                )
            
            elif args.command == 'get-analysis-report':
                result = self._make_api_call(
                    CustomGPT.ReportsAnalytics.analysis,
                    project_id=args.project_id,
                    filters=args.filters,
                    interval=args.interval
                )
            
            self._handle_default_format(result)
        except Exception as e:
            print(f"Failed to perform report {args.command}")
            sys.exit(1)
    
    def _handle_user_commands(self, args):
        """Handle all user-related commands based on OpenAPI/openapi.json."""
        try:
            if args.command == 'get-user':
                result = self._make_api_call(
                    CustomGPT.User.get
                )
            
            self._handle_default_format(result)
        except Exception as e:
            print(f"Failed to perform user {args.command}")
            sys.exit(1)
    
    def _handle_project_settings_commands(self, args):
        """Handle all project settings-related commands based on OpenAPI/openapi.json."""
        try:
            if args.command == 'get-project-settings':
                result = self._make_api_call(
                    CustomGPT.ProjectSettings.get,
                    project_id=args.project_id
                )

            elif args.command == 'update-project-settings':
                kwargs = {
                    'project_id': args.project_id,
                }
                if args.chatbot_avatar:
                    if not os.path.exists(args.chatbot_avatar):
                        print(f"Error: Avatar file '{args.chatbot_avatar}' does not exist")
                        sys.exit(1)
                    kwargs['chat_bot_avatar'] = File(payload=open(args.chatbot_avatar, 'rb'), file_name=os.path.basename(args.chatbot_avatar))
                if args.chatbot_background:
                    if not os.path.exists(args.chatbot_background):
                        print(f"Error: Background file '{args.chatbot_background}' does not exist")
                        sys.exit(1)
                    kwargs['chat_bot_bg'] = File(payload=open(args.chatbot_background, 'rb'), file_name=os.path.basename(args.chatbot_background))
                if args.default_prompt:
                    kwargs['default_prompt'] = args.default_prompt
                if args.example_questions:
                    try:
                        questions = ast.literal_eval(args.example_questions)
                        if not isinstance(questions, list):
                            print("Error: example_questions must be a list of strings")
                            sys.exit(1)
                        if not all(isinstance(q, str) for q in questions):
                            print("Error: all example questions must be strings")
                            sys.exit(1)
                        kwargs['example_questions'] = questions
                    except (ValueError, SyntaxError) as e:
                        print(f"Error parsing example_questions: {e}")
                        sys.exit(1)
                if args.response_source:
                    kwargs['response_source'] = args.response_source
                if args.chatbot_msg_lang:
                    kwargs['chatbot_msg_lang'] = args.chatbot_msg_lang
                if args.chatbot_color:
                    kwargs['chatbot_color'] = args.chatbot_color
                if args.chatbot_toolbar_color:
                    kwargs['chatbot_toolbar_color'] = args.chatbot_toolbar_color
                if args.persona_instructions:
                    kwargs['persona_instructions'] = args.persona_instructions
                if args.citations_answer_source_label_msg:
                    kwargs['citations_answer_source_label_msg'] = args.citations_answer_source_label_msg
                if args.citations_sources_label_msg:
                    kwargs['citations_sources_label_msg'] = args.citations_sources_label_msg
                if args.hang_in_there_msg:
                    kwargs['hang_in_there_msg'] = args.hang_in_there_msg
                if args.chatbot_siesta_msg:
                    kwargs['chatbot_siesta_msg'] = args.chatbot_siesta_msg
                if args.is_loading_indicator_enabled:
                    kwargs['is_loading_indicator_enabled'] = args.is_loading_indicator_enabled
                if args.enable_citations:
                    kwargs['enable_citations'] = args.enable_citations
                if args.enable_feedbacks:
                    kwargs['enable_feedbacks'] = args.enable_feedbacks
                if args.citations_view_type:
                    kwargs['citations_view_type'] = args.citations_view_type
                if args.no_answer_message:
                    kwargs['no_answer_message'] = args.no_answer_message
                if args.ending_message:
                    kwargs['ending_message'] = args.ending_message
                if args.remove_branding:
                    kwargs['remove_branding'] = args.remove_branding
                if args.enable_recaptcha_for_public_chatbots:
                    kwargs['enable_recaptcha_for_public_chatbots'] = args.enable_recaptcha_for_public_chatbots
                if args.chatbot_model:
                    kwargs['chatbot_model'] = args.chatbot_model
                if args.is_selling_enabled:
                    kwargs['is_selling_enabled'] = args.is_selling_enabled
                result = self._make_api_call(
                    CustomGPT.ProjectSettings.update,
                    **kwargs
                )
            
            self._handle_default_format(result)
        except Exception as e:
            print(f"Failed to perform project settings {args.command}")
            sys.exit(1)
    
    def _handle_plugins_commands(self, args):
        """Handle all plugins-related commands based on OpenAPI/openapi.json."""
        try:
            if args.command == 'list-plugins':
                result = self._make_api_call(
                    CustomGPT.ProjectPlugins.get,
                    project_id=args.project_id
                )

            elif args.command == 'create-plugin':
                result = self._make_api_call(
                    CustomGPT.ProjectPlugins.create,
                    project_id=args.project_id,
                    model_name=args.model_name,
                    human_name=args.human_name,
                    keywords=args.keywords,
                    description=args.description,
                    is_active=args.is_active
                )

            elif args.command == 'update-plugin':
                result = self._make_api_call(
                    CustomGPT.ProjectPlugins.update,
                    project_id=args.project_id,
                    model_name=args.model_name,
                    human_name=args.human_name,
                    keywords=args.keywords,
                    description=args.description,
                    is_active=args.is_active
                )
            self._handle_default_format(result)
        except Exception as e:
            print(f"Failed to perform plugin {args.command}")
            sys.exit(1)

    def _handle_limits_commands(self, args):
        """Handle all limits-related commands based on OpenAPI/openapi.json."""
        try:
            if args.command == 'get-limits':
                result = self._make_api_call(
                    CustomGPT.Limit.get
                )
            self._handle_default_format(result)
        except Exception as e:
            print(f"Failed to perform limits {args.command}")
            sys.exit(1)
    
    def _handle_page_metadata_commands(self, args):
        """Handle all page metadata-related commands based on OpenAPI/openapi.json."""
        try:
            if args.command == 'get-page-metadata':
                result = self._make_api_call(
                    CustomGPT.PageMetadata.get,
                    project_id=args.project_id,
                    page_id=args.page_id
                )

            elif args.command == 'update-page-metadata':
                result = self._make_api_call(
                    CustomGPT.PageMetadata.update,
                    project_id=args.project_id,
                    page_id=args.page_id,
                    title=args.title,
                    url=args.url,
                    description=args.description,
                    image=args.image
                )
            
            self._handle_default_format(result)
        except Exception as e:
            print(f"Failed to perform page metadata {args.command}")
            sys.exit(1)
    
    def _handle_preview_commands(self, args):
        """Handle all preview-related commands based on OpenAPI/openapi.json."""
        try:
            if args.command == 'preview-file':
                result = self._make_api_call(
                    CustomGPT.Page.preview,
                    id=args.id
                )
                
            self._handle_default_format(result)
        except Exception as e:
            print(f"Failed to perform preview {args.command}")
            sys.exit(1)

    def run(self):
        args = self.parser.parse_args()
        
        if not args.command:
            self.parser.print_help()
            return
            
        # Get API key from argument or environment variable
        api_key = args.api_key or os.environ.get('CUSTOMGPT_API_KEY')
        if not api_key:
            print("Error: API key must be provided via --api-key argument or CUSTOMGPT_API_KEY environment variable")
            sys.exit(1)
            
        # Set API key
        CustomGPT.api_key = api_key
        
        # Handle commands by category
        if args.command in ['create-project', 'show-project', 'list-projects', 'update-project', 'delete-projects', 'replicate-project', 'project-stats']:
            self._handle_project_commands(args)
        elif args.command in ['create-conversation', 'update-conversation', 'delete-conversation', 'send-message', 'get-messages', 'get-message', 'update-message-feedback' ]:
            self._handle_conversation_commands(args)
        elif args.command in ['get-pages', 'delete-page', 'reindex-page']:
            self._handle_page_commands(args)
        elif args.command in ['get-citation']:
            self._handle_citations_commands(args)
        elif args.command in ['list-sources', 'create-source', 'update-source', 'delete-source', 'sync-source']:
            self._handle_sources_commands(args)
        elif args.command in ['get-traffic-report', 'get-queries-report', 'get-conversations-report', 'get-analysis-report']:
            self._handle_reports_commands(args)
        elif args.command in ['get-user']:
            self._handle_user_commands(args)
        elif args.command in ['get-project-settings', 'update-project-settings']:
            self._handle_project_settings_commands(args)
        elif args.command in ['list-plugins', 'create-plugin', 'update-plugin', 'delete-plugin']:
            self._handle_plugins_commands(args)
        elif args.command in ['preview-file']:
            self._handle_preview_commands(args)
        elif args.command in ['get-page-metadata', 'update-page-metadata']:
            self._handle_page_metadata_commands(args)
        elif args.command in ['get-limits']:
            self._handle_limits_commands(args)

def main():
    cli = CustomGPTCLI()
    cli.run()

if __name__ == "__main__":
    main()

```

Contents of customgpt_cli/__pycache__/__init__.cpython-39.pyc:
```
[Could not decode file contents]

```

Contents of customgpt_cli/__pycache__/cli.cpython-39.pyc:
```
[Could not decode file contents]

```

Contents of tests/test_citations.sh:
```
# citations test shell script based on customgpt_cli/openapi.json

export PROJECT_ID=51241
UUID=4a4f4547-9a47-4402-a620-339f78ed947f
# $(uuidgen)
echo "UUID: $UUID"

echo "Testing citations command"

# foll parse_citations in cli.py

CITATION_ID=$(customgpt-cli send-message --project-id $PROJECT_ID --session-id $UUID --prompt "Tell me about your knowledge base in 10 words." --format json | jq -r '.data.citations[0]')

echo "CITATION_ID: $CITATION_ID"
customgpt-cli get-citation --project-id $PROJECT_ID --citation-id $CITATION_ID
```

Contents of tests/test_conversations.sh:
```
# First, set your environment variables
export PROJECT_ID=52093

# 1. Create a new conversation
customgpt-cli create-conversation --project-id $PROJECT_ID --name "Test Conversation" --format json

# 2. Create a conversation and save the session ID
SESSION_ID=$(customgpt-cli create-conversation --project-id $PROJECT_ID --name "Test Conversation" --format json | jq -r '.data.session_id')
echo $SESSION_ID

# 3. Update the conversation name
customgpt-cli update-conversation --project-id $PROJECT_ID --session-id $SESSION_ID --name "Updated Name" --format json

# 4. Send a basic message
customgpt-cli send-message --project-id $PROJECT_ID --session-id $SESSION_ID --prompt "Tell me about project management" --format json

# 5. Send a message with GPT-4 Turbo
customgpt-cli send-message --project-id $PROJECT_ID --session-id $SESSION_ID --prompt "Explain agile" --model gpt-4-turbo --format json

# 6. Send a message with custom persona
customgpt-cli send-message --project-id $PROJECT_ID --session-id $SESSION_ID --prompt "Best practices?" --persona "Technical expert" --format json

# 7. Send a message and save the prompt ID
PROMPT_ID=$(customgpt-cli send-message --project-id $PROJECT_ID --session-id $SESSION_ID --prompt "Test message" --format json | jq -r '.data.id')
echo $PROMPT_ID

# 9. Get all messages in ascending order
customgpt-cli get-messages --project-id $PROJECT_ID --session-id $SESSION_ID --order asc --page 1 --format json

# 10. Get all messages in descending order
customgpt-cli get-messages --project-id $PROJECT_ID --session-id $SESSION_ID --order desc --page 1 --format json

# 11. Get a specific message
customgpt-cli get-message --project-id $PROJECT_ID --session-id $SESSION_ID --prompt-id $PROMPT_ID --format json

# 8. Update message feedback
customgpt-cli update-message-feedback --project-id $PROJECT_ID --session-id $SESSION_ID --prompt-id $PROMPT_ID --reaction liked --format json


# 12. Test conversations
# First create a conversation

# Test different message configurations without streaming
echo "=== Testing Basic Message ==="
customgpt-cli send-message \
    --project-id $PROJECT_ID \
    --session-id $SESSION_ID \
    --prompt "Tell me about project management" \
    --format json | jq '.'

echo "=== Testing with GPT-4 Turbo ==="
customgpt-cli send-message \
    --project-id $PROJECT_ID \
    --session-id $SESSION_ID \
    --prompt "Explain agile methodologies" \
    --model gpt-4-turbo \
    --format json | jq '.'

echo "=== Testing with Custom Persona ==="
customgpt-cli send-message \
    --project-id $PROJECT_ID \
    --session-id $SESSION_ID \
    --prompt "What are the best project management tools?" \
    --persona "Technical expert" \
    --format json | jq '.'

echo "=== Testing with Own Content Response Source ==="
customgpt-cli send-message \
    --project-id $PROJECT_ID \
    --session-id $SESSION_ID \
    --prompt "Compare waterfall and agile methodologies" \
    --response-source own_content \
    --format json | jq '.'


# 12a. Test streaming mode 
customgpt-cli send-message --project-id $PROJECT_ID --session-id $SESSION_ID --prompt "Write a story" --stream

# 13. Delete the conversation
customgpt-cli delete-conversation --project-id $PROJECT_ID --session-id $SESSION_ID --force

# Error test cases
# 14. Test invalid session ID
customgpt-cli send-message --project-id $PROJECT_ID --session-id "invalid_id" --prompt "Test" --format json

# 15. Test invalid project ID
customgpt-cli create-conversation --project-id 999999999 --name "Test" --format json

# Quick cleanup script
cleanup_test() {
    local session_id=$1
    echo "Cleaning up conversation $session_id..."
    customgpt-cli delete-conversation \
        --project-id $PROJECT_ID \
        --session-id $session_id \
        --force 
}
cleanup_test $SESSION_ID

```

Contents of tests/test_limits.sh:
```
# test limits cli commands

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color
BLUE='\033[0;34m'

# Helper function for printing
print_header() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

# Function to check command success
check_success() {
    if [ $? -eq 0 ]; then
        print_success "$1"
    else
        print_error "$1"
        if [ "$2" = "exit" ]; then
            exit 1
        fi
    fi
}

print_header "Testing get-limits command"
customgpt-cli get-limits
check_success "Get limits"
```

Contents of tests/test_page_metadata.sh:
```
export PROJECT_ID=51241

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color
BLUE='\033[0;34m'

# Helper function for printing
print_header() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

# Function to check command success
check_success() {
    if [ $? -eq 0 ]; then
        print_success "$1"
    else
        print_error "$1"
        if [ "$2" = "exit" ]; then
            exit 1
        fi
    fi
}

# Test page metadata
print_header "Testing get-page-metadata command"
PAGE_ID=$(customgpt-cli get-pages --project-id $PROJECT_ID --page 1 | jq -r '.data.pages.data[0].id')
customgpt-cli get-page-metadata --project-id $PROJECT_ID --page-id $PAGE_ID
check_success "Get page metadata"

print_header "Testing update-page-metadata command"
customgpt-cli update-page-metadata --project-id $PROJECT_ID --page-id $PAGE_ID --title "Test Title" --url "https://app.customgpt.ai" --description "This is a test page." --image "https://app.customgpt.ai/assets/imgs/default_chatbot_avatar.png"
check_success "Update page metadata"

```

Contents of tests/test_pages.sh:
```
#!/bin/bash
export PROJECT_ID=51241
# First, set your environment variables
export TEST_PROJECT_NAME="CLI Test Project $(date +%s)"
export SITEMAP_URL="https://adorosario.github.io/small-sitemap.xml"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color
BLUE='\033[0;34m'

# Helper function for printing
print_header() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

# Function to check command success
check_success() {
    if [ $? -eq 0 ]; then
        print_success "$1"
    else
        print_error "$1"
        if [ "$2" = "exit" ]; then
            exit 1
        fi
    fi
}

# use _handle_pages_commands to test all page-related commands

# Test pages
print_header "Testing pages command"
PAGE_ID=$(customgpt-cli get-pages --project-id $PROJECT_ID | grep -A10 '"pages": {' | grep -o '"id": [0-9]*' | head -1 | awk '{print $2}')
echo "PAGE_ID: $PAGE_ID"
check_success "List pages"
# Test sync page
print_header "Testing sync-page command"
customgpt-cli reindex-page --project-id $PROJECT_ID --page-id $PAGE_ID
check_success "Sync page"

# Test delete page
print_header "Testing delete-page command"
# customgpt-cli delete-page --project-id $PROJECT_ID --page-id $PAGE_ID
check_success "Delete page"

# use all filters to test get-pages command

# Test get-pages command with filters
print_header "Testing get-pages command with filters"
customgpt-cli get-pages --project-id $PROJECT_ID --page $PAGE_ID --duration 90 --order asc
check_success "Get pages with filters"
```

Contents of tests/test_plugins.sh:
```
export PROJECT_ID=51241

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color
BLUE='\033[0;34m'

# Helper function for printing
print_header() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

# Function to check command success
check_success() {
    if [ $? -eq 0 ]; then
        print_success "$1"
    else
        print_error "$1"
        if [ "$2" = "exit" ]; then
            exit 1
        fi
    fi
}

# Test plugins
print_header "Testing list-plugins command"
customgpt-cli list-plugins --project-id $PROJECT_ID
check_success "List plugins"

print_header "Testing create-plugin command"
customgpt-cli create-plugin --project-id $PROJECT_ID --model-name "TestPlugin" --human-name "Test Assistant" --keywords "test,automation" --description "This is a helpful automation tool." --is-active
check_success "Create plugin"

print_header "Testing update-plugin command"
customgpt-cli update-plugin --project-id $PROJECT_ID --model-name "Updated" --human-name "Updated Assistant" --keywords "updated,assistant" --description "Trusted information about indoor plants and gardening." --is-active
check_success "Update plugin"

```

Contents of tests/test_project_settings.sh:
```
# test project settings

# First, set your environment variables
export PROJECT_ID=51241

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color
BLUE='\033[0;34m'

# Helper function for printing
print_header() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

# Function to check command success
check_success() {
    if [ $? -eq 0 ]; then
        print_success "$1"
    else
        print_error "$1"
        if [ "$2" = "exit" ]; then
            exit 1
        fi
    fi
}
    
# Test project settings
print_header "Testing project settings command"
customgpt-cli get-project-settings --project-id $PROJECT_ID
check_success "Get project settings"

print_header "Testing update-project-settings command"
customgpt-cli update-project-settings --project-id $PROJECT_ID --default-prompt "Test prompt" --chatbot-avatar "./tests/files/test.png" --chatbot-background "./tests/files/test.png" --example-questions '["Test questions"]' --response-source "default" --chatbot-msg-lang "en" --chatbot-color "#0e57cc" --chatbot-toolbar-color "#0e57cc" --persona-instructions "Test instructions" --citations-answer-source-label-msg "Test label" --citations-sources-label-msg "Test label" --hang-in-there-msg "Test message" --chatbot-siesta-msg "Test message" --is-loading-indicator-enabled --enable-citations 0 --enable-feedbacks --citations-view-type "user" --no-answer-message "Test message" --ending-message "Test message" --remove-branding --enable-recaptcha-for-public-chatbots --chatbot-model "gpt-4-o" --is-selling-enabled --license-slug "test" --selling-url "test"
check_success "Update project settings"

```

Contents of tests/test_projects.sh:
```
#!/bin/bash

# First, set your environment variables
export TEST_PROJECT_NAME="CLI Test Project $(date +%s)"
export SITEMAP_URL="https://adorosario.github.io/small-sitemap.xml"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color
BLUE='\033[0;34m'

# Helper function for printing
print_header() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

# Function to check command success
check_success() {
    if [ $? -eq 0 ]; then
        print_success "$1"
    else
        print_error "$1"
        if [ "$2" = "exit" ]; then
            exit 1
        fi
    fi
}

# Test listing projects
# print_header "Testing list-projects command"
# customgpt-cli list-projects
# check_success "List projects (table format)"

# customgpt-cli list-projects --format json
# check_success "List projects (JSON format)"

# customgpt-cli list-projects --format id-only
# check_success "List projects (ID only format)"

# Test creating a new project
print_header "Testing create-project command"
NEW_PROJECT_ID=$(customgpt-cli create-project --name "$TEST_PROJECT_NAME" --sitemap "$SITEMAP_URL" --format id-only)
check_success "Create new project" "exit"
print_success "New project ID: $NEW_PROJECT_ID"

# Test showing project details
print_header "Testing show-project command"
customgpt-cli show-project --project-id $NEW_PROJECT_ID
check_success "Show project details (table format)"

customgpt-cli show-project --project-id $NEW_PROJECT_ID --format json
check_success "Show project details (JSON format)"

# Test project stats
print_header "Testing project-stats command"
customgpt-cli project-stats --project-id $NEW_PROJECT_ID
check_success "Get project stats (table format)"

customgpt-cli project-stats --project-id $NEW_PROJECT_ID --format json
check_success "Get project stats (JSON format)"

# Test updating project
print_header "Testing update-project command"
UPDATED_NAME="$TEST_PROJECT_NAME Updated"
customgpt-cli update-project --project-id $NEW_PROJECT_ID --name "$UPDATED_NAME"
check_success "Update project name"

# Test project replication
print_header "Testing replicate-project command"
REPLICATED_PROJECT_ID=$(customgpt-cli replicate-project --project-id $NEW_PROJECT_ID --format id-only)
check_success "Replicate project"
print_success "Replicated project ID: $REPLICATED_PROJECT_ID"

# Test project deletion
print_header "Testing delete-projects command"
echo "Deleting both original and replicated projects..."
customgpt-cli delete-projects --project-ids "$NEW_PROJECT_ID,$REPLICATED_PROJECT_ID" --force
check_success "Delete projects"

# Additional filtering tests for list-projects
print_header "Testing list-projects with filters"
customgpt-cli list-projects --name-filter "Test" --format json
check_success "List projects with name filter"

customgpt-cli list-projects --inactive-days 30 --format json
check_success "List projects with inactivity filter"

customgpt-cli list-projects --min-queries 10 --max-queries 1000 --format json
check_success "List projects with query count filters"

customgpt-cli list-projects \
    --min-pages-found 1 \
    --min-pages-crawled 1 \
    --min-pages-indexed 1 \
    --min-words-indexed 1000 \
    --format json
check_success "List projects with comprehensive stats filters"

# Final summary
print_header "Test Summary"
echo -e "${GREEN}Project command tests completed.${NC}"
echo "Note: Some tests might show expected errors for invalid inputs or non-existent projects."
echo "Remember to check the output manually for expected results."

# Clean up environment variables
unset TEST_PROJECT_NAME
unset SITEMAP_URL

```

Contents of tests/test_reports.sh:
```
# test reports cli commands

PROJECT_ID=51241

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color
BLUE='\033[0;34m'

# Helper function for printing
print_header() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

# Function to check command success
check_success() {
    if [ $? -eq 0 ]; then
        print_success "$1"
    else
        print_error "$1"
        if [ "$2" = "exit" ]; then
            exit 1
        fi
    fi
}

print_header "Testing get-traffic-report command"
customgpt-cli get-traffic-report --project-id $PROJECT_ID --filters '["traffic", "pages"]'
check_success "Get traffic report"

print_header "Testing get-queries-report command"
customgpt-cli get-queries-report --project-id $PROJECT_ID --filters '["queries", "pages"]'
check_success "Get queries report"

print_header "Testing get-conversations-report command"
customgpt-cli get-conversations-report --project-id $PROJECT_ID --filters '["conversations", "pages"]'
check_success "Get conversations report"

print_header "Testing get-analysis-report command"
customgpt-cli get-analysis-report --project-id $PROJECT_ID --filters '["analysis", "pages"]'
check_success "Get analysis report"
```

Contents of tests/test_sources.sh:
```
#test sources

# First, set your environment variables
export PROJECT_ID=52093
# First, set your environment variables
export TEST_PROJECT_NAME="CLI Test Project $(date +%s)"
export SITEMAP_URL="https://adorosario.github.io/small-sitemap.xml"

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color
BLUE='\033[0;34m'

# Helper function for printing
print_header() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

# Function to check command success
check_success() {
    if [ $? -eq 0 ]; then
        print_success "$1"
    else
        print_error "$1"
        if [ "$2" = "exit" ]; then
            exit 1
        fi
    fi
}

# Test sources
print_header "Testing sources command"
customgpt-cli list-sources --project-id $PROJECT_ID
check_success "List sources"

# Test create source
print_header "Testing create-source command with sitemap"
SOURCE_ID=$(customgpt-cli create-source --project-id $PROJECT_ID --sitemap-path $SITEMAP_URL --file-data-retension --is-ocr-enabled --is-anonymized | jq -r '.data.id')
echo "SOURCE_ID: $SOURCE_ID"
check_success "Create source with sitemap"

# Test create source with file
print_header "Testing create-source command with file"
customgpt-cli create-source --project-id $PROJECT_ID --file ./tests/files/test.pdf --file-data-retension --is-ocr-enabled --is-anonymized
check_success "Create source with file"

# # Test update source
print_header "Testing update-source command"
customgpt-cli update-source --project-id $PROJECT_ID --source-id $SOURCE_ID --executive-js --data-refresh-frequency never --create-new-pages --remove-unexist-pages --refresh-existing-pages always --refresh-schedule ["00:00","08:00"]
check_success "Update source"


# Test delete source
print_header "Testing delete-source command"
customgpt-cli delete-source --project-id $PROJECT_ID --source-id $SOURCE_ID
check_success "Delete source"

# Test sync source
print_header "Testing sync-source command"
customgpt-cli sync-source --project-id $PROJECT_ID --source-id $SOURCE_ID
check_success "Sync source"
```

Contents of tests/test_user.sh:
```
# test user cli commands

GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color
BLUE='\033[0;34m'

# Helper function for printing
print_header() {
    echo -e "\n${BLUE}=== $1 ===${NC}\n"
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_error() {
    echo -e "${RED}✗ $1${NC}"
}

# Function to check command success
check_success() {
    if [ $? -eq 0 ]; then
        print_success "$1"
    else
        print_error "$1"
        if [ "$2" = "exit" ]; then
            exit 1
        fi
    fi
}

print_header "Testing get-user command"
customgpt-cli get-user
check_success "Get user"
```

Contents of tests/files/test.pdf:
```
[Could not decode file contents]

```

Contents of tests/files/test.png:
```
[Could not decode file contents]

```

Contents of customgpt_cli.egg-info/PKG-INFO:
```
Metadata-Version: 2.1
Name: customgpt-cli
Version: 0.1.0
Summary: UNKNOWN
Home-page: UNKNOWN
License: UNKNOWN
Platform: UNKNOWN

UNKNOWN


```

Contents of customgpt_cli.egg-info/dependency_links.txt:
```


```

Contents of customgpt_cli.egg-info/entry_points.txt:
```
[console_scripts]
customgpt-cli = customgpt_cli.cli:main


```

Contents of customgpt_cli.egg-info/requires.txt:
```
customgpt-client>=1.1.6
tabulate>=0.9.0

```

Contents of customgpt_cli.egg-info/top_level.txt:
```
customgpt_cli

```

Contents of customgpt_cli.egg-info/SOURCES.txt:
```
README.md
setup.py
customgpt_cli/__init__.py
customgpt_cli/cli.py
customgpt_cli.egg-info/PKG-INFO
customgpt_cli.egg-info/SOURCES.txt
customgpt_cli.egg-info/dependency_links.txt
customgpt_cli.egg-info/entry_points.txt
customgpt_cli.egg-info/requires.txt
customgpt_cli.egg-info/top_level.txt
```

